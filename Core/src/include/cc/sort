/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the GNU General Public License version 3
 * (see CoreComponents/LICENSE-gpl-3.0).
 *
 */

#pragma once

#include <cc/order>
#include <utility>

namespace cc {

template<class Container, class Order = Asc>
class HeapSort
{
public:
    void operator()(Container &container, const Order &order = Order{})
    {
        using std::swap;

        if (container.count() < 2) return;

        for (long fill = 2; fill <= container.count(); ++fill)
            shuffleUp(container, order, fill);

        for (auto pos = container.tail(); pos; --pos) {
            swap(container.first(), container.at(pos));
            shuffleDown(container, order, +pos);
        }
    }

private:
    using Item = typename Container::Item;

    static void shuffleUp(Container &buf, const Order &order, long fill)
    {
        using std::swap;

        for (long i = fill - 1; i != 0;) {
            long j = (i - 1) / 2;
            Item &a = buf[i];
            Item &b = buf[j];
            if (!order(b, a)) break;
            swap(a, b);
            i = j;
        }
    }

    static void shuffleDown(Container &buf, const Order &order, long fill)
    {
        using std::swap;

        if (fill <= 0) return;

        for (long i = 0; true;) {
            const long l = 2 * i + 1;
            const long r = 2 * i + 2;
            if (r < fill) {
                Item &a = buf[i];
                Item &b = buf[l];
                Item &c = buf[r];
                if (order(a, b)) {
                    if (order(b, c)) {
                        i = r;
                        swap(a, c);
                    }
                    else {
                        i = l;
                        swap(a, b);
                    }
                }
                else if (order(a, c)) {
                    i = r;
                    swap(a, c);
                }
                else break;
            }
            else if (l < fill) {
                Item &a = buf[i];
                Item &b = buf[l];
                if (order(a, b)) swap(a, b);
                break;
            }
            else
                break;
        }
    }
};

template<class Container, class Order = Asc>
void stableSort(Container &container, Order order = Order{})
{
    HeapSort<Container, Order>{}(container, order);
}

} // namespace cc
