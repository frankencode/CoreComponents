/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the GNU General Public License version 3
 * (see CoreComponents/LICENSE-gpl-3.0).
 *
 */

#pragma once

namespace cc {

/** \class FindAny cc/find
  * \brief Find a matching item
  */
class FindAny {
public:
    /** \brief Search in a sorted list of items
      * \param items the sorted list of items
      * \param pattern pattern to search for
      * \param finalIndex return the final index of the search
      * \return true if a matching item was found, false otherwise
      */
    template<
        class SortedItems,
        class Pattern = typename SortedItems::Item,
        class Index = long
    >
    static bool find(
        const SortedItems *items,
        const Pattern &pattern,
        Index *finalIndex
    ) {
        Index l = 0;
        Index r = items->count() - 1;
        while (l <= r) {
            Index m = (l + r) >> 1;
            const auto &candidate = items->at(m);
            auto order = candidate <=> pattern;
            if (order == std::strong_ordering::less) {
                l = m + 1;
            }
            else if (order == std::strong_ordering::greater) {
                r = m - 1;
            }
            else {
                *finalIndex = m;
                return true;
            }
        }
        *finalIndex = l;
        return false;
    }
};

/** \class FindFirst cc/find
  * \brief Find left-most item which equals pattern
  * \todo improve semantics to not perform a final equality comparism automatically
  */
class FindFirst
{
public:
    /** \brief Search in a sorted list of items
      * \param items the sorted list of items
      * \param pattern pattern to search for
      * \param finalIndex return the final index of the search
      * \return true if a matching item was found, false otherwise
      */
    template<
        class SortedItems,
        class Pattern = typename SortedItems::Item,
        class Index = long
    >
    static bool find(
        const SortedItems *items,
        const Pattern &pattern,
        Index *finalIndex
    ) {
        Index l = 0;
        Index r = items->count();
        while (l < r) {
            Index m = (l + r) >> 1;
            if (items->at(m) < pattern)
                l = m + 1;
            else
                r = m;
        }
        *finalIndex = l;
        return l < items->count() && !(items->at(l) < pattern || pattern < items->at(l));
    }
};

/** \class FindLast cc/find
  * \brief Find right-most item which equals pattern
  * \todo improve semantics to not perform a final equality comparism automatically
  */
class FindLast
{
public:
    /** \brief Search in a sorted list of items
      * \param items the sorted list of items
      * \param pattern pattern to search for
      * \param finalIndex return the final index of the search
      * \return true if a matching item was found, false otherwise
      */
    template<
        class SortedItems,
        class Pattern = typename SortedItems::Item,
        class Index = long
    >
    static bool find(
        const SortedItems *items,
        const Pattern &pattern,
        Index *finalIndex
    ) {
        Index l = 0;
        Index r = items->count();
        bool found = false;
        while (l < r) {
            Index m = (l + r) >> 1;
            if (pattern < items->at(m))
                r = m;
            else
                l = m + 1;
        }
        found = (0 < l) && !(items->at(l - 1) < pattern || pattern < items->at(l - 1));
        *finalIndex = l - found;
        return found;
    }
};

} // namespace cc
