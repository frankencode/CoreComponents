/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the GNU General Public License version 3
 * (see CoreComponents/LICENSE-gpl-3.0).
 *
 */

#pragma once

#include <cc/order>

namespace cc {

/** \class FindAny cc/find
  * \brief Find a matching item
  */
class FindAny {
public:
    /** \brief Search in a sorted list of items
      * \param items The sorted list of items
      * \param pattern Pattern to search for
      * \param finalIndex Returns the final index of the search
      * \return True if a matching item was found, false otherwise
      */
    template<
        class SortedItems,
        class Pattern = typename SortedItems::Item,
        class Index = long
    >
    static bool find(
        const SortedItems *items,
        const Pattern &pattern,
        Index *finalIndex
    ) {
        Index l = 0;
        Index r = items->count() - 1;
        while (l <= r) {
            Index m = (l + r) >> 1;
            const auto &candidate = items->at(m);
            auto order = candidate <=> pattern;
            if (order == std::strong_ordering::less) {
                l = m + 1;
            }
            else if (order == std::strong_ordering::greater) {
                r = m - 1;
            }
            else {
                *finalIndex = m;
                return true;
            }
        }
        *finalIndex = l;
        return false;
    }

    /** \brief Search in a sorted list of items
      * \param items The sorted list of items
      * \param pattern Pattern to search for
      * \param finalIndex Returns the final index of the search
      * \param finalItem Returns the final item of the search
      * \return True if a matching item was found, false otherwise
      */
    template<
        class SortedItems,
        class Pattern = typename SortedItems::Item,
        class Index = long
    >
    static bool find(
        SortedItems *items,
        const Pattern &pattern,
        Index *finalIndex = nullptr,
        typename SortedItems::Item **finalItem = nullptr
    ) {
        Index l = 0;
        Index r = items->count() - 1;
        while (l <= r) {
            Index m = (l + r) >> 1;
            auto &candidate = items->at(m);
            auto order = candidate <=> pattern;
            if (order == std::strong_ordering::less) {
                l = m + 1;
            }
            else if (order == std::strong_ordering::greater) {
                r = m - 1;
            }
            else {
                if (finalIndex) *finalIndex = m;
                if (finalItem) *finalItem = &candidate;
                return true;
            }
        }
        if (finalIndex) *finalIndex = l;
        if (finalItem) *finalItem = &items->at(l);
        return false;
    }
};

/** \class FindFirst cc/find
  * \brief Find left-most item which equals pattern
  * \todo improve semantics to not perform a final equality comparism automatically
  */
class FindFirst
{
public:
    /** \brief Search in a sorted list of items
      * \param items The sorted list of items
      * \param pattern Pattern to search for
      * \param finalIndex Returns the final index of the search
      * \return True if a matching item was found, false otherwise
      */
    template<
        class SortedItems,
        class Pattern = typename SortedItems::Item,
        class Index = long
    >
    static bool find(
        const SortedItems *items,
        const Pattern &pattern,
        Index *finalIndex
    ) {
        Index l = 0;
        Index r = items->count();
        while (l < r) {
            Index m = (l + r) >> 1;
            if (items->at(m) < pattern)
                l = m + 1;
            else
                r = m;
        }
        *finalIndex = l;
        return l < items->count() && !(items->at(l) < pattern || pattern < items->at(l));
    }

    template<
        class SortedItems,
        class Pattern = typename SortedItems::Item,
        class Index = long,
        class Order = DefaultOrder
    >
    static bool find(
        SortedItems *items,
        const Pattern &pattern,
        Index *finalIndex = nullptr,
        typename SortedItems::Item **finalItem = nullptr
    ) {
        Index l = 0;
        Index r = items->count();
        while (l < r) {
            Index m = (l + r) >> 1;
            if (Order::compare(items->at(m), pattern) == std::strong_ordering::less)
                l = m + 1;
            else
                r = m;
        }
        if (finalIndex) *finalIndex = l;
        if (finalItem) *finalItem = &items->at(l);
        return l < items->count() && Order::compare(items->at(l), pattern) == std::strong_ordering::equal;
    }
};

/** \class FindLast cc/find
  * \brief Find right-most item which equals pattern
  */
class FindLast
{
public:
    template<
        class SortedItems,
        class Pattern = typename SortedItems::Item,
        class Index = long,
        class Order = DefaultOrder
    >
    static bool find(
        const SortedItems *items,
        const Pattern &pattern,
        Index *finalIndex
    ) {
        Index l = 0;
        Index r = items->count();
        bool found = false;
        while (l < r) {
            Index m = (l + r) >> 1;
            if (Order::compare(pattern, items->at(m)) == std::strong_ordering::less)
                r = m;
            else
                l = m + 1;
        }
        found = 0 < l && Order::compare(pattern, items->at(l - 1)) == std::strong_ordering::equal;
        *finalIndex = l - found;
        return found;
    }

    template<
        class SortedItems,
        class Pattern = typename SortedItems::Item,
        class Index = long,
        class Order = DefaultOrder
    >
    static bool find(
        SortedItems *items,
        const Pattern &pattern,
        Index *finalIndex = nullptr,
        typename SortedItems::Item **finalItem = nullptr
    ) {
        Index l = 0;
        Index r = items->count();
        bool found = false;
        while (l < r) {
            Index m = (l + r) >> 1;
            if (Order::compare(pattern, items->at(m)) == std::strong_ordering::less)
                r = m;
            else
                l = m + 1;
        }
        found = 0 < l && Order::compare(pattern, items->at(l - 1)) == std::strong_ordering::equal;
        l -= found;
        if (finalIndex) *finalIndex = l;
        if (finalItem) *finalItem = &items->at(l);
        return found;
    }
};

} // namespace cc
