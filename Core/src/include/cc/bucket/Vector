/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the GNU General Public License version 3
 * (see CoreComponents/LICENSE-gpl-3.0).
 *
 */

#pragma once

#include <cc/bucket/Tree>
#include <cc/Locator>
#include <cc/InOut>
#include <cc/order>

namespace cc {
namespace bucket {

/** \internal
  * \brief Unified internal data structure
  */
template<class T>
class Vector: public Tree
{
public:
    using Item = T;
    using Leaf = bucket::Leaf<T>;

    Vector() = default;

    Vector(const Vector &other)
    {
        // \todo performance: optimize tree built-up

        for (auto pos = other.head(); pos; ++pos)
            pushBack(other.at(pos));
    }

    ~Vector()
    {
        deplete();
    }

    Locator head() const
    {
        return Locator{&root_.weight_, 0, getMinNode(), 0};
    }

    Locator tail() const
    {
        long index = count() - 1;
        Node *node = lastLeaf_;
        unsigned egress = node ? node->fill_ - 1 : 0;
        return Locator{&root_.weight_, index, node, egress};
    }

    Locator from(long index) const
    {
        unsigned egress = 0;
        Node *node = stepDownTo(index, &egress);
        if (root_.weight_ <= index) node = nullptr;
        return Locator{&root_.weight_, index, node, egress};
    }

    template<class Access = Item>
    static Access &value(const Locator &target)
    {
        assert(*target.revisionPtr_ == target.revisionSaved_); // cannot access container with undefined locator
        assert(target); // locator needs to be valid

        return static_cast<Leaf *>(target.stop_)->at(target.egress_);
    }

    Item &at(const Locator &target) const
    {
        assert(target.revisionPtr_ == &root_.weight_); // locator needs to belong to this container
        assert(*target.revisionPtr_ == target.revisionSaved_); // cannot access container with undefined locator
        assert(target); // locator needs to be valid

        return static_cast<Leaf *>(target.stop_)->at(target.egress_);
    }

    Item &operator[](long index) const
    {
        return at(index);
    }

    Item &at(long index) const
    {
        unsigned egress;
        return static_cast<Leaf *>(stepDownTo(index, &egress))->at(egress);
    }

    Item &first() const
    {
        Node *firstLeaf = getMinNode();
        return static_cast<Leaf *>(firstLeaf)->at(0);
    }

    Item &last() const
    {
        return static_cast<Leaf *>(lastLeaf_)->at(lastLeaf_->fill_ - 1);
    }

    template<class... Args>
    void emplaceAt(Locator &target, Args... args);

    template<class... Args>
    void emplaceAt(long index, Args... args);

    void push(long index, const Item &item);

    template<class... Args>
    void emplaceLast(Args... args)
    {
        emplace(lastLeaf_, lastLeaf_ ? lastLeaf_->fill_ : 0, args...);
    }

    void pushBack(const Item &item)
    {
        push(lastLeaf_, lastLeaf_ ? lastLeaf_->fill_ : 0, item);
    }

    template<class... Args>
    void emplace(Node *target, unsigned egress, Args... args)
    {
        Leaf *leaf = target ? static_cast<Leaf *>(target) : nullptr;
        emplaceAndTell(leaf, egress, args...);
    }

    void push(Node *target, unsigned egress, const Item &item)
    {
        Leaf *leaf = target ? static_cast<Leaf *>(target) : nullptr;
        pushAndTell(leaf, egress, item);
    }

    template<class... Args>
    void emplaceAndTell(Leaf *&target, unsigned &egress, Args... args);

    void pushAndTell(Leaf *&target, unsigned &egress, const Item &item);

    template<class... Args>
    void emplaceAndStep(Locator &target, Args... args)
    {
        if (count() == 0) emplaceLast(args...);
        else assert(bool(target)); // cannot insert an item using an invalid locator
        emplace(target.index_, args...);
        target = from(target.index_);
    }

    void pushAndStep(Locator &target, const Item &item)
    {
        if (count() == 0) pushBack(item);
        else {
            assert(bool(target)); // cannot insert an item using an invalid locator
            push(target.index_, item);
        }
        target = from(target.index_);
    }

    void pushAndTell(Locator &target, const Item &item)
    {
        assert(target);
        Leaf *leaf = static_cast<Leaf *>(target.stop_);
        unsigned egress = target.egress_;
        pushAndTell(leaf, egress, item);
        target.stop_ = leaf;
        target.egress_ = egress;
    }

    void pop(long index);

    void pop(Node *target, unsigned egress);

    void popAndStep(Locator &pos)
    {
        assert(bool(pos)); // cannot remove an item using an invalid locator
        pop(static_cast<Node *>(pos.stop_), pos.egress_);
        pos = from(pos.index_);
    }

    void deplete()
    {
        if (root_.node_) {
            Node *leaf = getMinNode();
            Branch *parent = leaf->parent_;
            while (leaf) {
                Node *succ = leaf->succ();
                delete static_cast<Leaf *>(leaf);
                leaf = succ;
            }
            while (parent) {
                Node *branch = parent;
                parent = parent->parent_;
                while (branch) {
                    Node *succ = branch->succ();
                    delete branch;
                    branch = succ;
                }
            }
            *this = Vector{};
        }
    }

    template<class Search = FindAny, class Order = Asc, class Pattern = Item>
    bool lookup(const Pattern &pattern, long *finalIndex = nullptr, Leaf **target = nullptr, unsigned *egress = nullptr, Order order = Order{}) const;

    template<class Search = FindAny, class Pattern = Item>
    bool find(const Pattern &pattern, Out<Locator> target = None{}) const
    {
        long index = 0;
        Leaf *leaf = nullptr;
        unsigned egress = 0;
        bool found = lookup<Search, Asc, Pattern>(pattern, &index, &leaf, &egress);
        if (found && target.requested()) target = Locator{&root_.weight_, index, leaf, egress};
        return found;
    }

    template<class Order = Asc>
    bool insertUnique(const T &item, Out<Locator> target = None{}, Order order = Order{})
    {
        Leaf *leaf = nullptr;
        unsigned egress = 0;
        long index = 0;
        bool found = lookup(item, &index, &leaf, &egress, order);
        if (!found) pushAndTell(leaf, egress, item);
        if (target.requested()) target = Locator{&root_.weight_, index, leaf, egress};
        return !found;
    }

    template<class Order = Asc>
    void insertLast(const T &item, Order order = Order{})
    {
        Leaf *leaf = nullptr;
        unsigned egress = 0;
        bool found = lookup<FindLast>(item, nullptr, &leaf, &egress, order);
        push(leaf, egress + found, item);
    }

    void establish(const T &item)
    {
        Leaf *leaf = nullptr;
        unsigned egress = 0;
        bool found = lookup(item, nullptr, &leaf, &egress);
        if (found) leaf->at(egress) = item;
        else push(leaf, egress, item);
    }

    template<class Pattern = Item>
    bool remove(const Pattern &pattern)
    {
        Leaf *leaf = nullptr;
        unsigned egress = 0;
        bool found = lookup(pattern, nullptr, &leaf, &egress);
        if (found) pop(leaf, egress);
        return found;
    }

    void reverse()
    {
        using std::swap;

        if (count() > 2) {
            auto hi = head();
            auto ti = tail();
            while (hi < ti) {
                swap(at(hi), at(ti));
                ++hi;
                --ti;
            }
        }
    }
};

template<class T>
template<class... Args>
void Vector<T>::emplaceAt(Locator &target, Args... args)
{
    assert(target);
    assert(target.revisionPtr_ == &root_.weight_); // locator needs to belong to this container
    assert(target.revisionSaved_ == root_.weight_); // locator needs to be up-to-date

    unsigned egress = target.egress_;
    Leaf *leaf = static_cast<Leaf *>(target.stop_);
    emplaceAndTell(leaf, egress, args...);
    target.egress_ = egress;
    target.stop_ = leaf;
    #ifndef NDEBUG
    target.revisionSaved_ = root_.weight_;
    #endif
}

template<class T>
template<class... Args>
void Vector<T>::emplaceAt(long index, Args... args)
{
    unsigned egress = 0;
    Node *node = stepDownTo(index, &egress);
    emplace(node, egress, args...);
}

template<class T>
void Vector<T>::push(long index, const Item &item)
{
    unsigned egress = 0;
    Node *node = stepDownTo(index, &egress);
    push(node, egress, item);
}

template<class T>
template<class... Args>
void Vector<T>::emplaceAndTell(Leaf *&target, unsigned &egress, Args... args)
{
    if (target) {
        dissipate(target, egress);
        target->emplace(egress, args...);
        updateWeights(target, 1);
    }
    else {
        target = new Leaf;
        egress = 0;
        target->emplace(egress, args...);
        root_.weight_ = 1;
        root_.node_ = target;
        lastLeaf_ = target;
        ++height_;
        // firstLeaf_ = leaf;
        // leafCount_ = 1;
    }
}

template<class T>
void Vector<T>::pushAndTell(Leaf *&target, unsigned &egress, const Item &item)
{
    if (target) {
        dissipate(target, egress);
        target->push(egress, item);
        updateWeights(target, 1);
    }
    else {
        target = new Leaf;
        egress = 0;
        target->push(egress, item);
        root_.weight_ = 1;
        root_.node_ = target;
        lastLeaf_ = target;
        ++height_;
        // firstLeaf_ = leaf;
        // leafCount_ = 1;
    }
}

template<class T>
void Vector<T>::pop(long index)
{
    unsigned egress = 0;
    Leaf *target = static_cast<Leaf *>(stepDownTo(index, &egress));
    pop(target, egress);
}

template<class T>
void Vector<T>::pop(Node *target, unsigned egress)
{
    if (root_.weight_ > 1) {
        Leaf *leaf = static_cast<Leaf *>(target);
        leaf->pop(egress);
        updateWeights(leaf, -1);
        if (leaf->succ_) isDense_ = false;
        relieve(leaf);
        reduce();
    }
    else {
        delete static_cast<Leaf *>(root_.node_);
        root_.node_ = nullptr;
        root_.weight_ = 0;
        lastLeaf_ = nullptr;
        // leafCount_ = 0;
        --height_;
        isDense_ = true;
    }
}

template<class Item>
class SearchNode
{
public:
    SearchNode(const Leaf<Item> *leaf):
        leaf_{leaf}
    {}

    const Leaf<Item> *leaf_;
};

template<class Pattern, class Item, class Order>
class SearchShimOrder
{
public:
    SearchShimOrder(const Order &order): order_{order} {}

    bool operator()(const SearchNode<Item> &searchNode, const Pattern &pattern) const
    {
        const Leaf<Item> *leaf = searchNode.leaf_;
        return order_(leaf->at(leaf->fill_ - 1), pattern);
    }

    bool operator()(const Pattern &pattern, const SearchNode<Item> &searchNode) const
    {
        const Leaf<Item> *leaf = searchNode.leaf_;
        return order_(pattern, leaf->at(0));
    }

private:
    const Order order_;
};

template<class Item>
class SearchShim
{
public:
    SearchShim(const Tree *tree):
        tree_{tree},
        idealLeafCount_{tree->idealLeafCount()}
    {}

    SearchNode<Item> at(long index) const
    {
        return static_cast<const Leaf<Item> *>(tree_->idealLeafAt(index));
    }

    long count() const { return idealLeafCount_; }

private:
    const Tree *tree_;
    long idealLeafCount_;
};

template<class T>
template<class Search, class Order, class Pattern>
bool Vector<T>::lookup(const Pattern &pattern, long *finalIndex, Leaf **target, unsigned *egress, Order order) const
{
    bool found = false;
    if (height_ == 0) {
        Leaf *leaf = static_cast<Leaf *>(root_.node_);
        long i = 0;
        found = Search::find(leaf, pattern, &i, order);
        if (finalIndex) *finalIndex = i;
        if (target) *target = leaf;
        if (egress) *egress = i;
    }
    else if (height_ > 0) {
        Leaf *leaf = static_cast<Leaf *>(lastLeaf_);
        if (leaf->at(leaf->fill_ - 1) < pattern) {
            if (finalIndex) *finalIndex = root_.weight_;
            if (target) *target = leaf;
            if (egress) *egress = leaf->fill_;
        }
        else {
            SearchShim<Item> shim{this};
            long i = 0, j = 0;
            bool lookInside = Search::find(&shim, pattern, &j, SearchShimOrder<Pattern, Item, Order>{order});
            leaf = static_cast<Leaf *>(idealLeafAt(j));
            unsigned k = 0;
            if (lookInside) {
                found = Search::find(leaf, pattern, &k, order);
                i = k;
            }
            i += nodeOffset(leaf);
            if (finalIndex) *finalIndex = i;
            if (target) *target = leaf;
            if (egress) *egress = k;
        }
    }
    else if (finalIndex) {
        *finalIndex = 0;
    }
    return found;
}

}} // namespace cc::bucket
