/*
 * Copyright (C) 2023 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the GNU General Public License version 3
 * (see CoreComponents/LICENSE-gpl-3.0).
 *
 */

#pragma once

#include <type_traits>
#include <utility>
#include <cstdint>
#include <cstring>

namespace cc {

using std::memmove;
using std::memcpy;
using std::is_trivially_copyable;
using std::move;

template<class Item, bool useMemMove = is_trivially_copyable<Item>()>
struct ShiftInsert
{};

template<class Item>
struct ShiftInsert<Item, true>
{
    static void call(Item *items, unsigned fill, unsigned index, const Item &item)
    {
        if (index < fill) {
            memmove(
                items + index + 1,
                items + index,
                (fill - index) * sizeof(Item)
            );
        }
        items[index] = item;
    }
};

template<class Item>
struct ShiftInsert<Item, false>
{
    static void call(Item *items, unsigned fill, unsigned index, const Item &item)
    {
        if (index < fill) {
            for (unsigned k = fill; index < k; ++k) {
                new(items + k) Item(move(items[k - 1]));
            }
        }
        new(items + index) Item(item);
    }
};

template<class Item, bool useMemMove = is_trivially_copyable<Item>()>
struct ShiftEmplace
{};

template<class Item>
struct ShiftEmplace<Item, true>
{
    static void call(Item *items, unsigned fill, unsigned index, Item &&item)
    {
        if (index < fill) {
            memmove(
                items + index + 1,
                items + index,
                (fill - index) * sizeof(Item)
            );
        }
        items[index] = item;
    }
};

template<class Item>
struct ShiftEmplace<Item, false>
{
    static void call(Item *items, unsigned fill, unsigned index, Item &&item)
    {
        if (index < fill) {
            for (unsigned k = fill; index < k; ++k) {
                new(items + k) Item(move(items[k - 1]));
            }
        }
        new(items + index) Item(item);
    }
};

template<class Item, bool useMemMove = is_trivially_copyable<Item>()>
struct ShiftRemove
{};

template<class Item>
struct ShiftRemove<Item, true>
{
    static void call(Item *items, unsigned fill, unsigned index)
    {
        if (index < fill - 1) {
            memmove(
                items + index,
                items + index + 1,
                (fill - index - 1) * sizeof(Item)
            );
        }
    }
};

template<class Item>
struct ShiftRemove<Item, false>
{
    static void call(Item *items, unsigned fill, unsigned index)
    {
        if (index < fill - 1) {
            for (unsigned k = index; k < fill; ++k) {
                new(items + k) Item(move(items[k + 1]));
            }
        }
    }
};

template<class Item, unsigned Capacity, unsigned Gap = 0, bool useMemMove = is_trivially_copyable<Item>()>
struct SplitMove
{};

template<class Item, unsigned Capacity, unsigned Gap>
struct SplitMove<Item, Capacity, Gap, true>
{
    static constexpr unsigned HalfCapacity = Capacity / 2;

    static void call(const Item *items, Item *newSucc)
    {
        memcpy(
            newSucc,
            items + HalfCapacity,
            (HalfCapacity - Gap) * sizeof(Item)
        );
    }
};

template<class Item, unsigned Capacity, unsigned Gap>
struct SplitMove<Item, Capacity, Gap, false>
{
    static constexpr unsigned HalfCapacity = Capacity / 2;

    static void call(Item *items, Item *newSucc)
    {
        for (unsigned k = 0; k < HalfCapacity - Gap; ++k)
        {
            new(newSucc + k) Item(move(items[k + HalfCapacity]));
        }
    }
};

template<class Item, bool useMemMove = is_trivially_copyable<Item>()>
struct Move
{};

template<class Item>
struct Move<Item, true>
{
    static void call(Item *target, const Item *source, unsigned count)
    {
        memcpy(target, source, count * sizeof(Item));
    }
};

template<class Item>
struct Move<Item, false>
{
    static void call(Item *target, const Item *source, unsigned count)
    {
        for (unsigned k = 0; k < count; ++k) {
            new(target + k) Item(move(source[k]));
        }
    }
};

} // namespace cc
