/*
 * Copyright (C) 2019 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the GNU General Public License version 3
 * (see CoreComponents/LICENSE-gpl-3.0).
 *
 */

#pragma once

#include <cassert>
#include <cstdint>

namespace cc::buckets {

/** \internal
  * \brief Storage slot mapping table
  *
  * The BucketSlotMap decides where individual items are stored on a bucket.
  */
template<unsigned Capacity>
class BucketSlotMap
{};

template<>
class BucketSlotMap<16>
{
public:
    static constexpr unsigned Capacity = 16;

    unsigned mapToSlot(unsigned bucketIndex) const
    {
        return (map_ >> (bucketIndex << 2u)) & 0xFu;
    }

    unsigned mapToBucket(unsigned slotIndex) const
    {
        unsigned i = 0;
        for (uint64_t m = map_; (m & 0xFu) ^ slotIndex; m >>= 4) ++i;
        return i;
    }

    unsigned pushEntry(unsigned bucketIndex, unsigned fill)
    {
        assert(bucketIndex <= fill);
        assert(fill < BucketSlotMap::Capacity);

        const uint64_t slotIndex = map_ >> 60u;

        const unsigned bucketShift = bucketIndex << 2u;
        const uint64_t highMask = (~UINT64_C(0)) << bucketShift;
        const uint64_t lowMask  = ~highMask;

        map_ = ((map_ & highMask) << 4u) | (map_ & lowMask) | (slotIndex << bucketShift);

        return slotIndex;
    }

    unsigned popEntry(unsigned bucketIndex, unsigned fill)
    {
        assert(bucketIndex < fill);
        assert(fill > 0);

        const uint64_t slotIndex = mapToSlot(bucketIndex);

        const unsigned bucketShift = bucketIndex << 2u;
        const uint64_t highMask = (~UINT64_C(0)) << bucketShift;
        const uint64_t lowMask  = ~highMask;

        map_ = (slotIndex << 60u) | ((map_ >> 4u) & highMask) | (map_ & lowMask);

        return slotIndex;
    }

private:
    uint64_t map_ { UINT64_C(0x0123456789ABCDEF) };
};

} // namespace cc::buckets
