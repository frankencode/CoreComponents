/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the GNU General Public License version 3
 * (see CoreComponents/LICENSE-gpl-3.0).
 *
 */

#pragma once

#include <cc/buckets/BucketSlotMap>
#include <cc/buckets/BucketStop>
#include <type_traits>
#include <limits>
#include <utility>
#include <functional>
#include <bit>
#include <cassert>

namespace cc::buckets {

/** \internal
  * \brief Purely counted B-tree
  *
  * The BucketIndexTree is a B-tree which contains sub-tree weights as keys in the inner nodes.
  * The levels of the tree are comprised of double linked bucket chains.
  *
  * Item storage and retrieval has to be defined in a derived class.
  * This class provides only part of the tree logic which is independent of the item type.
  *
  * \see BucketVector
  */
class BucketIndexTree
{
public:
    class Branch;

    class Node: public BucketStop
    {
    public:
        static constexpr unsigned Capacity = 16;
        static constexpr unsigned HalfCapacity = Capacity >> 1;
        static constexpr unsigned QuarterCapacity = Capacity >> 2;

        Node *succ() const { return static_cast<Node *>(succ_); }
        Node *pred() const { return static_cast<Node *>(pred_); }
        Branch *parent_ { nullptr };
    };

    static constexpr unsigned StepBits = std::countr_zero(Node::Capacity);
    static constexpr unsigned StepMask = Node::Capacity - 1;

    class Branch final: public Node
    {
    public:
        Node *childAt(unsigned egress) const { return child_[map_.mapToSlot(egress)]; }
        long weightAt(unsigned egress) const { return weight_[map_.mapToSlot(egress)]; }

        Node *find(long &index) const
        {
            const unsigned n = fill_;

            for (unsigned k = 0; k < n; ++k)
            {
                const unsigned slotIndex = map_.mapToSlot(k);
                index -= weight_[slotIndex];
                if (index < 0) {
                    index += weight_[slotIndex];
                    return child_[slotIndex];
                }
            }

            return nullptr;
        }

        void push(unsigned egress, Node *child, long weight)
        {
            unsigned slotIndex = map_.pushEntry(egress, fill_);
            ++fill_;
            child_[slotIndex] = child;
            weight_[slotIndex] = weight;
            child->slotIndex_ = slotIndex;
            child->parent_ = this;
        }

        unsigned drop(unsigned egress)
        {
            unsigned slotIndex = map_.popEntry(egress, fill_);
            --fill_;
            return slotIndex;
        }

        long &weightOf(const Node *child) { return weight_[child->slotIndex_]; }

        unsigned indexOf(const Node *child) const { return map_.mapToBucket(child->slotIndex_); }

        long dissipateForwardTo(Branch *succ)
        {
            assert(fill_ > 0);
            assert(succ->fill_ < Capacity);

            unsigned slotIndex = drop(fill_ - 1);
            succ->push(0, child_[slotIndex], weight_[slotIndex]);
            return weight_[slotIndex];
        }

        long dissipateBackwardTo(Branch *pred)
        {
            assert(fill_ > 0);
            assert(pred->fill_ < Capacity);

            unsigned slotIndex = drop(0);
            pred->push(pred->fill_, child_[slotIndex], weight_[slotIndex]);
            return weight_[slotIndex];
        }

        long distributeHalfForwardTo(Branch *succ)
        {
            assert(fill_ == Capacity);
            assert(succ->fill_ <= HalfCapacity);

            long delta = 0;

            for (unsigned i = 0; i < HalfCapacity; ++i)
            {
                unsigned slotIndex = drop(HalfCapacity);
                delta += weight_[slotIndex];
                succ->push(i, child_[slotIndex], weight_[slotIndex]);
            }

            return delta;
        }

        long distributeQuarterForwardTo(Branch *succ)
        {
            assert(fill_ == Capacity);
            assert(succ->fill_ <= Capacity - QuarterCapacity);

            long delta = 0;

            for (unsigned k = Capacity - 1; k >= Capacity - QuarterCapacity; --k)
            {
                unsigned slotIndex = drop(k);
                delta += weight_[slotIndex];
                succ->push(0, child_[slotIndex], weight_[slotIndex]);
            }

            return delta;
        }

        long distributeQuarterBackwardTo(Branch *pred)
        {
            assert(fill_ == Capacity);
            assert(pred->fill_ == HalfCapacity);

            long delta = 0;

            for (unsigned k = HalfCapacity; k < HalfCapacity + QuarterCapacity; ++k)
            {
                unsigned slotIndex = drop(0);
                delta += weight_[slotIndex];
                pred->push(k, child_[slotIndex], weight_[slotIndex]);
            }

            return delta;
        }

        void adoptChildrenOfSucc(const Branch *succ)
        {
            assert(fill_ + succ->fill_ <= Capacity);

            for (unsigned k = 0; k < succ->fill_; ++k)
            {
                unsigned slotIndex = succ->map_.mapToSlot(k);
                push(fill_, succ->child_[slotIndex], succ->weight_[slotIndex]);
            }
        }

    private:
        BucketSlotMap<Capacity> map_;
        Node *child_[Capacity];
        long weight_[Capacity];
    };

    long count() const { return weight_; }

    #if 1
    long idealLeafCount() const
    {
        return (height_ > 0) ? root_->fill_ << ((height_ - 1) * StepBits) : 1;
    }
    #endif

    #if 0
    long idealLeafCount() const
    {
        Node *node = root_;
        uint64_t n = 0;
        for (int h = height_; h > 0; --h) {
            unsigned i = node->fill_ - 1;
            n <<= StepBits;
            n |= i;
            node = static_cast<const Branch *>(node)->childAt(i);
        }
        return n + 1;
    }
    #endif

    Node *idealLeafAt(long idealIndex) const
    {
        Node *node = root_;
        for (int h = height_; h > 0; --h) {
            const int shift = (h - 1) * StepBits;
            unsigned i = (idealIndex >> shift) & StepMask;
            if (node->fill_ <= i) i = node->fill_ - 1;
            node = static_cast<const Branch *>(node)->childAt(i);
        }
        return node;
    }

    Node *locateIdealLeaf(long idealIndex, long *offset) const
    {
        Node *node = root_;
        long predWeight = 0;
        for (int h = height_; h > 0; --h) {
            const int shift = (h - 1) * StepBits;
            unsigned i = (idealIndex >> shift) & StepMask;
            if (node->fill_ <= i) i = node->fill_ - 1;
            const Branch *branch = static_cast<const Branch *>(node);
            for (unsigned k = 0; k < i; ++k) {
                predWeight += branch->weightAt(k);
            }
            node = branch->childAt(i);
        }
        *offset = predWeight;
        return node;
    }

    Node *getMinNode() const
    {
        Node *node = root_;
        for (int h = height_; h > 0; --h) {
            node = static_cast<const Branch *>(node)->childAt(0);
        }
        return node;
    }

    Node *getMaxNode() const
    {
        Node *node = root_;
        for (int h = height_; h > 0; --h) {
            node = static_cast<const Branch *>(node)->childAt(node->fill_ - 1);
        }
        return node;
    }

    bool isDense() const { return isDense_; }

    Node *stepDownTo(long index, unsigned *egress) const;

    bool check(const std::function<bool(const Node *)> &f) const
    {
        return check(f, root_, height_);
    }

    static bool check(const std::function<bool(const Node *)> &f, const Node *node, int h)
    {
        bool ok = true;
        if (h > 0) {
            const Branch *branch = static_cast<const Branch *>(node);
            for (unsigned i = 0; i < branch->fill_; ++i) {
                ok = ok && check(f, branch->childAt(i), h - 1);
            }
        }
        if (h > -1) ok = ok && f(node);
        return ok;
    }

protected:
    template<class>
    friend class SearchShim;

    template<class NodeType>
    void dissipate(NodeType *&node, unsigned &egress)
    {
        if (node->fill_ == Node::Capacity) dissipateSlow(node, egress);
    }

    template<class NodeType>
    void dissipateSlow(NodeType *&node, unsigned &egress);

    template<class NodeType>
    void relieve(NodeType *node, bool recursive = false);

    template<class NodeType>
    void joinSucc(NodeType *node, NodeType *newNode)
    {
        joinSucc(node, newNode, std::is_same<NodeType, Branch>());
    }

    void joinSucc(Node *node, Node *newNode, bool isBranch);

    template<class NodeType>
    void collapseSucc(NodeType *node, NodeType *succ);

    template<class NodeType>
    void unlink(NodeType *node)
    {
        unlink(node, std::is_same<NodeType, Branch>());
    }

    void unlink(Node *node, bool isBranch);

    static long &weight(Node *child) {
        assert(child->parent_);
        return child->parent_->weightOf(child);
    }

    static void shiftWeights(Node *from, Node *to, long delta);
    void updateWeights(Node *node, long delta);

    void reduce();

    const unsigned *revision() const
    {
        #ifdef NDEBUG
        return nullptr;
        #else
        return &revision_;
        #endif
    }

    int height_ { -1 };
    bool isDense_ { true };
    Node *root_ { nullptr };
    long weight_ { 0 };
    Node *lastLeaf_ { nullptr }; // FIXME: maxLeaf_;
    #ifndef NDEBUG
    unsigned revision_ { 0 };
    #endif
};

template<class NodeType>
void BucketIndexTree::dissipateSlow(NodeType *&node, unsigned &egress)
{
    NodeType *succ = static_cast<NodeType *>(node->succ_);
    NodeType *pred = static_cast<NodeType *>(node->pred_);

    if (succ && pred) {
        if (succ->fill_ < pred->fill_) {
            if (egress != Node::Capacity) {
                shiftWeights(node, succ, node->dissipateForwardTo(succ));
            }
            else {
                node = succ;
                egress = 0;
            }
            return;
        }
        if (pred->fill_ < succ->fill_) {
            if (egress != 0) {
                shiftWeights(node, pred, node->dissipateBackwardTo(pred));
                --egress;
            }
            else {
                node = pred;
                egress = pred->fill_;
            }
            return;
        }
    }

    if (pred) {
        if (pred->fill_ < Node::Capacity) {
            if (egress != 0) {
                shiftWeights(node, pred, node->dissipateBackwardTo(pred));
                --egress;
            }
            else {
                node = pred;
                egress = pred->fill_;
            }
            return;
        }
    }

    if (succ) {
        if (succ->fill_ < Node::Capacity) {
            if (egress != Node::Capacity) {
                shiftWeights(node, succ, node->dissipateForwardTo(succ));
            }
            else {
                node = succ;
                egress = 0;
            }
            return;
        }
    }

    NodeType *newSucc = new NodeType;
    joinSucc(node, newSucc);

    #if 1
    if (egress == Node::Capacity && !succ) {
        node = newSucc;
        egress = 0;
        return;
    }
    #endif

    shiftWeights(node, newSucc, node->distributeHalfForwardTo(newSucc));
    isDense_ = false;

    #if 1
    if (pred) {
        shiftWeights(pred, node, pred->distributeQuarterForwardTo(node));
    }

    if (succ) {
        shiftWeights(succ, newSucc, succ->distributeQuarterBackwardTo(newSucc));
    }
    #endif

    if (egress > Node::HalfCapacity) {
        node = newSucc;
        egress -= Node::HalfCapacity;
    }
    #if 1
    else if (pred) {
        egress += Node::QuarterCapacity;
    }

    assert(egress <= node->fill_);
    #endif
}

template<class NodeType>
void BucketIndexTree::relieve(NodeType *node, bool recursive)
{
    NodeType *succ = static_cast<NodeType *>(node->succ_);
    if (node->fill_ < Node::HalfCapacity) {
        if (succ) {
            if (succ->fill_ > Node::HalfCapacity)
                shiftWeights(succ, node, succ->dissipateBackwardTo(node));
            else
                collapseSucc(node, succ);
        }
        else if (node->fill_ == 0) {
            unlink(node);
        }
    }
}

template<class NodeType>
void BucketIndexTree::collapseSucc(NodeType *node, NodeType *succ)
{
    node->adoptChildrenOfSucc(succ);
    shiftWeights(succ, node, weight(succ));
    unlink(succ);
}

} // namespace cc::buckets
