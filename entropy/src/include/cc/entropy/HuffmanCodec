/*
 * Copyright (C) 2007-2018 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Array>
#include <cc/Heap>
#include <cc/Stack>
#include <cc/entropy/BitSink>
#include <cc/entropy/BitSource>

namespace cc {
namespace entropy {

/** \brief Huffman entropy encoding
  */
class HuffmanCodec: public Object
{
public:
    /** Initialize the codec and allocate required memory.
      *
      * The arguments provided determine the memory consumption of the codec.
      * Much more restricted values may be choosen than the default
      * If the raw diversity or the raw dynamic range is to small
      * for a given input buffer the codec will fall back to a special
      * raw transmission mode.
      *
      * \param rawDiversity estimated size of the raw symbols alphabet
      * \param rawDynamicRange estimated dynamic range of raw symbols (max-min+1)
      */
    inline static Ref<HuffmanCodec> create(int rawDiversity = 0x10000, int rawDynamicRange = 0x10000)
    {
        return new HuffmanCodec(rawDiversity, rawDynamicRange);
    }

    /** Returns the number of bytes written on encoding in the worst case.
      * Allows to dimension the output buffer for encoding and the input buffer
      * for decoding.
      *
      * \param rawCapacity maximum size of an input buffer (in symbols)
      * \param rawDynamicRange maximum dynamic range of raw symbols
      * \return maximum number of bytes of encoded result
      */
    int encodedCapacity(int rawCapacity, int rawDynamicRange) const;

    /** Read symbols from an input buffer and write the encoded result
      * to a bit sink.
      *
      * \param sink bit sink
      * \param raw input buffer
      * \param rawFill number of symbols to be read from input buffer
      * \param userFallback if not null returns raw transmission fallback indicator
      */
    void encode(BitSink *sink, int *raw, int rawFill, bool *userFallback = 0);

    /** Read a complete encoded frame from a bit source and write the decoded
      * result to an ouput buffer.
      *
      * \param raw output buffer
      * \param rawCapacity size of the output buffer in number of symbols
      * \param source bit source
      * \return number of symbols written to the output buffer
      */
    int decode(int *raw, int rawCapacity, BitSource *source);

private:
    /** \brief Huffman tree node
      */
    struct Node
    {
        Node *parent_;
        Node *leftChild_;
        Node *rightChild_;
        int value_;
        int count_;
    };

    /** \brief Comparable reference to a huffman tree node
      */
    struct NodeRef
    {
        NodeRef(Node *node = nullptr): node_(node) {}

        Node *node_;

        inline bool operator<(const NodeRef &b) const
        {
            return node_->count_ < b.node_->count_;
        }
    };

    HuffmanCodec(int rawDiversity = 0x10000, int rawDynamicRange = 0x10000);

    void reset();
    void addSymbol(int value, int count0);

    void generateCodeTable();
    void debugCodeTable();
    void writeRawFrame(BitSink *sink, int *frame, int frameFill, int rawMin, int rawMax);

    int options_;
    int rawDiversity_;
    int rawDynamicRange_;

    Ref< Array<Node> > nodes_;
    Node *root_;
    int fill_;

    Ref< Array<NodeRef> > codeMap_;
    Ref< MaxHeap<NodeRef> > heap_;
    Ref< Stack<uint8_t> > bitStack_;

    inline static int ilog2(int n)
    {
        int i = 0;
        for (int h = 1; h < n; h <<= 1)
            ++i;
        return i;
    }
};

}} // namespace cc::entropy
