/*
 * Copyright (C) 2007-2018 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/String>
#include <cc/Array>
#include <cc/Heap>
#include <cc/Stack>
#include <cc/Stream>
#include <cc/entropy/BitSink>
#include <cc/entropy/BitSource>

namespace cc {
namespace entropy {

/** \brief Huffman entropy encoding
  */
class HuffmanCodec: public Object
{
public:
    /** Create a new HuffmanCodec
      * \return new object instance
      */
    inline static Ref<HuffmanCodec> create()
    {
        return new HuffmanCodec();
    }

    /** Huffman encode a block of symbols
      * \param source source to read input symbols from
      * \param sink sink to write the Huffman encoded data to
      * \return number of input symbols read
      */
    int encode(Stream *source, BitSink *sink);

    /** Huffman decode a block of symbols
      * \param source source to read the Huffman encoded data from
      * \param sink sink to write the output symbols to
      * \return number of output symbols written
      */
    int decode(BitSource *source, Stream *sink);

private:
    /** \brief Huffman tree node
      */
    struct Node
    {
        Node *parent_;
        Node *leftChild_;
        Node *rightChild_;
        int value_;
        int count_;
    };

    /** \brief Comparable reference to a huffman tree node
      */
    struct NodeRef
    {
        NodeRef(Node *node = nullptr): node_(node) {}

        Node *node_;

        inline bool operator<(const NodeRef &b) const
        {
            return node_->count_ < b.node_->count_;
        }
    };

    HuffmanCodec();

    void reset();
    void addSymbol(int value, int count0);

    void generateCodeTable();

    String buffer_;

    Ref< Array<Node> > nodes_;
    int nodesFill_;
    Node *root_;

    Ref< Array<NodeRef> > codeMap_;
    Ref< MinHeap<NodeRef> > heap_;
    Ref< Stack<uint8_t> > bitStack_;

    template<int B>
    inline static int ilog(int n) // TODO: move to cc/math (new name for cc/rounding)
    {
        int i = 0;
        for (int h = 1; h < n; h *= B)
            ++i;
        return i;
    }
};

}} // namespace cc::entropy
