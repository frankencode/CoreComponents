/*
 * Copyright (C) 2018 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/CharArray>

namespace cc {
namespace sfnt {

/** \brief Sorted list of glyph index ranges
  */
class GlyphRangeArray: public Object
{
public:
    static Ref<GlyphRangeArray> open(const CharArray *data);

    class RangeRecord {
    public:
        RangeRecord(unsigned startGlyphIndex, unsigned endGlyphIndex, int startCoverageIndex):
            startGlyphIndex_{startGlyphIndex},
            endGlyphIndex_{endGlyphIndex},
            startCoverageIndex_{startCoverageIndex}
        {}

        unsigned startGlyphIndex() const { return startGlyphIndex_; }
        unsigned endGlyphIndex() const { return endGlyphIndex_; }
        int startCoverageIndex() const { return startCoverageIndex_; }

        bool operator==(unsigned glyphIndex) const
        {
            return startGlyphIndex_ <= glyphIndex && glyphIndex <= endGlyphIndex_;
        }

        bool operator<(unsigned glyphIndex) const
        {
            return endGlyphIndex_ < glyphIndex;
        }

        const RangeRecord *operator->() const { return this; }

    private:
        unsigned startGlyphIndex_;
        unsigned endGlyphIndex_;
        int startCoverageIndex_;
    };

    typedef RangeRecord Item;
    typedef int Index;

    RangeRecord at(int i) const {
        return RangeRecord{
            endianGate(data_->item<uint16_t>(3 * i), BigEndian),
            endianGate(data_->item<uint16_t>(3 * i + 1), BigEndian),
            endianGate(data_->item<uint16_t>(3 * i + 2), BigEndian)
        };
    }

    int count() const { return data_->count() / 6; }

    bool lookup(unsigned glyphIndex, int *coverageIndex = 0) const;

private:
    GlyphRangeArray(const CharArray *data);

    Ref<const CharArray> data_;
};

}} // namespace cc::sfnt
