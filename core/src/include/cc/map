/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <initializer_list>
#include <cc/Map>
#include <cc/Format>

namespace cc {

template<class K, class V = K>
class map {
public:
    typedef Map<K, V> Instance;
    typedef typename Instance::Item Item;
    typedef typename Instance::Index index;
    typedef typename Instance::Item value_type;
    typedef typename Instance::iterator iterator;
    typedef typename Instance::const_iterator const_iterator;

    map():
        instance_{new Instance}
    {}

    map(std::initializer_list<Pair<K, V>> b):
        instance_{new Instance}
    {
        for (auto &x: b) *instance_ << x;
    }

    map(const map &b) = default;

    map(map &&b):
        instance_{std::move(b.instance_)}
    {}

    map &operator=(const map &b) = default;

    map &operator=(map &&b) {
        instance_ = std::move(b.instance_);
        return *this;
    }

    explicit map(Instance *b):
        instance_{b}
    {}

    Instance *operator->() { return Cow::get(instance_); }
    const Instance *operator->() const { return instance_; }

    operator const Instance *() const { return instance_; }

    const Pair<K, V> &operator[](index i) const { return instance_->at(i); }

    map &operator<<(const Pair<K, V>& x) { *Cow::get(instance_) << x; return *this; }
    map &operator>>(Pair<K, V>& x) { if (instance_->count() > 0) *Cow::get(instance_) >> x; return *this; }

private:
    Ref<Instance> instance_;
};

template<class K, class V>
typename map<K, V>::index count(const map<K, V> &a) { return a->count(); }

template<class K, class V>
typename map<K, V>::const_iterator begin(const map<K, V> &a) { return a->begin(); }

template<class K, class V>
typename map<K, V>::const_iterator end(const map<K, V> &a) { return a->end(); }

template<class K, class V>
typename map<K, V>::iterator begin(map<K, V> &a) { return a->begin(); }

template<class K, class V>
typename map<K, V>::iterator end(map<K, V> &a) { return a->end(); }

template<class K, class V>
bool operator==(const map<K, V> &a, const map<K, V> &b) { return container::compare(a, b) == 0; }

template<class K, class V>
bool operator!=(const map<K, V> &a, const map<K, V> &b) { return container::compare(a, b) != 0; }

template<class K, class V>
bool operator<(const map<K, V> &a, const map<K, V> &b) { return container::compare(a, b) < 0; }

template<class K, class V>
bool operator>(const map<K, V> &a, const map<K, V> &b) { return container::compare(a, b) > 0; }

template<class K, class V>
bool operator<=(const map<K, V> &a, const map<K, V> &b) { return container::compare(a, b) <= 0; }

template<class K, class V>
bool operator>=(const map<K, V> &a, const map<K, V> &b) { return container::compare(a, b) >= 0; }

template<class K, class V>
Map<K, V> *mutate(map<K, V> &a) { return a; }

template<class K, class V>
String str(const Pair<K, V> &a)
{
    return Format{} << "(" << a->key() << ": " << a->value() << ")";
}

template<class K, class V>
String str(const map<K, V> &a)
{
    Format f;
    f << "[ ";
    for (auto &x: a)
        f << x << (&x == &a->last() ? " ]" : ", ");
    return f;
}

} // namespace cc
