/*
 * Copyright (C) 2019 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <string.h>
#include <iterator>
#include <limits>
#include <type_traits>
#include <cc/Local>
#include <cc/BucketMap>
#include <cc/debug> // DEBUG
#include <cc/Format> // DEBUG

namespace cc {
namespace index {

struct Branch;

struct Node
{
    static constexpr unsigned Capacity = 16;

    Node(bool isBranch = false):
        isBranch_{isBranch}
    {}

    Branch *parent_ { nullptr };
    Node *succ_ { nullptr };
    unsigned fill_ { 0 };
    bool isBranch_;
};

struct Head
{
    int64_t weight_;
    Node *node_;
};

class Branch: public Node
{
public:
    Branch(): Node{true} {}

    Local<Head> &at(unsigned nodeIndex) { assert(nodeIndex < fill_); return head_[nodeIndex]; }
    const Local<Head> &at(unsigned nodeIndex) const { assert(nodeIndex < fill_); return head_[nodeIndex]; }

    void push(unsigned nodeIndex, const Head *head);
    void pop(unsigned nodeIndex);

    int64_t weightAt(unsigned nodeIndex) const { return at(nodeIndex)->weight_; }

    void copyToPred(Branch *pred);

private:
    Local<Head> head_[Node::Capacity];
};

template<class Item, bool Trivial>
class LeafData: public Node
{
public:
    Item &at(unsigned nodeIndex) { return slot_[map_->mapToSlot(nodeIndex, fill_)]; }
    const Item &at(unsigned nodeIndex) const { return slot_[map_->mapToSlot(nodeIndex, fill_)]; }

    void push(unsigned nodeIndex, const Item &item) { slot_[map_->pushEntry(nodeIndex, fill_)] = item; }
    void pop(unsigned nodeIndex) { map_->popEntry(nodeIndex, fill_); }

    void copyToPred(LeafData *pred) const
    {
        for (unsigned i = 0; i < fill_; ++i)
            pred->push(pred->fill_, at(i));
    }

private:
    Local<BucketMap<Node::Capacity>> map_;
    Item slot_[Node::Capacity];
};

template<class Item>
class LeafData<Item, true>: public Node
{
public:
    Item &at(unsigned nodeIndex)
    {
        assert(nodeIndex < fill_);
        return slot_[nodeIndex];
    }

    const Item &at(unsigned nodeIndex) const
    {
        assert(nodeIndex < fill_);
        return slot_[nodeIndex];
    }

    void push(unsigned nodeIndex, const Item &item)
    {
        assert(fill_ < Node::Capacity);
        assert(nodeIndex <= fill_);

        if (nodeIndex < fill_)
            ::memmove(&slot_[nodeIndex + 1], &slot_[nodeIndex], (fill_ - nodeIndex) * sizeof(Item));

        slot_[nodeIndex] = item;
        ++fill_;
    }

    void pop(unsigned nodeIndex)
    {
        assert(fill_ > 0);
        assert(nodeIndex < fill_);

        --fill_;
        if (nodeIndex < fill_) {
            ::memmove(&slot_[nodeIndex], &slot_[nodeIndex + 1], (fill_ - nodeIndex) * sizeof(Item));
        }
    }

    void copyToPred(LeafData *pred) const
    {
        assert(pred->fill_ + fill_ <= Node::Capacity);

        ::memcpy(&pred->slot_[pred->fill_], &slot_[0], fill_ * sizeof(Item));
        pred->fill_ += fill_;
    }

private:
    Item slot_[Node::Capacity];
};

template<class Item>
class Leaf: public LeafData<Item, std::is_trivially_copyable<Item>::value && sizeof(Item) <= 2 * sizeof(void*)>
{
public:
    using Node::isBranch_;

    Leaf() { isBranch_ = 0; }

    int64_t weightAt(unsigned nodeIndex) const { return 1; }
};

class TreeData
{
protected:
    friend class Path;

    unsigned height_ { 0 };
    #ifndef NDEBUG
    uint64_t revision_ { 0 };
    #endif

    Local<Head> root_ {
        .weight_ = 0,
        .node_ = nullptr
    };
};

class Path
{
public:
    Path():
        node_{nullptr}
    {}

    Path(const TreeData *tree):
        origin_{0},
        node_{tree->root_->node_},
        depth_{0},
        nodeIndex_{0}
    {}

    Path(const TreeData *tree, int64_t index, bool insertion = false):
        origin_{0},
        node_{tree->root_->node_},
        depth_{0},
        nodeIndex_{0}
    {
        if (!node_) return;

        if (index + !insertion >= tree->root_->weight_) {
            while (node_->isBranch_) stepDown(node_->fill_ - 1);
            nodeIndex_ = node_->fill_ - !insertion;
        }
        else if (index <= 0) {
            while (node_->isBranch_) stepDown(0);
        }
        else {
            init(tree, index);
        }

        assert(!node_->isBranch_);
    }

    explicit operator bool() const { return node_; }
    Node *node() const { return node_; }
    Branch *branch() const { assert(node_ && node_->isBranch_); return static_cast<Branch *>(node_); }
    template<class Item> Leaf<Item> *leaf() const { assert(node_ && !node_->isBranch_); return static_cast<Leaf<Item> *>(node_); }

    unsigned depth() const { return depth_; }
    void grow() { ++depth_; origin_ <<= 4; }

    unsigned nodeIndex() const { return nodeIndex_; }
    void setNodeIndex(unsigned newValue) { nodeIndex_ = newValue; }

    template<class Item> Item &item() const { return leaf<Item>()->at(nodeIndex_); }

    bool hasPred() const { return origin_ != 0; }
    Path getPred() const { Local<Path> path{*this}; path->stepPred(); return path; }

    bool hasSucc() const { return node_ && node_->succ_; }
    Path getSucc() const { Local<Path> path{*this}; path->stepSucc(); return path; }

    bool hasParent() const { return depth_ > 0; }
    Path getParent() const { Local<Path> path{*this}; path->stepUp(); return path; }

    void stepDown(unsigned egress)
    {
        assert(egress < Node::Capacity);
        assert(depth_ < MaxDepth);
        assert(node_->isBranch_);

        node_ = static_cast<Branch *>(node_)->at(egress)->node_;
        origin_ |= (uint64_t(egress) << (depth_ << 2));
        nodeIndex_ = 0;
        ++depth_;
    }

    void stepUp()
    {
        assert(depth_ > 0);

        node_ = node_->parent_;
        nodeIndex_ = getOrigin();
        --depth_;
        origin_ &= ~(UINT64_C(0xF) << (depth_ << 2));
    }

    bool stepPred();
    bool stepSucc();

    bool iterateForward();
    bool iterateBackward();

    unsigned getOrigin() const;
    void setOrigin(unsigned newValue);

    unsigned getOriginAtDepth(unsigned depth) const;
    void setOriginAtDepth(unsigned depth, unsigned newValue);

    String toString() const // DEBUG
    {
        return Format{} << "Path { depth: " << depth_ << ", getOrigin(): " << ((depth_ > 0) ? getOrigin() : 0u) << ", origin: 0x" << hex(origin_, 16) << ", nodeIndex: " << nodeIndex_ << ", node: " << (void *)node_ << ", fill: " << (node_ ? node_->fill_ : 0u) << ", parent: " << (void *)(node_ ? node_->parent_ : nullptr) << " }";
    }

private:
    static constexpr unsigned MaxDepth = 16;

    void init(const TreeData *tree, int64_t index);

    uint64_t origin_;
    Node *node_;
    unsigned depth_;
    unsigned nodeIndex_;
};

class Tree: public TreeData
{
public:
    template<class Item>
    Item &at(int64_t index)
    {
        return (height_ == 0) ?
            static_cast<Leaf<Item> *>(root_->node_)->at(index) :
            Local<index::Path>{this, index}->item<Item>();
    }

    template<class Item>
    Item &at(int64_t index) const
    {
        return (height_ == 0) ?
            static_cast<Leaf<Item> *>(root_->node_)->at(index) :
            Local<index::Path>{this, index}->item<Item>();
    }

    int64_t count() const { return root_->weight_; }

    template<class Item>
    void push(int64_t index, const Item &item);

    template<class Item>
    void pop(int64_t index);

    template<class Item>
    void deplete()
    {
        if (root_->node_) {
            deplete<Item>(root_->node_);
            *this = Tree{};
        }
    }

    #ifndef NDEBUG
    uint64_t revision() const { return revision_; }
    #endif

    String dotify() const;

private:
    unsigned commonDepth(const Path *first, const Path *second);

    template<class Node>
    void dissipateForward(const Path *pred, const Path *dest);

    template<class Node>
    void dissipateBackward(const Path *dest, const Path *succ);

    template<class Node>
    void dissipateToPred(Path *dest, Path *pred);

    template<class Node>
    void dissipateToSucc(Path *dest, Path *succ);

    template<class Item>
    void pushInitial(const Item &item);

    template<class Item>
    void deplete(Node *node);

    void updateWeights(const Path *path, int64_t delta, unsigned minDepth);

    void updateWeights(const Path *path, int64_t delta)
    {
        updateWeights(path, delta, 0);
        root_->weight_ += delta;
    }

    void shiftWeights(const Path *from, const Path *to, int64_t delta)
    {
        unsigned minDepth = commonDepth(from, to);
        updateWeights(from, -delta, minDepth);
        updateWeights(to  ,  delta, minDepth);
    }

    template<class Node>
    void dissipate(Path *dest);

    template<class Node>
    void dissipateMax(Path *dest);

    void joinSucc(Path *path, Node *newNode);

    template<class Node>
    void relieve(const Path *dest);

    template<class Node>
    void collapseSucc(const Path *dest, const Path *succ);

    void reduce();

    void dotifyNode(Format &format, const Head *head, unsigned origin = 0u) const;

};

template<class Node>
void Tree::dissipateForward(const Path *pred, const Path *dest)
{
    Node *a = static_cast<Node *>(pred->node());
    Node *b = static_cast<Node *>(dest->node());

    assert(b->fill_ < Node::Capacity);
    assert(a->fill_ > 0);

    int64_t delta = a->weightAt(a->fill_ - 1);

    b->push(0, a->at(a->fill_ - 1));
    a->pop(a->fill_ - 1);

    shiftWeights(pred, dest, delta);
}

template<class Node>
void Tree::dissipateBackward(const Path *dest, const Path *succ)
{
    Node *a = static_cast<Node *>(dest->node());
    Node *b = static_cast<Node *>(succ->node());

    assert(a->fill_ < Node::Capacity);
    assert(b->fill_ > 0);

    int64_t delta = b->weightAt(0);

    a->push(a->fill_, b->at(0));
    b->pop(0);

    shiftWeights(succ, dest, delta);
}

template<class Node>
void Tree::dissipateToPred(Path *dest, Path *pred)
{
    if (dest->nodeIndex() > 0) {
        dissipateBackward<Node>(pred, dest);
        dest->setNodeIndex(dest->nodeIndex() - 1);
    }
    else {
        *dest = *pred;
        dest->setNodeIndex(dest->node()->fill_);
    }
}

template<class Node>
void Tree::dissipateToSucc(Path *dest, Path *succ)
{
    if (dest->nodeIndex() < dest->node()->fill_) {
        dissipateForward<Node>(dest, succ);
    }
    else {
        *dest = *succ;
        dest->setNodeIndex(0);
    }
}

template<class Item>
void Tree::push(int64_t index, const Item &item)
{
    do {
        if (height_ == 0) {
            Node *node = root_->node_;
            if (node) {
                if (node->fill_ < Node::Capacity) {
                    static_cast<Leaf<Item> *>(node)->push(index, item);
                    ++root_->weight_;
                    break;
                }
            }
            else {
                Leaf<Item> *leaf = new Leaf<Item>;
                leaf->push(0, item);
                root_->node_ = leaf;
                root_->weight_ = 1;
                break;
            }
        }

        Local<Path> path{this, index, true};
        assert(path);
        dissipate<Leaf<Item>>(&path);
        static_cast<Leaf<Item> *>(path->node())->push(path->nodeIndex(), item);
        updateWeights(path, 1);
    }
    while (false);

    #ifndef NDEBUG
    ++revision_;
    #endif
}

template<class Node>
void Tree::dissipate(Path *dest)
{
    do {
        if (dest->node()->fill_ < Node::Capacity) break;

        if (!dest->node()->isBranch_) {
            if (dest->hasSucc() && dest->hasPred()) {
                Local<Path> pred = dest->getPred();
                if (pred->node()->fill_ < Node::Capacity) {
                    dissipateToPred<Node>(dest, &pred);
                    break;
                }
            }
        }

        Local<Path> succ = dest->getSucc();

        if (!succ || succ->node()->fill_ == Node::Capacity) {
            joinSucc(dest, new Node);
            succ = dest->getSucc();
        }

        dissipateToSucc<Node>(dest, &succ);
    }
    while (false);
}

template<class Item>
void Tree::pop(int64_t index)
{
    if (height_ == 0) {
        Node *node = root_->node_;
        if (count() > 1) {
            static_cast<Leaf<Item> *>(node)->pop(index);
            --root_->weight_;
        }
        else
            deplete<Item>();
    }
    else if (count() > 1) {
        Local<Path> path{this, index};
        path->leaf<Item>()->pop(path->nodeIndex());
        updateWeights(path, -1);
        relieve<Leaf<Item>>(path);
        reduce();
    }
    else
        deplete<Item>();

    #ifndef NDEBUG
    ++revision_;
    #endif
}

template<class Node>
void Tree::relieve(const Path *dest)
{
    const unsigned minFill = Node::Capacity >> 1;

    if (dest->node()->fill_ < minFill) {
        do {
            Local<Path> succ = dest->getSucc();
            if (succ) {
                if (succ->node()->fill_ > minFill) {
                    dissipateBackward<Node>(dest, succ);
                    break;
                }
            }

            Local<Path> pred = dest->getPred();
            if (pred) {
                if (pred->node()->fill_ > minFill) {
                    dissipateForward<Node>(pred, dest);
                    break;
                }
            }

            if (succ) collapseSucc<Node>(dest, succ);
            else if (pred) collapseSucc<Node>(pred, dest);
        }
        while (false);
    }
}

template<class Node>
void Tree::collapseSucc(const Path *dest, const Path *succ)
{
    unsigned succOrigin = succ->getOrigin();
    shiftWeights(succ, dest, succ->node()->parent_->at(succOrigin)->weight_);
    static_cast<Node *>(succ->node())->copyToPred(static_cast<Node *>(dest->node()));
    Local<Path> parent = succ->getParent();
    parent->branch()->pop(succOrigin);
    dest->node()->succ_ = succ->node()->succ_;
    delete static_cast<Node *>(succ->node());
    relieve<Branch>(parent);
}

template<class Item>
void Tree::deplete(Node *node)
{
    if (node->isBranch_) {
        Branch *branch = static_cast<Branch *>(node);
        for (unsigned i = 0; i < branch->fill_; ++i)
            deplete<Item>(branch->at(i)->node_);
        delete branch;
    }
    else {
        delete static_cast<Leaf<Item> *>(node);
    }
}

template<class Item, class Tree, class Node>
class TreeIterator:
    public std::iterator<
        /*iterator_category*/ std::forward_iterator_tag,
        /*value_type*/        Item,
        /*difference_type*/   int64_t,
        /*pointer*/           void,
        /*reference*/         Item
    >
{
public:
    TreeIterator():
        index_{std::numeric_limits<int64_t>::max()}
    {}

    TreeIterator(Tree *tree, int64_t index):
        tree_{tree},
        index_{index}
        #ifndef NDEBUG
        , revision_{tree_->revision()}
        #endif
    {
        traverse();
    }

    Item &operator*() {
        assert(node_); // cannot deference an exhausted iterator
        return static_cast<Leaf<Item> *>(node_)->at(nodeIndex_);
    }

    Item *operator->() const { return &**this; }

    TreeIterator &operator++()
    {
        assert(index_ != std::numeric_limits<int64_t>::max()); // cannot increment an exhausted iterator
        assert(revision_ == tree_->revision()); // cannot modify container while iterating it
        ++index_;
        ++nodeIndex_;
        if (nodeIndex_ == node_->fill_) {
            nodeIndex_ = 0;
            node_ = node_->succ_;
            if (!node_)
                index_ = std::numeric_limits<int64_t>::max();
        }

        return *this;
    }

    TreeIterator operator+(int64_t delta) { return TreeIterator{tree_, index_ + delta}; }
    TreeIterator operator-(int64_t delta) { return TreeIterator{tree_, index_ - delta}; }

    int64_t operator-(const TreeIterator &b) const { return index_ - b.index_; }
    bool operator<(const TreeIterator &b) const { return index_ < b.index_; }

    bool operator==(const TreeIterator &b) const { return index_ == b.index_; }
    bool operator!=(const TreeIterator &b) const { return index_ != b.index_; }

private:
    void traverse()
    {
        Local<Path> path{tree_, index_};
        node_ = path->node();
        nodeIndex_ = path->nodeIndex();
        if (!node_)
            index_ = std::numeric_limits<int64_t>::max();
        #ifndef NDEBUG
        revision_ = tree_->revision();
        #endif
    }

    const Tree *tree_;
    int64_t index_;
    Node *node_;
    unsigned nodeIndex_;
    #ifndef NDEBUG
    uint64_t revision_;
    #endif
};

template<class Item>
class ConstIterator: public TreeIterator<const Item, const Tree, const Node>
{
public:
    ConstIterator()
    {}

    ConstIterator(const Tree *tree, int64_t index):
        TreeIterator<const Item, const Tree, const Node>{tree, index}
    {}
};

template<class Item>
class Iterator: public TreeIterator<Item, Tree, Node>
{
public:
    Iterator()
    {}

    Iterator(Tree *tree, int64_t index):
        TreeIterator<Item, Tree, Node>{tree, index}
    {}
};

}} // namespace cc::index
