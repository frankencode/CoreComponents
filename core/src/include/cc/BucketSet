/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/bucket>
#include <cc/binarySearch>

namespace cc {

template<class T>
class BucketSet: public Object
{
public:
    typedef int64_t Index;
    typedef T Item;

    static Ref<BucketSet> create() { return new BucketSet; }

    Index count() const { return tree_->count(); }

    const Item &at(Index index) const
    {
        assert(0 <= index && index < count());
        return tree_->at<Item>(index);
    }

    template<class Pattern>
    bool lookup(const Pattern &pattern, Index *finalIndex = nullptr) const
    {
        auto root = tree_->root()->node_;
        const Index n = tree_->root()->weight_;
        Index i = 0;
        bool found = false;
        if (root) {
            if (root->fill() == 1) {
                auto leaf = static_cast<const bucket::Leaf<Item> *>(root);
                found = binarySearch(leaf, pattern, &i);
            }
            else {
                if (at(n - 1) < pattern) {
                    i = n;
                }
                else {
                    #if 1
                    bucket::SearchShim<Item> shim{tree_};
                    bucket::Weight j = 0;
                    bool bucketFound = binarySearch(&shim, pattern, &j);
                    const bucket::Leaf<Item> *leaf = static_cast<const bucket::Leaf<Item> *>(tree_->idealLeafAt(j));
                    i = bucket::Tree::nodeOffset(leaf);
                    if (bucketFound) {
                        unsigned j = 0;
                        found = binarySearch(leaf, pattern, &j);
                        i += j;
                    }
                    #endif
                    #if 0
                    bucket::IdealShim<Item> shim{tree_};
                    Index j = 0;
                    found = binarySearch(&shim, pattern, &j);
                    i = tree_->idealToReal(j);
                    #endif
                }
            }
        }
        if (finalIndex) *finalIndex = i;
        return found;
    }

    bool contains(const Item &item) const
    {
        return lookup(item);
    }

    bool insert(const Item &item, Index *index = nullptr)
    {
        bool success = false;
        Index finalIndex = 0;
        if (!lookup(item, &finalIndex)) {
            tree_->push<Item>(finalIndex, item);
            success = true;
        }
        if (index) *index = finalIndex;
        return success;
    }

    template<class Pattern>
    bool remove(const Pattern &pattern)
    {
        bool success = false;
        Index index;
        if (lookup(pattern, &index)) {
            tree_->pop<Item>(index);
            success = true;
        }
        return success;
    }

    /** \name iterators
      * @{
      */
    typedef bucket::Iterator<Item> iterator;
    iterator begin() { return bucket::Iterator<Item>{&tree_, 0}; }
    iterator end() { return bucket::Iterator<Item>{}; }
    // iterator from(Index index);

    typedef bucket::ConstIterator<Item> const_iterator;
    const_iterator begin() const { return bucket::ConstIterator<Item>{tree_, 0}; }
    const_iterator end() const { return bucket::ConstIterator<Item>{}; }
    // const_iterator from(Index index) const;
    /** @}
      */

    void deplete() { tree_->deplete<Item>(); }

private:
    friend class bucket::Internals;
    friend class Local<BucketSet>;

    BucketSet() = default;
    ~BucketSet() { tree_->deplete<Item>(); }

    Local<bucket::Tree> tree_;
};

} // namespace cc
