/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Source>
#include <cc/string>

namespace cc {

class Dir;

/** \class DirWalker cc/DirWalker
  * \ingroup file_system
  * \brief Recursive directory tree traversal
  * \see Dir
  */
class DirWalker: public Source<string>
{
public:
    /** Open a directory for recursive tree traversal
      * \param path directory path
      * \return new object instance
      */
    static Ref<DirWalker> open(const string &path);

    /** Open a directory for recursive tree traversal, if it exists
      * \param path directory path
      * \return new object instance
      */
    static Ref<DirWalker> tryOpen(const string &path);

    /// Maximum recursive tree traversal depth (or -1 if none)
    int maxDepth() const { return maxDepth_; }

    /// \copydoc maxDepth()
    void setMaxDepth(int depth) { maxDepth_ = depth; }

    /// Overstep hidden files and directories during recursive tree traversal (defaults to false)
    bool ignoreHidden() const { return ignoreHidden_; }

    /// \copydoc ignoreHidden()
    void setIgnoreHidden(bool on) { ignoreHidden_ = on; }

    /// Follow symbolic links during recursive tree traversal (defaults to false)
    bool followSymlink() const { return followSymlink_; }

    /// \copydoc followSymlink()
    void setFollowSymlink(bool on) { followSymlink_ = on; }

    /// Child-first recursive tree traversal order (defaults to false)
    bool deleteOrder() const { return deleteOrder_; }

    /// \copydoc deleteOrder()
    void setDeleteOrder(bool on) { deleteOrder_ = on; }

    /** Read next file or directory path
      * \param path return the file or directory path
      * \param isDir true if the return path points to a directory
      * \return true if not end of information
      */
    bool read(string *path, bool *isDir);

    /** Read next file or directory path
      * \param path return the file or directory path
      * \return true if not end of information
      */
    bool read(string *path) { return read(path, nullptr); }

private:
    DirWalker(const string &path, Dir *dir = nullptr);

    int maxDepth_;
    bool ignoreHidden_;
    bool followSymlink_;
    bool deleteOrder_;
    int depth_;
    Ref<Dir> dir_;
    Ref<DirWalker> child_;
};

} // namespace cc
