/*
 * Copyright (C) 2007-2018 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/String>

namespace cc {

class Variant;

/** \class Color cc/Color
  * \ingroup misc
  * \brief 32-bit ARGB color value
  */
class Color
{
public:
    /** Convenience color values
      * \todo should be upper-case
      * @{
      */
    static const Color transparent;
    static const Color black;
    static const Color white;
    static const Color red;
    static const Color green;
    static const Color blue;
    /** @}
      */

    /** Construct an invalid Color
      */
    Color():
        instance_{0x00FFFFFFu}
    {}

    /** Construct a valid Color from a 32-bit word \a w
      */
    explicit Color(uint32_t w):
        instance_{w | (w < 0x1000000u ? 0xFF000000u : 0u)}
    {}

    /** \copydoc Color(const String &s)
      */
    explicit Color(const char *s)
    {
        bool ok = false;
        *this = parse(s, &ok);
        if (!ok) *this = Color{};
    }

    /** Construct a Color from color literal or name \a s
      * \param s color specification to parse
      * %Color literals can be either SVG color names (e.g. 'AliceBlue') or literal RGB tuples (\#RRGGBB, \#RRGGBBAA, \#RGB, \#RGBA).
      */
    explicit Color(const String &s)
    {
        bool ok = false;
        *this = parse(s, &ok);
        if (!ok) *this = Color{};
    }

    /** Construct a Color from a Variant \a v
      */
    Color(const Variant &v);

    /** Compose a Color from its components
      * \param r red component (0..0xFF)
      * \param g green component (0..0xFF)
      * \param b blue component (0..0xFF)
      * \param a alpha value / opacity (0..0xFF)
      */
    template<class T>
    Color(T r, T g, T b, T a = 0xFF):
        instance_{r, g, b, a}
    {}

    /** Construct a Color from a palette value \a v
      */
    template<class T>
    explicit Color(T v):
        Color{static_cast<uint32_t>(v)}
    {}

    /** \copydoc Color(const char *)
      * \param ok return true if \a s is a valid color literal or name
      */
    static Color parse(const char *s, bool *ok = nullptr);

    /** Construct a Color from a 32-bit word \a w
      */
    static Color fromWord(uint32_t w) { Color c; c->w_ = w; return c; }

    /** Return the full color with hue \a h
      * \param h hue in range [0, 360]
      */
    static Color fromHue(double h) { return fromHsv(h, 1., 1.); }

    /** Construct Color from a HSV tuple
      * \param h hue in range [0, 360]
      * \param s saturation in range [0, 1]
      * \param v value in range [0, 1]
      */
    static Color fromHsv(double h, double s, double v);

    /** Construct Color from HSL tuple
      * \param h hue in range [0, 360]
      * \param s saturation in range [0, 1]
      * \param l luminance in range [0, 1]
      */
    static Color fromHsl(double h, double s, double l);

    /** Alpha-blend color \a a over color \a b and return result
      */
    static Color blend(Color a, Color b)
    {
        b->applyOver(a);
        return b;
    }

    class Instance {
    public:
        /** Check if valid
          * A Color is considered invalid, if alpha is zero and red, green or blue is non-zero.
          */
        bool isValid() const {
            return !(
                alpha() == 0 && (
                    red()   != 0 ||
                    green() != 0 ||
                    blue()  != 0
                )
            );
        }

        /** Convenience function to check if \a c is a fully opaque
          */
        bool isOpaque() const {
            return alpha() == 0xFF;
        }

        /** Getters for individual color components
          * @{
          */
        uint32_t alpha() const { return component<AlphaShift>(); }
        uint32_t red  () const { return component<RedShift  >(); }
        uint32_t green() const { return component<GreenShift>(); }
        uint32_t blue () const { return component<BlueShift >(); }
        /** @}
          */

        /** Alpha-blend color \a b over this color
          */
        void applyOver(Color b);

        /** Mix color \a b into this color
          */
        void mixIn(Color b, int percent);

        /** Return a lighter version of this color
          */
        Color lighter(int percent) const {
            Color c = Color::fromWord(w_);
            c->mixIn(Color::white, percent);
            return c;
        }

        /** Return a darker version of this color
          */
        Color darker(int percent) const {
            Color c = Color::fromWord(w_);
            c->mixIn(Color::black, percent);
            return c;
        }

        /** Translate from non-premultiplied to premultiplied representation
          */
        Color premultiplied() const
        {
            Color c = Color::fromWord(w_);
            c->premultiply();
            return c;
        }

        /** Translate from premultiplied to non-premultiplied representation
          */
        Color normalized() const
        {
            Color c = Color::fromWord(w_);
            c->normalize();
            return c;
        }

        /** \copydoc premultiplied()
          */
        void premultiply()
        {
            uint32_t h = w_;
            uint16_t a = component<AlphaShift, uint16_t>(h);
            if (a == 0 || a == 0xFF) return;
            typedef uint16_t v4ui16 __attribute__((vector_size(8)));
            v4ui16 v {
                component<RedShift,   uint16_t>(h),
                component<GreenShift, uint16_t>(h),
                component<BlueShift,  uint16_t>(h),
                0
            };
            v = (a * v) / 0xFF;
            w_ = compose(v[0], v[1], v[2], a);
        }

        /** \copydoc normalized()
          */
        void normalize()
        {
            uint32_t h = w_;
            uint16_t a = component<AlphaShift, uint16_t>(h);
            if (a == 0 || a == 0xFF) return;
            typedef uint16_t v4ui16 __attribute__((vector_size(8)));
            v4ui16 v {
                component<RedShift,   uint16_t>(h),
                component<GreenShift, uint16_t>(h),
                component<BlueShift,  uint16_t>(h),
                0
            };
            v = (0xFF * v) / a;
            w_ = compose(v[0], v[1], v[2], a);
        }

        /// convert to a 32-bit word
        uint32_t toWord() const { return w_; }

        /// Stringify this color value
        String toString() const;

    private:
        friend class Color;

        Instance()
        {}

        Instance(uint32_t w):
            w_{w}
        {}

        template<class T>
        Instance(T r, T g, T b, T a = 0xFF):
            w_{compose(r, g, b, a)}
        {}

        enum {
            AlphaShift = 24,
            RedShift   = 16,
            GreenShift =  8,
            BlueShift  =  0
        };

        template<int Shift, class T = uint32_t>
        T component() const { return component<Shift, T>(w_); }

        template<int Shift, class T = uint32_t>
        static T component(uint32_t w) { return (w >> Shift) & 0xFF; }

        template<class T>
        static uint32_t compose(T r, T g, T b, T a = 0xFF) {
            return
                (uint32_t(a) << AlphaShift) |
                (uint32_t(r) << RedShift  ) |
                (uint32_t(g) << GreenShift) |
                (uint32_t(b) << BlueShift ) ;
        };

        uint32_t w_;
    };

    /** Create a color tone from this color with \a percent opacity
      */
    Color operator()(int percent) const
    {
        return Color{
            (*this)->red(),
            (*this)->green(),
            (*this)->blue(),
            uint32_t(percent) * 0xFF / 100
        };
    }

    /** Comparism operators
      * @{
      */
    bool operator==(const Color &b) const { return (*this)->w_ == b->w_; }
    bool operator!=(const Color &b) const { return (*this)->w_ != b->w_; }
    /** @}
      */

    const Instance *operator->() const { return &instance_; }
    Instance *operator->() { return &instance_; }

    explicit operator bool() const { return (*this)->isValid(); }

private:
    friend class Variant;

    Instance instance_;
};

/// Stringify color \a c
inline String str(const Color &c) { return c->toString(); }

} // namespace cc
