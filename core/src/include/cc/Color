/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/String>

namespace cc {

class Variant;

/** \class Color cc/Color
  * \ingroup misc
  * \brief 32-bit ARGB color value
  * \see ColorNames
  */
class Color
{
public:
    /** Construct an invalid color
      */
    Color():
        w_{0x00FFFFFF}
    {}

    /** Construct a color from a color literal or name \a s.
      * \param s color specification to parse
      * %Color literals can be either SVG color names (e.g. 'AliceBlue') or literal RGB tuples (\#RRGGBB, \#RRGGBBAA, \#RGB, \#RGBA).
      */
    Color(const char *s)
    {
        bool ok = false;
        *this = parse(s, &ok);
        if (!ok) *this = Color();
    }

    /** Compose a color from its components
      * \param r red component (0..0xFF)
      * \param g green component (0..0xFF)
      * \param b blue component (0..0xFF)
      * \param a alpha value / opacity (0..0xFF)
      */
    template<class T>
    Color(T r, T g, T b, T a = 0xFF):
        w_{compose(r, g, b, a)}
    {}

    /** \copydoc Color(const char *)
      * \param ok return true if \a s is a valid color literal or name
      */
    static Color parse(const char *s, bool *ok = 0);

    /** Construct a color from a 32-bit word \a w
      */
    inline static Color fromWord(uint32_t w) { Color c; c.w_ = w; return c; }

    /** Return the full color with hue \a h
      * \param h hue in range [0, 360]
      */
    inline static Color fromHue(double h) { return fromHsv(h, 1., 1.); }

    /** Construct color from a HSV
      * \param h hue in range [0, 360]
      * \param s saturation in range [0, 1]
      * \param v value in range [0, 1]
      */
    static Color fromHsv(double h, double s, double v);

    /** Construct color from a HSL
      * \param h hue in range [0, 360]
      * \param s saturation in range [0, 1]
      * \param l luminance in range [0, 1]
      */
    static Color fromHsl(double h, double s, double l);

    /** Check if color \c is valid
      * A color is considered invalid, if alpha is zero and red, green or blue is non-zero.
      */
    inline static bool isValid(Color c) {
        return !(
            alpha(c) == 0 && (
                red(c)   != 0 ||
                green(c) != 0 ||
                blue(c)  != 0
            )
        );
    }

    /** Convenience function to check if \a c is a fully opaque color
      */
    inline static bool isOpaque(Color c) {
        return alpha(c) == 0xFF;
    }

    /** Getters for individual color components
      * @{
      */
    inline static uint32_t alpha(Color c) { return component<Alpha>(c); }
    inline static uint32_t red  (Color c) { return component<Red  >(c); }
    inline static uint32_t green(Color c) { return component<Green>(c); }
    inline static uint32_t blue (Color c) { return component<Blue >(c); }
    /** @}
      */

    /** Automatic conversion to a 32-bit word
      */
    inline operator uint32_t() { return w_; }

    /** Comparism operators
      * @{
      */
    inline bool operator==(const Color &b) const { return w_ == b.w_; }
    inline bool operator!=(const Color &b) const { return w_ != b.w_; }
    /** @}
      */

    /** Alpha-blend color \a a over color \a b
      */
    static Color blend(Color a, Color b);

    /** Return the premultiplied version of color \a c
      */
    inline static Color premultiplied(Color c)
    {
        uint32_t h = c.w_;
        uint16_t a = component<Alpha, uint16_t>(h);
        if (a == 0 || a == 0xFF) return c;
        typedef uint16_t v4ui16 __attribute__((vector_size(8)));
        v4ui16 v {
            component<Red,   uint16_t>(h),
            component<Green, uint16_t>(h),
            component<Blue,  uint16_t>(h),
            0
        };
        v = (a * v) / 0xFF;
        return Color(v[0], v[1], v[2], a);
    }

    /** Translate a premultiplied color to a non-premultiplied color
      */
    inline static void normalize(Color *c)
    {
        uint32_t h = c->w_;
        uint16_t a = component<Alpha, uint16_t>(h);
        if (a == 0 || a == 0xFF) return;
        typedef uint16_t v4ui16 __attribute__((vector_size(8)));
        v4ui16 v {
            component<Red,   uint16_t>(h),
            component<Green, uint16_t>(h),
            component<Blue,  uint16_t>(h),
            0
        };
        v = (0xFF * v) / a;
        c->w_ = compose(v[0], v[1], v[2], a);
    }

private:
    friend class Variant;

    enum Shift {
        Alpha = 24,
        Red   = 16,
        Green =  8,
        Blue  =  0
    };

    template<int Shift, class T = uint32_t>
    inline static T component(Color c) { return component<Shift, T>(c.w_); }

    template<int Shift, class T = uint32_t>
    inline static T component(uint32_t w) { return (w >> Shift) & 0xFF; }

    template<class T>
    inline static uint32_t compose(T r, T g, T b, T a) {
        return
            (uint32_t(a) << Alpha) |
            (uint32_t(r) << Red  ) |
            (uint32_t(g) << Green) |
            (uint32_t(b) << Blue ) ;
    };

    uint32_t w_;
};

/** Convenience color constants
  * @{
  */
const Color transparent { 0x00, 0x00, 0x00, 0x00 };
const Color black       { 0x00, 0x00, 0x00 };
const Color white       { 0xFF, 0xFF, 0xFF };
const Color red         { 0xFF, 0x00, 0x00 };
const Color green       { 0x00, 0xFF, 0x00 };
const Color blue        { 0x00, 0x00, 0xFF };
/** @}
  */

/// Stringify color \a c
String str(Color c);

} // namespace cc
