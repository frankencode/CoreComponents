/*
 * Copyright (C) 2007-2018 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/String>

namespace cc {

class Variant;

/** \class Color cc/Color
  * \ingroup misc
  * \brief 32-bit ARGB color value
  * \see ColorNames
  */
class Color
{
public:
    /** Convenience color constants
      * @{
      */
    static const Color Transparent;
    static const Color Black;
    static const Color White;
    static const Color Red;
    static const Color Green;
    static const Color Blue;
    static const Color Yellow;
    static const Color Cyan;
    static const Color Magenta;
    /** @}
      */

    /** Construct an invalid color
      */
    Color():
        w_{0x00FFFFFFu}
    {}

    /** Construct a color from a color literal or name \a s.
      * \param s color specification to parse
      * %Color literals can be either SVG color names (e.g. 'AliceBlue') or literal RGB tuples (\#RRGGBB, \#RRGGBBAA, \#RGB, \#RGBA).
      */
    Color(const char *s)
    {
        bool ok = false;
        *this = parse(s, &ok);
        if (!ok) *this = Color();
    }

    /** Compose a color from its components
      * \param r red component (0..0xFF)
      * \param g green component (0..0xFF)
      * \param b blue component (0..0xFF)
      * \param a alpha value / opacity (0..0xFF)
      */
    template<class T>
    Color(T r, T g, T b, T a = 0xFF):
        w_{compose(r, g, b, a)}
    {}

    /** Create a black tone with \a percent opacity
      */
    static Color shade(int percent) { return Color{ 0,       0,    0, percent * 0xFF / 100 }; }

    /** Create a white tone with \a percent opacity
      */
    static Color tint(int percent) { return Color{ 0xFF, 0xFF, 0xFF, percent * 0xFF / 100 }; }

    /** Create a color from a palette \a value
      */
    template<class PaletteValue>
    static Color tone(PaletteValue value) { return Color::fromWord(static_cast<uint32_t>(value) | 0xFF000000u); }

    /** \copydoc Color(const char *)
      * \param ok return true if \a s is a valid color literal or name
      */
    static Color parse(const char *s, bool *ok = 0);

    /** Construct a color from a 32-bit word \a w
      */
    inline static Color fromWord(uint32_t w) { Color c; c.w_ = w; return c; }

    /** Return the full color with hue \a h
      * \param h hue in range [0, 360]
      */
    inline static Color fromHue(double h) { return fromHsv(h, 1., 1.); }

    /** Construct color from a HSV
      * \param h hue in range [0, 360]
      * \param s saturation in range [0, 1]
      * \param v value in range [0, 1]
      */
    static Color fromHsv(double h, double s, double v);

    /** Construct color from a HSL
      * \param h hue in range [0, 360]
      * \param s saturation in range [0, 1]
      * \param l luminance in range [0, 1]
      */
    static Color fromHsl(double h, double s, double l);

      /** Check if color \c is valid
      * A color is considered invalid, if alpha is zero and red, green or blue is non-zero.
      */
    inline static bool isValid(Color c) {
        return !(
            alphaComponent(c) == 0 && (
                redComponent(c)   != 0 ||
                greenComponent(c) != 0 ||
                blueComponent(c)  != 0
            )
        );
    }

    /** Convenience function to check if \a c is a fully opaque color
      */
    inline static bool isOpaque(Color c) {
        return alphaComponent(c) == 0xFF;
    }

    /** Getters for individual color components
      * @{
      */
    inline static uint32_t alphaComponent(Color c) { return component<AlphaShift>(c); }
    inline static uint32_t redComponent  (Color c) { return component<RedShift  >(c); }
    inline static uint32_t greenComponent(Color c) { return component<GreenShift>(c); }
    inline static uint32_t blueComponent (Color c) { return component<BlueShift >(c); }
    /** @}
      */

    /** Automatic conversion to a 32-bit word
      */
    inline operator uint32_t() { return w_; }

    /** Comparism operators
      * @{
      */
    inline bool operator==(const Color &b) const { return w_ == b.w_; }
    inline bool operator!=(const Color &b) const { return w_ != b.w_; }
    /** @}
      */

    /** Alpha-blend color \a a over color \a b
      */
    static Color blend(Color a, Color b);

    /** Return the premultiplied version of color \a c
      */
    inline static Color premultiplied(Color c)
    {
        uint32_t h = c.w_;
        uint16_t a = component<AlphaShift, uint16_t>(h);
        if (a == 0 || a == 0xFF) return c;
        typedef uint16_t v4ui16 __attribute__((vector_size(8)));
        v4ui16 v {
            component<RedShift,   uint16_t>(h),
            component<GreenShift, uint16_t>(h),
            component<BlueShift,  uint16_t>(h),
            0
        };
        v = (a * v) / 0xFF;
        return Color(v[0], v[1], v[2], a);
    }

    /** Translate a premultiplied color to a non-premultiplied color
      */
    inline static void normalize(Color *c)
    {
        uint32_t h = c->w_;
        uint16_t a = component<AlphaShift, uint16_t>(h);
        if (a == 0 || a == 0xFF) return;
        typedef uint16_t v4ui16 __attribute__((vector_size(8)));
        v4ui16 v {
            component<RedShift,   uint16_t>(h),
            component<GreenShift, uint16_t>(h),
            component<BlueShift,  uint16_t>(h),
            0
        };
        v = (0xFF * v) / a;
        c->w_ = compose(v[0], v[1], v[2], a);
    }

private:
    friend class Variant;

    enum {
        AlphaShift = 24,
        RedShift   = 16,
        GreenShift =  8,
        BlueShift  =  0
    };

    template<int Shift, class T = uint32_t>
    inline static T component(Color c) { return component<Shift, T>(c.w_); }

    template<int Shift, class T = uint32_t>
    inline static T component(uint32_t w) { return (w >> Shift) & 0xFF; }

    template<class T>
    inline static uint32_t compose(T r, T g, T b, T a) {
        return
            (uint32_t(a) << AlphaShift) |
            (uint32_t(r) << RedShift  ) |
            (uint32_t(g) << GreenShift) |
            (uint32_t(b) << BlueShift ) ;
    };

    uint32_t w_;
};

/// Stringify color \a c
String str(Color c);

} // namespace cc
