/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

namespace cc {

/** \class Bits cc/Bits
  * \ingroup bits
  * \brief %Select the bits \a i to \a j from a word of type \a T.
  * \tparam T %Unsigned integer type
  * \tparam j %High bit position
  * \tparam i %Low bit position
  */
template<class T, unsigned j, unsigned i>
class Bits
{
    static const T Mask { (~T{}) >> (8 * sizeof(T) - (j - i + 1)) };

public:
    /** Create a new bit selector
      * \param word %Word to select bits from
      */
    explicit Bits(T &word):
        word_{word}
    {
        static_assert(j < 8 * sizeof(T), "invalid bit range");
        static_assert(i <= j, "invalid bit range");
    }

    /// %Return value of selection
    operator T() const { return (word_ >> i) & Mask; }

    /// Assign a new value to the bit selection
    template<class Value>
    Bits &operator=(Value value)
    {
        word_ &= ~(Mask << i);
        word_ |= (static_cast<T>(value) & Mask) << i;
        return *this;
    }

    /// Combine a new value to the bit selection using the or operator
    template<class Value>
    Bits &operator|=(Value value)
    {
        word_ |= (static_cast<T>(value) & Mask) << i;
        return *this;
    }

    /// Combine a new value to the bit selection using the xor operator
    template<class Value>
    Bits &operator^=(Value value)
    {
        word_ ^= (static_cast<T>(value) & Mask) << i;
        return *this;
    }

    /// Combine a new value to the bit selection using the and operator
    template<class Value>
    Bits &operator&=(Value value)
    {
        word_ &= (static_cast<T>(value) & Mask) << i;
        return *this;
    }

private:
    T &word_;
};

/** \brief Select bit \a i from a word of type \a T
  * \ingroup bits
  * \tparam T %Unsigned integer type
  * \tparam i %Bit position
  */
template<class T, unsigned i>
using Bit = Bits<T, i, i>;

/** Get value of bit \a i in \a word
  * \ingroup bits
  */
template<unsigned i, class T>
Bit<T, i> bit(T &word) {
    return Bit<T, i>{word};
}

/** Get value of bits \a i to \a j in \a word
  * \ingroup bits
  */
template<unsigned j, unsigned i = j, class T>
Bits<T, j, i> bits(T &word) {
    return Bits<T, j, i>{word};
}

} // namespace cc
