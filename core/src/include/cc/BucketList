/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Object>
#include <cc/bucket>
#include <cc/Set>

namespace cc {

template<class T>
class BucketList: public Object
{
public:
    typedef bucket::Weight Index;
    typedef T Item;

    static Ref<BucketList> create() { return new BucketList; }

    static Ref<BucketList> allocate(Index count)
    {
        // TODO: improve performance

        auto list = new BucketList;
        for (; count > 0; --count) list->pushBack(Item{});
        return list;
    }


    static Ref<BucketList> copy(const BucketList *other)
    {
        // TODO: improve performance

        auto list = new BucketList;
        for (const Item &item: other) list->pushBack(item);
        return list;
    }

    Index count() const { return tree_->count(); }

    Item &at(Index index)
    {
        assert(0 <= index && index < count());
        return tree_->at<Item>(index);
    }

    const Item &at(Index index) const
    {
        assert(0 <= index && index < count());
        return tree_->at<Item>(index);
    }

    void push(Index index, const Item &item)
    {
        assert(0 <= index && index <= count());
        tree_->push<Item>(index, item);
    }

    void pop(Index index)
    {
        assert(0 <= index && index < count());
        tree_->pop<Item>(index);
    }

    void pushBack(const Item &item)
    {
        tree_->pushBack(item);
    }

    void popBack()
    {
        assert(count() > 0);
        pop(count());
    }

    void pushFront(const Item &item)
    {
        push(0, item);
    }

    void popFront()
    {
        assert(count() > 0);
        pop(0);
    }

    void append(const Item &item)
    {
        tree_->pushBack(item);
    }

    /** Append a copy of another list to this list
      * \param b another list
      */
    void appendList(const BucketList *other)
    {
        if (other) {
            // TODO: improve performance

            for (const Item &item: other)
                tree_->pushBack(item);
        }
    }

    template<class Iterator>
    void pushAndStep(Iterator &target, const Item &item)
    {
        tree_->pushAndStep(target, item);
    }

    template<class Iterator>
    void popAndStep(Iterator &target)
    {
        tree_->popAndStep(target);
    }

    /** Return a copy of this list
      * \return new object instance
      */
    Ref<BucketList> copy() const { return BucketList::copy(this); }

    /** Search for an item
      * \param item item to search for
      * \param index start position for the search
      * \return first position the item was found in or count() if the item couldn't be found
      */
    int find(const Item &item, Index index = 0) const
    {
        auto it = beginAt(index);
        for (; it; ++it) {
            if (*it == item) break;
        }
        return +it;
    }

    /** Test if the list contains a certain item
      * \param item item to test for
      * \return true if the item appears in the list
      */
    bool contains(const Item &item) const
    {
        return find(item) < count();
    }

    void deplete() { tree_->deplete<Item>(); }

    Item &first() { assert(count() > 0); return tree_->first<Item>(); }
    const Item &first() const { assert(count() > 0); return tree_->first<Item>(); }

    Item &last() { assert(count() > 0); return tree_->last<Item>(); }
    const Item &last() const { assert(count() > 0); return tree_->last<Item>(); }

    /** Create a reversed copy of this list
      * \return reversed list
      */
    Ref<BucketList> reverse() const
    {
        // TODO: improve performance

        Ref<BucketList> result = BucketList::allocate(count());
        for (int i = 0, n = count(); i < n; ++i)
            result->at(i) = at(n - i - 1);
        return result;
    }

    /** Remove duplicate entries from the list
      * \param list list to eliminate duplicates from
      */
    static void makeUnique(BucketList *list)
    {
        auto set = Set<Item>::create();
        for (auto it = list->begin(); it;) {
            if (set->insert(*it)) ++it;
            else list->popAndStep(it);
        }
    }

    /** Convert to a list of different item type
      * \tparam T2 the target item type
      * \return new list instance
      */
    template<class Item2>
    Ref< BucketList<Item2> > toList() const {
        auto other = BucketList<Item2>::create();
        for (const Item &item: this)
            other->append(item);
        return other;
    }

    /// \copydoc push(const Item &item)
    void operator<<(const Item& item) { pushBack(item); }

    /// \copydoc pop()
    void operator>>(Item* item) { *item = first(); popFront(); }

    /** \name Iterators
      * @{
      */
    typedef bucket::Iterator<Item> Iterator;
    Iterator begin() { return Iterator{&tree_}; }
    Iterator end() { return Iterator{}; }

    typedef bucket::ConstIterator<Item> ConstIterator;
    ConstIterator begin() const { return ConstIterator{tree_}; }
    ConstIterator end() const { return ConstIterator{}; }
    ConstIterator beginAt(Index index) const { return ConstIterator{tree_, index}; }
    /** @}
      */

    /** \internal
      * @{
      */
    typedef Iterator iterator;
    typedef ConstIterator const_iterator;
    /** @}
      */

    /** \name Source adapters
      * @{
      */
    template<class OutputType = Item>
    Ref< Source<OutputType> > getAll() const { return ContainerSource< BucketList, Pass<Item, OutputType> >::open(this); }
    /** @}
      */

private:
    friend class Local<BucketList>;
    friend class bucket::Internals;

    BucketList() = default;
    ~BucketList() { tree_->deplete<Item>(); }

    BucketList(const BucketList &) = delete;

    Local<bucket::Tree> tree_;
};

} // namespace cc
