/*
 * Copyright (C) 2007-2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/bucket>

namespace cc {

/** \class pair cc/pair
  * \brief key_type value pair
  */
template<class K, class V = K>
class pair
{
public:
    typedef K key_type;
    typedef V value_type;

    pair()
    {}

    pair(const key_type &key):
        instance_{key}
    {}

    pair(const key_type &key, const value_type &value):
        instance_{key, value}
    {}

    bool operator< (const pair &b) const { return instance_.key_ <  b.instance_.key_; }
    bool operator> (const pair &b) const { return instance_.key_ >  b.instance_.key_; }
    bool operator==(const pair &b) const { return instance_.key_ ==  b.instance_.key_; }
    bool operator!=(const pair &b) const { return instance_.key_ !=  b.instance_.key_; }
    bool operator<=(const pair &b) const { return instance_.key_ <=  b.instance_.key_; }
    bool operator>=(const pair &b) const { return instance_.key_ >=  b.instance_.key_; }

    class Instance {
    public:
        key_type key() const { return key_; }
        value_type value() const { return value_; }
        value_type &value() { return value_; }
        void setValue(const value_type &newValue) { value_ = newValue; }

    private:
        friend class pair;
        Instance()
        {}
        Instance(const key_type &key):
            key_{key}, value_{value_type{}}
        {}
        Instance(const key_type &key, const value_type &value):
            key_{key}, value_{value}
        {}
        key_type key_;
        value_type value_;
    };

    Instance *operator->() { return &instance_; }
    const Instance *operator->() const { return &instance_; }

private:
    Instance instance_;
};

template<class K, class V>
class IteratorAccess< const pair<K, V> > {
public:
    typedef K key_type;
    typedef V value_type;
    typedef pair<K, V> Item;

    typedef const Item &DerefAccess;
    typedef IteratorAccess MemberAccess;

    IteratorAccess(const Item &item): item_{&item} {}

    key_type key() const { return (*item_)->key(); }
    value_type value() const { return (*item_)->value(); }

    const IteratorAccess *operator->() const { return this; }

private:
    const Item *item_;
};

template<class K, class V>
class IteratorAccess< pair<K, V> > {
public:
    typedef K key_type;
    typedef V value_type;
    typedef pair<K, V> Item;

    typedef const Item &DerefAccess;
    typedef IteratorAccess MemberAccess;

    IteratorAccess(Item &item): item_{&item} {}

    key_type key() const { return (*item_)->key(); }
    value_type &value() const { return (*item_)->value(); }
    void setValue(const value_type &newValue) const { (*item_)->setValue(newValue); }

    const IteratorAccess *operator->() const { return this; }

private:
    Item *item_;
};

} // namespace cc
