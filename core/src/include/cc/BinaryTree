/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/assert>
#include <cc/ExclusiveAccess>

namespace cc {

class BinaryNode
{
public:
    BinaryNode():
        weight_(1),
        balance_(0)
    {}

    BinaryNode *left_;
    BinaryNode *right_;
    BinaryNode *parent_;
    int weight_;
    int balance_;
};

class BinaryTree;

class AvlBalance
{
protected:
    static void restore(BinaryTree *tree, BinaryNode *kp, bool left, bool attached);

private:
    static BinaryNode *rebalance(BinaryTree *tree, BinaryNode *k1);

public:
#ifndef NDEBUG
    static int height(BinaryNode *k);
    static bool testBalance(BinaryNode *k);
#endif
};

#ifndef NDEBUG
class BinaryTreeTester;
#endif

class BinaryTree: public AvlBalance
{
public:
    inline BinaryNode *min() const { return min(root_); }
    inline BinaryNode *max() const { return max(root_); }

    void attach(BinaryNode *kp, BinaryNode *kn, bool left);
    BinaryNode *unlink(BinaryNode *k);

protected:
    inline int weight() const { return weight(root_); }
    inline static int weight(BinaryNode *k) { return (k) ? k->weight_ : 0; }

    BinaryNode *getNodeAt(int i) const;
    void attachAt(int i, BinaryNode *kn);
    BinaryNode *unlinkAt(int i);

    BinaryTree(): root_(0), cachedNode_(0) {}
    void populate(BinaryNode **v, int n);

    template<class Node>
    static Node *clone(Node *k);

    template<class Node>
    inline void clear() {
        clear(static_cast<Node *>(root_));
        root_ = 0;
        cachedNode_ = 0;
    }

    virtual void changed(BinaryNode *kp, BinaryNode *kc, bool left, bool attached);
    virtual void rotated(BinaryNode *k1, bool /*left*/);

    BinaryNode *root_;

private:
    friend class AvlBalance;
    #ifndef NDEBUG
    friend class BinaryTreeTester;
    #endif

    void attachBefore(BinaryNode *kb, BinaryNode *kn);

    BinaryNode *detach(BinaryNode *k);
    void replace(BinaryNode *ki, BinaryNode *kl);

    void rotate(BinaryNode *k1, bool left);

    inline static void establishWeight(BinaryNode *k) { k->weight_ = weight(k->left_) + weight(k->right_) + 1; }

    static BinaryNode *min(BinaryNode *k);
    static BinaryNode *max(BinaryNode *k);

    static BinaryNode *pred(BinaryNode *k);
    static BinaryNode *succ(BinaryNode *k);

    template<class Node>
    static void clear(Node *k);

    static bool testStructure(BinaryNode *k);
    static bool testWeight(BinaryNode *k);
    static bool testIteration(BinaryNode *k);

    mutable ExclusiveSection cacheExclusive_;
    mutable BinaryNode *cachedNode_;
    mutable int cachedIndex_;
};

template<class Node>
Node *BinaryTree::clone(Node *k)
{
    if (!k) return 0;
    Node *kn = new Node(*k);
    if (!k->parent_) kn->parent_ = 0;
    if (k->left_) {
        kn->left_ = clone(k->left());
        kn->left_->parent_ = kn;
    }
    else {
        kn->left_ = 0;
    }
    if (k->right_) {
        kn->right_ = clone(k->right());
        kn->right_->parent_ = kn;
    }
    else {
        kn->right_ = 0;
    }
    return kn;
}

template<class Node>
void BinaryTree::clear(Node *k)
{
    if (!k) return;
    clear(k->left());
    clear(k->right());
    delete k;
}

#ifndef NDEBUG

class BinaryTreeTester {
protected:
    static bool testStructure(const BinaryTree *tree) { return tree->testStructure(tree->root_); }
    static bool testWeight(const BinaryTree *tree) { return tree->testWeight(tree->root_); }
    static bool testIteration(const BinaryTree *tree) { return tree->testIteration(tree->root_); }
    static bool testBalance(const BinaryTree *tree) { return tree->testBalance(tree->root_); }

    static bool test(const BinaryTree *tree) {
        return
            testStructure(tree) &&
            testWeight(tree) &&
            testIteration(tree) &&
            testBalance(tree);
    }
};

#endif

} // namespace cc
