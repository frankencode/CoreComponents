/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Map>
#include <cc/Queue>

namespace cc {

template<class T>
class priority_queue;

/** \class PriorityQueue cc/PriorityQueue
  * \ingroup container_dynamic
  * \brief Priority based queue data container
  * \tparam T item type
  * \see Queue, Channel
  */
template<class T>
class PriorityQueue: public Object
{
public:
    typedef T value_type;
    typedef int64_t size_type;

    /** Create a new queue
      * \return new object instance
      */
    static Ref<PriorityQueue> create() { return new PriorityQueue; }

    /** Add a new item to the end of the queue
      * \param item item value
      * \param priority priority of item
      */
    void pushBack(const T &item, int priority = 0)
    {
        inputQueue(priority)->pushBack(item);
    }

    /** Remove an item from the head of the queue
      * \param item optionally returns the item value
      * \return item value
      */
    const T &popFront(T *item)
    {
        CC_ASSERT(size_ > 0);
        return outputQueue()->popFront(item);
    }

    /** Remove the first item from the queue
      * \return item value
      */
    T popFront() {
        T item;
        return popFront(&item);
    }

    /// \copydoc pushBack()
    void push(const T &item, int priority) { pushBack(item, priority); }

    /// \copydoc popFront(T *)
    const T &pop(T *item) { return popFront(item); }

    /// \copydoc popFront()
    T pop() { return popFront(); }

    /// Return the number of queued items
    int count() const { return size_; }

    /// Return the first item in the queue
    T front() { return readQueue()->front(); }

    /** \name Syntax sugar
      */
    ///@{
    /// Append an item to the end
    void operator<<(const T& item) { pushBack(item); }
    /// Remove an item from the front
    void operator>>(T& item) { if (count() > 0) { popFront(&item); } }
    ///@}

private:
    friend class priority_queue<T>;

    PriorityQueue():
        queueByPriority_{QueueByPriority::create()},
        size_{0}
    {}

    Queue<T> *inputQueue(int priority)
    {
        ++size_;
        Queue<T> *queue = queueByPriority_->value(priority);
        if (!queue) {
            Ref< Queue<T> > newQueue = Queue<T>::create();
            queueByPriority_->insert(priority, newQueue);
            queue = newQueue;
        }
        return queue;
    }

    Ref< Queue<T> > outputQueue()
    {
        --size_;
        typename QueueByPriority::value_type pair = queueByPriority_->at(queueByPriority_->count() - 1);
        if (pair->value()->count() == 1) queueByPriority_->remove(pair->key());
        return pair->value();
    }

    Queue<T> *readQueue() const
    {
        return queueByPriority_->valueAt(queueByPriority_->count() - 1);
    }

    typedef Map<int, Ref< Queue<T> > > QueueByPriority;
    Ref<QueueByPriority> queueByPriority_;

    int size_;
};

} // namespace cc
