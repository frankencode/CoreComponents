/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/debug>
#include <cc/map>
#include <cc/queue>

namespace cc {

template<class T>
class priority_queue;

/** \class PriorityQueue cc/PriorityQueue
  * \ingroup container_dynamic
  * \brief Priority based queue data container
  * \tparam T item type
  * \see Queue, Channel
  * \todo provide iterators
  */
template<class T>
class PriorityQueue: public Object
{
public:
    typedef T Item;
    typedef int64_t Index;

    /** Create a new queue
      * \return new object instance
      */
    static Ref<PriorityQueue> create() { return new PriorityQueue; }

    /** Create a copy of another queue
      * \param other the queue to copy
      * \return new object instance
      */
    static Ref<PriorityQueue> copy(const PriorityQueue *other) { return new PriorityQueue{*other}; }

    /** Make a copy of this queue
      * \return new object instance
      */
    Ref<PriorityQueue> copy() const { return new PriorityQueue{*this}; }

    /** Add a new item to the end of the queue
      * \param item item value
      * \param priority priority of item
      */
    void pushBack(const T &item, int priority = 0)
    {
        typename QueueByPriority::iterator it;

        if (!queueByPriority_->find(priority, &it))
            queueByPriority_->insert(priority, queue<T>{}, &it);

        it->value()->pushBack(item);
        ++size_;
    }

    /** Remove an item from the head of the queue
      * \param item returns the item value
      * \return item value
      */
    const T &popFront(T *item)
    {
        CC_ASSERT(size_ > 0);
        --size_;

        auto it = queueByPriority_->last();
        it->value()->popFront(item);
        if (it->value()->count() == 0) queueByPriority_->remove(it);
        return *item;
    }

    /** Remove the first item from the queue
      * \return item value
      */
    T popFront() {
        T item;
        return popFront(&item);
    }

    /// \copydoc pushBack()
    void push(const T &item, int priority) { pushBack(item, priority); }

    /// \copydoc popFront(T *)
    const T &pop(T *item) { return popFront(item); }

    /// \copydoc popFront()
    T pop() { return popFront(); }

    /// Return the number of queued items
    Index count() const { return size_; }

    /// Return the first item in the queue
    T front() { return queueByPriority_->beginAt(queueByPriority_->count() - 1)->value()->front(); }

    /** \name Syntax sugar
      */
    ///@{
    /// Append an item to the end
    void operator<<(const T& item) { pushBack(item); }
    /// Remove an item from the front
    void operator>>(T& item) { if (count() > 0) { popFront(&item); } }
    ///@}

private:
    friend class priority_queue<T>;

    PriorityQueue() = default;

    PriorityQueue(const PriorityQueue *other)
    {
        for (const auto &item: queueByPriority_) {
            auto priority = item->key();
            for (const T &x: item->value())
                pushBack(x, priority);
        }
    }

    typedef map< int, queue<T> > QueueByPriority;

    QueueByPriority queueByPriority_;
    Index size_ { 0 };
};

} // namespace cc
