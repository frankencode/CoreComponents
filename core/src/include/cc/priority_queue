/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <initializer_list>
#include <cc/PriorityQueue>

namespace cc {

/** \class priority_queue cc/priority_queue
  * \ingroup container_highlevel
  * \brief priority based queue data container
  * \tparam T item type
  * \see queue
  */
template<class T>
class priority_queue {
public:
    typedef PriorityQueue<T> Instance;
    typedef typename Instance::value_type value_type;
    typedef typename Instance::size_type size_type;

    priority_queue():
        instance_{new Instance}
    {}

    priority_queue(std::initializer_list<T> b):
        instance_{new Instance}
    {
        for (auto &x: b) *instance_ << x;
    }

    priority_queue(Instance *b):
        instance_{b}
    {}

    const Instance *operator->() const { return instance_; }
    Instance *operator->() { return instance_; }

    operator const Instance *() const { return instance_; }
    operator Instance *() { return instance_; }

    priority_queue &operator<<(const T& x) { *instance_ << x; return *this; }
    priority_queue &operator>>(T& x) { if (instance_->count() > 0) *instance_ >> x; return *this; }

private:
    priority_queue(const priority_queue &b) = delete;
    priority_queue &operator=(const priority_queue &b) = delete;

    Ref<Instance> instance_;
};

template<class T>
typename priority_queue<T>::size_type count(const priority_queue<T> &a) { return a->count(); }

} // namespace cc
