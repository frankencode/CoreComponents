/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/EventX>
#include <cc/Set>

namespace cc {

template<class T>
class PropertyX
{
public:
    PropertyX(): instance_(Instance::create()) {}
    PropertyX(const T &b): instance_(Instance::create(b)) {}

    PropertyX(const PropertyX &b): PropertyX(b->value()) {}
    inline PropertyX &operator=(const PropertyX &b) { (*this)->setValue(b->value()); return *this; }

    PropertyX(PropertyX &&b): instance_(b.instance_) { b.instance_ = nullptr; }

    PropertyX(const std::function<T()> &f): instance_(Instance::create(f)) {}
    inline PropertyX &operator=(const std::function<T()> &f) { (*this)->bind(f); return *this; }

    class Instance: public Object {
    public:
        EventX valueChanged;

        const T &value() const
        {
            if (dirty_) {
                const_cast<Instance *>(this)->dirty_ = false;
                const_cast<Instance *>(this)->evaluate();
            }

            if ((activeInstance_) && (activeInstance_ != this)) {
                if (activeInstance_->dependencies()->insert(const_cast<Instance *>(this)))
                    subscribers()->insert(activeInstance_);
            }
            return value_;
        }

        void setValue(const T &newValue)
        {
            if (f_) {
                clearDependencies();
                f_ = std::function<T()>();
                dirty_ = false;
            }
            establish(newValue);
        }

        template<class F>
        void bind(const F &f)
        {
            if (f_) clearDependencies();
            f_ = f;
            dirty_ = true;
        }

        PropertyX alias() { return PropertyX(this, Alias()); }

    private:
        friend class PropertyX;

        typedef Set< Ref<Instance> > Association;

        inline static Ref<Instance> create(const T &b = T()) { return new Instance(b); }
        inline static Ref<Instance> create(const std::function<T()> &f) { return new Instance(f); }

        Instance(const T &b):
            value_(b),
            dirty_(false)
        {}

        Instance(const std::function<T()> &f):
            value_(T()),
            f_(f),
            dirty_(true)
        {}

        ~Instance()
        {
            clearDependencies();
            clearSubscribers();
        }

        Association *dependencies() const {
            if (!dependencies_) dependencies_ = Association::create();
            return dependencies_;
        }

        Association *subscribers() const {
            if (!subscribers_) subscribers_ = Association::create();
            return subscribers_;
        }

        void clearDependencies()
        {
            if (!dependencies_) return;

            for (Instance *other: dependencies_)
                other->subscribers_->remove(this);
            dependencies_ = nullptr;
        }

        void clearSubscribers()
        {
            if (!subscribers_) return;

            for (Instance *other: subscribers_)
                other->dependencies_->remove(this);
            subscribers_ = nullptr;
        }

        void notify()
        {
            if (subscribers_) {
                for (Instance *other: subscribers_)
                    other->evaluate();
            }
            valueChanged->notify();
        }

        void evaluate()
        {
            class Activator {
            public:
                Activator(Instance *instance): savedActiveInstance_(activeInstance_) { activeInstance_ = instance; }
                ~Activator() { activeInstance_ = savedActiveInstance_; }
            private:
                Instance *savedActiveInstance_;
            };

            Activator activator(this);
            establish(f_());
        }

        void establish(const T &newValue)
        {
            if (newValue != value_) {
                value_ = newValue;
                notify();
            }
        }

        mutable T value_;
        std::function<T()> f_;
        bool dirty_;

        mutable Ref<Association> dependencies_;
        mutable Ref<Association> subscribers_;
        thread_local static Instance *activeInstance_;
    };

    inline Instance *operator->() { return instance_; }
    inline const Instance *operator->() const { return instance_; }

    inline operator const T &() const { return (*this)->value(); }
    inline PropertyX &operator=(const T &b) { (*this)->setValue(b); return *this; }

private:
    friend class Instance;

    class Alias {};

    PropertyX(Instance *instance, Alias): instance_(instance) {}

    Ref<Instance> instance_;
};

template<class T>
thread_local typename PropertyX<T>::Instance *PropertyX<T>::Instance::activeInstance_ = nullptr;

} // namespace cc
