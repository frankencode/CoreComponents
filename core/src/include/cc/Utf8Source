/*
 * Copyright (C) 2007-2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/ByteSource>

namespace cc {

/** \class Utf8Source cc/Utf8Source
  * \ingroup unicode
  * \brief %Unicode UTF-8 decoding data source
  */
class Utf8Source: public Object
{
public:
    /** Open a new UTF-8 decoding data source
      * \param stream underlying data stream
      * \param buffer input buffer (optional)
      * \return new object instance
      */
    static Ref<Utf8Source> open(Stream *stream, CharArray *buffer = nullptr)
    {
        return new Utf8Source{stream, buffer};
    }

    /** Open a new UTF-8 decoding data source
      * \param buffer input buffer
      * \return new object instance
      */
    static Ref<Utf8Source> open(const CharArray *buffer)
    {
        return new Utf8Source{buffer};
    }

    /** Read the next %Unicode character
      * \param ch returns the %Unicode character read if any
      * \return true if not end of information, false otherwise
      * \exception UnicodeError
      */
    bool read(uchar_t *ch)
    {
        bool more = byteSource_->hasMore();
        if (more) {
            *ch = byteSource_->readUInt8();
            if ((*ch & 0x80) != 0) // distinguish 7 bit ASCII from multibyte sequence
                *ch = readMultiByte(*ch);
        }
        return more;
    }

    /// Underlying byte source used for UTF-8 decoding
    ByteSource *byteSource() const { return byteSource_; }

private:
    class DecodingError: public UnicodeError {
    public:
        String message() const override;
    };

    Utf8Source(Stream *stream, CharArray *buffer):
        byteSource_{ByteSource::open(stream, buffer)}
    {}

    Utf8Source(const CharArray *buffer):
        byteSource_{ByteSource::open(buffer)}
    {}

    char32_t readMultiByte(char32_t ch);

    Ref<ByteSource> byteSource_;
};

} // namespace cc
