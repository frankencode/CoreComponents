/*
 * Copyright (C) 2022 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Object>

namespace cc {

/** \internal
  */
class VoidPointer: public Object
{
public:
    VoidPointer(void *target = nullptr):
        Object{new State{target}}
    {}

protected:
    friend class Entity;

    struct State final: public Object::State
    {
        State(void *target): target_{target} {}

        template<class T>
        T* target() { return target_ ? static_cast<T *>(target_) : nullptr; }

        template<class T>
        const T* target() const { return target_ ? static_cast<const T *>(target_) : nullptr; }

        void *target_ { nullptr };
    };

    State &me() { return Object::me.as<State>(); }
    const State &me() const { return Object::me.as<State>(); }

    State *operator->() { return &me(); }
};

/** \class Pointer cc/Pointer
  * \ingroup objects
  * \brief Weak pointer to an Entity
  * Pointer is a weak pointer to an Entity. It is automatically set to null when the target object is destroyed.
  */
template<class T>
class Pointer: public VoidPointer
{
public:
    Pointer(T::State *target = nullptr):
        VoidPointer{target}
    {}

    explicit operator bool() const { return me().target_; }

    T *operator*() { return me().target<T::State>(); }
    const T *operator*() const { return me().target<T::State>(); }

    T *operator->() { return me().target<T::State>(); }
    const T *operator->() const { return me().target<T::State>(); }
};

} // namespace cc
