/*
 * Copyright (C) 2007-2018 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/OrdinalTree>

namespace cc {

template<class ItemType, class ExtentType>
class LayoutNode: public OrdinalNode
{
public:
    typedef ItemType Item;
    typedef ExtentType Extent;

    LayoutNode():
        treeExtent_(0),
        itemExtent_(0),
        item_(Item())
    {}

    LayoutNode(Extent extent, const Item &item):
        treeExtent_(extent),
        itemExtent_(extent),
        item_(item)
    {
        activate(this);
    }

    inline ~LayoutNode() { deactivate(this); }

    inline LayoutNode *left() const { return left_ ? static_cast<LayoutNode *>(left_) : nullptr; };
    inline LayoutNode *right() const { return right_ ? static_cast<LayoutNode *>(right_) : nullptr; }
    inline LayoutNode *parent() const { return parent_ ? static_cast<LayoutNode *>(parent_): nullptr; }

    Extent treeExtent_;
    Extent itemExtent_;
    Item item_;
};

template<class Item, class Extent>
class LayoutTree: public OrdinalTree
{
public:
    typedef LayoutNode<Item, Extent> Node;

    void *insertAt(int index, const Item &item, Extent extent);
    void updateAt(int index, const Item &item, Extent extent);
    void removeAt(int index, Item *item = 0);

    static int getIndexOf(void *handle) { return getIndexOf(reinterpret_cast<OrdinalNode *>(handle)); }

    Extent layoutSize() const;
    void updateExtentAt(int index, Extent extent);

    void getItemAt(int index, Item *item, Extent *extent = 0) const;
    void getView(Extent pos0, Extent pos1, int *index0, int *index1, Extent *itemPos0) const;
    Extent getPosAt(int index) const;

    Item &at(int index);
    const Item &at(int index) const;

private:
    inline static int treeExtent(Node *k) { return (k) ? k->treeExtent_ : 0; }
    inline static void establishTreeExtent(Node *k) { k->treeExtent_ = treeExtent(k->left()) + treeExtent(k->right()) + k->itemExtent_; }

    Node *find(Extent x, int *index = 0, Extent *x0 = 0) const;

    void changed(OrdinalNode *kp, OrdinalNode *kc, bool left, bool attached) override;
    void rotated(OrdinalNode *k1, bool left) override;
};

template<class Item, class Extent>
void *LayoutTree<Item, Extent>::insertAt(int index, const Item &item, Extent extent)
{
    Node *kn = new Node(extent, item);
    attachAt(index, kn);
    return kn;
}

template<class Item, class Extent>
void LayoutTree<Item, Extent>::updateAt(int index, const Item &item, Extent extent)
{
    Node *k = static_cast<Node *>(getNodeAt(index));
    Extent delta = extent - k->itemExtent_;
    k->item_ = item;
    k->itemExtent_ = extent;
    k->treeExtent_ += delta;
    for (; k; k = k->parent())
        k->treeExtent_ += delta;
}

template<class Item, class Extent>
void LayoutTree<Item, Extent>::removeAt(int index, Item *item)
{
    Node *ko = static_cast<Node *>(unlinkAt(index));
    if (item) *item = ko->item_;
    delete ko;
}

template<class Item, class Extent>
Extent LayoutTree<Item, Extent>::layoutSize() const
{
    if (!root_) return 0;
    return treeExtent(static_cast<Node *>(root_));
}

template<class Item, class Extent>
void LayoutTree<Item, Extent>::updateExtentAt(int index, Extent extent)
{
    Node *k = static_cast<Node *>(getNodeAt(index));
    Extent delta = extent - k->itemExtent_;
    k->itemExtent_ = extent;
    k->treeExtent_ += delta;
    for (; k; k = k->parent())
        k->treeExtent_ += delta;
}

template<class Item, class Extent>
void LayoutTree<Item, Extent>::getItemAt(int index, Item *item, Extent *extent) const
{
    Node *k = static_cast<Node *>(getNodeAt(index));
    if (item) *item = k->item_;
    if (extent) *extent = k->itemExtent_;
}

template<class Item, class Extent>
void LayoutTree<Item, Extent>::getView(Extent pos0, Extent pos1, int *index0, int *index1, Extent *itemPos0) const
{
    if (
        !root_ ||
        pos1 <= pos0 ||
        pos1 <= 0 ||
        layoutSize() <= pos0
    ) {
        if (index0) *index0 = 0;
        if (index1) *index1 = 0;
        return;
    }

    if (index0) find(pos0, index0, itemPos0);

    if (index1) {
        Extent item1Pos0 = 0;
        find(pos1, index1, &item1Pos0);
        *index1 += (item1Pos0 < pos1);
    }
}

template<class Item, class Extent>
Extent LayoutTree<Item, Extent>::getPosAt(int index) const
{
    OrdinalNode *k = root_;
    Extent y = 0;
    Extent y0 = 0;
    int j0 = 0;
    while (k) {
        y = y0 + treeExtent(static_cast<Node *>(k->left_));
        int j = j0 + weight(k->left_);
        if (index < j) {
            k = k->left_;
        }
        else if (j < index) {
            y0 = y + static_cast<Node *>(k)->itemExtent_;
            j0 = j + 1;
            k = k->right_;
        }
        else // i == j
            break;
    }
    return y;
}

template<class Item, class Extent>
Item &LayoutTree<Item, Extent>::at(int index)
{
    return static_cast<Node *>(getNodeAt(index))->item_;
}

template<class Item, class Extent>
const Item &LayoutTree<Item, Extent>::at(int index) const
{
    return static_cast<Node *>(getNodeAt(index))->item_;
}

template<class Item, class Extent>
typename LayoutTree<Item, Extent>::Node *LayoutTree<Item, Extent>::find(Extent x, int *index, Extent *x0) const
{
    if (!root_) return nullptr;
    Node *k = static_cast<Node *>(root_);
    Extent z0 = 0;
    Extent z1 = 0;
    Extent y0 = 0;
    int j0 = 0;
    int j = 0;
    while (true) {
        z0 = y0 + (k->left_ ? static_cast<Node *>(k->left_)->treeExtent_ : Extent{});
        z1 = z0 + k->itemExtent_;
        j = j0 + weight(k->left_);
        if (x < z0) {
            if (!k->left_) break;
            k = static_cast<Node *>(k->left_);
        }
        else if (z1 <= x) {
            if (!k->right_) break;
            y0 = z1;
            j0 = j + 1;
            k = static_cast<Node *>(k->right_);
        }
        else break;
    }
    if (index) *index = j;
    if (x0) *x0 = z0;
    return k;
}

template<class Item, class Extent>
void LayoutTree<Item, Extent>::changed(OrdinalNode *kp, OrdinalNode *kc, bool left, bool attached)
{
    Extent delta = static_cast<Node *>(kc)->itemExtent_;
    if (!attached) delta = -delta;

    for (OrdinalNode *k = kp; k; k = k->parent_)
        static_cast<Node *>(k)->treeExtent_ += delta;

    OrdinalTree::changed(kp, kc, left, attached);
}

template<class Item, class Extent>
void LayoutTree<Item, Extent>::rotated(OrdinalNode *k1, bool left)
{
    establishTreeExtent(static_cast<Node *>(k1));
    establishTreeExtent(static_cast<Node *>(k1->parent_));

    OrdinalTree::rotated(k1, left);
}

} // namespace cc
