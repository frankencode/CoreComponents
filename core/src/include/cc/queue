/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <initializer_list>
#include <cc/Queue>

namespace cc {

/** \class queue cc/queue
  * \ingroup container_highlevel
  * \brief %Queue data container
  * \tparam T item type
  * \see priority_queue
  */
template<class T>
class queue {
public:
    typedef Queue<T> Instance;
    typedef typename Instance::value_type value_type;
    typedef typename Instance::size_type size_type;

    queue():
        instance_{new Instance}
    {}

    queue(std::initializer_list<T> b):
        instance_{new Instance}
    {
        for (auto &x: b) *instance_ << x;
    }

    queue(Instance *b):
        instance_{b}
    {}

    const Instance *operator->() const { return instance_; }
    Instance *operator->() { return instance_; }

    operator const Instance *() const { return instance_; }
    operator Instance *() { return instance_; }

    queue &operator<<(const T& x) { *instance_ << x; return *this; }
    queue &operator>>(T& x) { if (instance_->count() > 0) *instance_ >> x; return *this; }

private:
    queue(const queue &b) = delete;
    queue &operator=(const queue &b) = delete;

    Ref<Instance> instance_;
};

template<class T>
typename queue<T>::size_type count(const queue<T> &a) { return a->count(); }

} // namespace cc
