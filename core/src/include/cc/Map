/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/bucket>
#include <cc/containers>
#include <cc/Pair>

namespace cc {

/** \class Map cc/Map
  * \ingroup container
  * \brief %Map data container
  * \see Set, List
  */
template<class K, class V = K>
class Map: public Object
{
public:
    // Key type
    typedef K Key;

    // Value type
    typedef V Value;

    /// Item type
    typedef Pair<Key, Value> Item;

    /// Index type
    typedef bucket::Weight Index;

    /** Create a new map
      * \return new object instance
      */
    static Ref<Map> create() { return new Map; }

    /// Number of items
    Index count() const { return tree_->count(); }

    /// Check if an index is valid
    bool has(Index index) const {
        return 0 <= index && index < count();
    }

    /** Return a reference to an item
      * \param index set index
      * \return reference to the item
      */
    const Item &at(Index index) const
    {
        assert(0 <= index && index < count());
        return tree_->at<Item>(index);
    }

    /// Check if the map contains \a key
    bool contains(const Key &key) const
    {
        return tree_->lookup<Item>(Item{key});
    }

    /** Insert a new key-value pair if the map doesn't contain the key already
      * \param key search key
      * \param value new value
      * \param currentValue returns the current value if the map contains the given key already
      * \param currentIndex returns the index of the key if the map contains the given key already
      * \return true if the new key-value pair was inserted successfully
      */
    bool insert(const Key &key, const Value &value, Value *currentValue = nullptr, Index *currentIndex = nullptr)
    {
        bucket::Leaf<Item> *target = nullptr;
        unsigned egress = 0;
        Item item{key, value};
        bool found = tree_->lookup<Item>(item, currentIndex, &target, &egress);
        if (!found) tree_->push<Item>(target, egress, item);
        else if (currentValue) *currentValue = target->at(egress)->value();
        return !found;
    }

    /** Remove the given \a key from the map
      * \return true if a matching key was found and removed
      */
    bool remove(const Key &key)
    {
        bucket::Leaf<Item> *target = nullptr;
        unsigned egress = 0;
        bool found = tree_->lookup<Item>(Item{key}, nullptr, &target, &egress);
        if (found) tree_->pop<Item>(target, egress);
        return found;
    }

    /** Insert a new or overwrite a existing key-value mapping
      * \param key search key
      * \param value new value
      */
    void establish(const Key &key, const Value &value)
    {
        bucket::Leaf<Item> *target = nullptr;
        unsigned egress = 0;
        Item item{key, value};
        bool found = tree_->lookup<Item>(item, nullptr, &target, &egress);
        if (found) target->at(egress) = item;
        else tree_->push<Item>(target, egress, item);
    }

    /** Retrieve value of associated with a given \a key
      * \param key search key
      * \param fallback fallback value
      * \return retieved value if key was found, fallback value otherwise
      */
    Value value(const Key &key, const Value &fallback = Value{}) const
    {
        bucket::Leaf<Item> *target = nullptr;
        unsigned egress = 0;
        bool found = tree_->lookup(Item{key}, nullptr, &target, &egress);
        return found ? target->at(egress)->value() : fallback;
    }

    /** Modify value of an existing key-value mapping
      * \param key search key
      * \param value new value
      * \return true if key is was found, false otherwise
      */
    bool setValue(const Key &key, const Value &value)
    {
        bucket::Leaf<Pair<Key, Value>> *target = nullptr;
        unsigned egress = 0;
        Item item{key, value};
        bool found = tree_->lookup(item, nullptr, &target, &egress);
        if (found) target->at(egress) = item;
        return found;
    }

    /** Lookup key-value pair by given key.
      * If a matching key-value pair is found the value is returned in 'value' and the
      * function returns with true. If a matching key-value pair could not be found
      * 'value' is not set and the function returns false.
      */
    template<class ReturnValue>
    bool lookup(const Key &key, ReturnValue *value = nullptr, Index *index = nullptr) const
    {
        bucket::Leaf<Item> *target = nullptr;
        unsigned egress = 0;
        bool found = tree_->lookup(Item{key}, index, &target, &egress);
        if (found) *value = target->at(egress)->value();
        return found;
    }

    /// Remove item at given \a index
    void removeAt(Index index)
    {
        assert(0 <= index && index < count());
        tree_->pop<Item>(index);
    }

    /// Modify value of the key-value mapping at given \a index
    void setValueAt(Index index, const Value &value)
    {
        assert(0 <= index && index < count());
        tree_->at<Item>(index)->setValue(value);
    }

    /** \name Iterators
      * @{
      */
    typedef bucket::ConstIterator<Item> Iterator;
    typedef bucket::ConstIterator<Item> ConstIterator;

    Iterator begin() { return ConstIterator{tree_}; }
    Iterator end() { return ConstIterator{tree_, tree_->count()}; }
    ConstIterator begin() const { return ConstIterator{tree_}; }
    ConstIterator end() const { return ConstIterator{tree_, tree_->count()}; }

    ConstIterator first(const Key &key) const
    {
        Index index = 0;
        bucket::Leaf<Item> *node = nullptr;
        unsigned egress = 0;
        tree_->lookupFirst(Item{key}, &index, &node, &egress);
        return ConstIterator(tree_, index, node, egress);
    }

    ConstIterator last(const Key &key) const
    {
        Index index = 0;
        bucket::Leaf<Item> *node = nullptr;
        unsigned egress = 0;
        tree_->lookupLast(Item{key}, &index, &node, &egress);
        return ConstIterator(tree_, index, node, egress);
    }
    /** @}
      */

    /** \internal
      * @{
      */
    typedef Iterator iterator;
    typedef ConstIterator const_iterator;
    /** @}
      */

    /// Return the smallest item
    const Item &first() const { return tree_->first<Item>(); }

    /// Return the biggest item
    const Item &last() const { return tree_->last<Item>(); }

    /// Reset to an empty map
    void deplete() { tree_->deplete<Item>(); }

protected:
    friend class bucket::Internals;
    friend class Local<Map>;

    Map() = default;

    Map(const Map *other)
    {
        tree_->populate<Item>(other);
    }

    ~Map() { tree_->deplete<Item>(); }

private:
    Local<bucket::Tree> tree_;
};

template<class K, class V>
bool operator==(const Map<K, V> &a, const Map<K, V> &b) { return container::compare(a, b) == 0; }

template<class K, class V>
bool operator!=(const Map<K, V> &a, const Map<K, V> &b) { return container::compare(a, b) != 0; }

template<class K, class V>
bool operator<(const Map<K, V> &a, const Map<K, V> &b) { return container::compare(a, b) < 0; }

template<class K, class V>
bool operator>(const Map<K, V> &a, const Map<K, V> &b) { return container::compare(a, b) > 0; }

template<class K, class V>
bool operator<=(const Map<K, V> &a, const Map<K, V> &b) { return container::compare(a, b) <= 0; }

template<class K, class V>
bool operator>=(const Map<K, V> &a, const Map<K, V> &b) { return container::compare(a, b) >= 0; }

} // namespace cc
