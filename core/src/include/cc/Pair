/*
 * Copyright (C) 2007-2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/bucket>

namespace cc {

/** \class Pair cc/Pair
  * \brief Key value pair
  */
template<class K, class V = K>
class Pair
{
public:
    typedef K Key;
    typedef V Value;

    Pair()
    {}

    Pair(const Key &key):
        instance_{key}
    {}

    Pair(const Key &key, const Value &value):
        instance_{key, value}
    {}

    bool operator< (const Pair &b) const { return instance_.key_ <  b.instance_.key_; }
    bool operator> (const Pair &b) const { return instance_.key_ >  b.instance_.key_; }
    bool operator==(const Pair &b) const { return instance_.key_ ==  b.instance_.key_; }
    bool operator!=(const Pair &b) const { return instance_.key_ !=  b.instance_.key_; }
    bool operator<=(const Pair &b) const { return instance_.key_ <=  b.instance_.key_; }
    bool operator>=(const Pair &b) const { return instance_.key_ >=  b.instance_.key_; }

    class Instance {
    public:
        Key key() const { return key_; }
        Value value() const { return value_; }
        Value &value() { return value_; }
        void setValue(const Value &newValue) { value_ = newValue; }

    private:
        friend class Pair;
        Instance()
        {}
        Instance(const Key &key):
            key_{key}, value_{Value{}}
        {}
        Instance(const Key &key, const Value &value):
            key_{key}, value_{value}
        {}
        Key key_;
        Value value_;
    };

    Instance *operator->() { return &instance_; }
    const Instance *operator->() const { return &instance_; }

private:
    Instance instance_;
};

template<class K, class V>
class IteratorAccess< const Pair<K, V> > {
public:
    typedef K Key;
    typedef V Value;
    typedef Pair<K, V> Item;

    typedef const Item &DerefAccess;
    typedef IteratorAccess MemberAccess;

    IteratorAccess(const Item &item): item_{&item} {}

    Key key() const { return (*item_)->key(); }
    Value value() const { return (*item_)->value(); }

    const IteratorAccess *operator->() const { return this; }

private:
    const Item *item_;
};

template<class K, class V>
class IteratorAccess< Pair<K, V> > {
public:
    typedef K Key;
    typedef V Value;
    typedef Pair<K, V> Item;

    typedef const Item &DerefAccess;
    typedef IteratorAccess MemberAccess;

    IteratorAccess(Item &item): item_{&item} {}

    Key key() const { return (*item_)->key(); }
    Value &value() const { return (*item_)->value(); }
    void setValue(const Value &newValue) const { (*item_)->setValue(newValue); }

    const IteratorAccess *operator->() const { return this; }

private:
    Item *item_;
};

} // namespace cc
