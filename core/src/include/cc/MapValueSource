/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Source>

namespace cc
{

/** \class MapValueSource cc/MapValueSource
  * \ingroup container
  * \brief %Source adapter for the values stored in a %Map
  * \see Source, Map
  */
template<class Map, class Item = typename Map::Value>
class MapValueSource: public Source<Item>
{
public:
    static Ref<MapValueSource> open(const Map *map)
    {
        return new MapValueSource{map};
    }

    bool read(Item *item) override
    {
        if (!iterator_) return false;
        *item = iterator_->value();
        ++iterator_;
        return true;
    }

protected:
    MapValueSource(const Map *map): iterator_{map->begin()} {}
    typename Map::ConstIterator iterator_;
};

} // namespace cc
