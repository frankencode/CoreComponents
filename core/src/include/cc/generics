/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Object>
#include <cc/Ref>

namespace cc {

/** \internal
  * \brief Reference manually allocated objects
  *
  * Wrapper class to allow taking reference to classes not inherited
  * from cc::Object. Beware that it is impossible to reference
  * the same alien object by two different alien wrappers.
  */
template<class T>
class Alien: public Object
{
public:
    typedef void (*DelFunc)(T *);

    Alien(T *guest, DelFunc delFunc = 0):
        guest_(guest),
        delFunc_(delFunc)
    {}

    ~Alien()
    {
        if (guest_ != 0)
        {
            if (delFunc_) delFunc_(guest_);
            else delete guest_;
            guest_ = 0;
        }
    }

    inline T *get() const { return guest_; }

private:
    mutable T *guest_;
    DelFunc delFunc_;
};

#ifdef major
#undef major
#endif
#ifdef minor
#undef minor
#endif

/** \brief Integer range
  */
class Range: public Object
{
public:
    inline static Ref<Range> create(int i0 = 0, int i1 = -1) { return new Range(i0, i1); }

    inline int i0() const { return i0_; }
    inline int i1() const { return i1_; }

    inline void assign(int i0, int i1) {
        i0_ = i0;
        i1_ = i1;
    }

    inline bool valid() const { return i0_ <= i1_; }

protected:
    Range(int i0 = 0, int i1 = -1): i0_(i0), i1_(i1) {}

    int i0_, i1_;
};

} // namespace cc
