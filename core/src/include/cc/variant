/*
 * Copyright (C) 2007-2018 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <new>
#include <cc/bitmask>
#include <cc/Color>
#include <cc/Version>
#include <cc/string>
#include <cc/Map>

namespace cc {

class variant;

typedef List<variant> VariantList;
typedef Map<string, variant> VariantMap;

/** \internal
  * \brief variant cast policy
  * \see variant::cast()
  */
template<class T, bool IsPointer>
class VariantCast {};

/** Type of a variant value
  * \see variant::type(), variant::itemType()
  */
enum class VariantType: uint16_t
{
    Undefined = 0,
    Int       = 1,
    Bool      = 2 | Int,
    Float     = 4,
    Color     = 8,
    Version   = 16,
    Object    = 32,
    String    = 64 | Object,
    List      = 128 | Object,
    Map       = 256 | Object,
    Any       = 511
};

CC_BITMASK(VariantType, uint16_t)

/** \class variant cc/variant
  * \ingroup misc
  * \brief Duck-typed value
  *
  * A variant can represent different types.
  * The type of a variant is defined implicitly at construction or assignment.
  * Variants automatically cast to bool, int, float if the variant type is compatible
  * with the target type requested by an expression.
  * In debug mode a DebugException will be thrown on illegal type casts.
  * Variants can be savely passed by value.
  */
class variant
{
public:
    /// Integer type used for storing integer values inside a variant
    typedef float Int;

    /// Floating point number type used for storing real values inside a variant
    typedef float Float;

    static const char *typeName(VariantType type, VariantType itemType);

    /** Heuristically detect the type and read a variant value from a string
      * \param s text representation of the variant value
      * \return variant value
      */
    static variant read(const string &s);

    template<class T>
    inline static T cast(const variant &value) { return VariantCast<T, CC_IS_POINTER(T)>::cast(value); }

    class Instance
    {
    public:
        VariantType type() const { return type_; }
        VariantType itemType() const { return itemType_; }
        const char *typeName() const;

        string toString() const;

        /** TODO: allow to request more smart conversions explicitly and have proper range checking and exception handling at this point
          */

    private:
        friend class variant;

        template<class, bool>
        friend class VariantCast;

        friend string str(const variant &x);
        friend int type(const variant &value);
        friend int itemType(const variant &value);

        template<class U>
        friend U *cast(const variant &value);

        Instance() {}

        Instance(int value)    : type_{VariantType::Int},     int_{value}            {}
        Instance(bool value)   : type_{VariantType::Bool},    int_{value}            {}
        Instance(float value)  : type_{VariantType::Float},   float_{value}          {}
        Instance(double value) : type_{VariantType::Float},   float_{float(value)}   {}
        Instance(Color value)  : type_{VariantType::Color},   word_{value->toWord()} {}
        Instance(Version value): type_{VariantType::Version}, word_{value->toWord()} {}

        Instance(const char *value)  : type_{VariantType::String} { initRef(mutate(string(value))); }
        Instance(const string &value): type_{VariantType::String} { initRef(mutate(value)); }

        template<class T>
        Instance(const Ref<T> &value): type_{VariantType::Object} { initRef(value.get()); }

        Instance(const Ref< List<int> > &value)    : type_{VariantType::List}, itemType_{VariantType::Int}     { initRef(value); }
        Instance(const Ref< List<bool> > &value)   : type_{VariantType::List}, itemType_{VariantType::Bool}    { initRef(value); }
        Instance(const Ref< List<float> > &value)  : type_{VariantType::List}, itemType_{VariantType::Float}   { initRef(value); }
        Instance(const Ref< List<Color> > &value)  : type_{VariantType::List}, itemType_{VariantType::Color}   { initRef(value); }
        Instance(const Ref< List<Version> > &value): type_{VariantType::List}, itemType_{VariantType::Version} { initRef(value); }
        Instance(const Ref<StringList> &value)     : type_{VariantType::List}, itemType_{VariantType::String}  { initRef(value); }
        Instance(const Ref<VariantList> &value)    : type_{VariantType::List}, itemType_{VariantType::Any}     { initRef(value); }
        Instance(const Ref<VariantMap> &value)     : type_{VariantType::List}, itemType_{VariantType::Any}     { initRef(value); }

        void initRef(Object *object = nullptr) {
            new(dummy_)Ref<Object>(object);
        }

        void killRef() {
            ref().~Ref<Object>();
        }

        void setRef(Object *object) const {
            ref() = object;
        }

        Ref<Object> &ref() const {
            return *union_cast< Ref<Object> *>(dummy_);
        }

        VariantType type_ { VariantType::Undefined };
        VariantType itemType_ { VariantType::Undefined };
        union {
            int32_t int_;
            uint32_t word_;
            float32_t float_;
            mutable char dummy_[sizeof(Ref<Object>)];
        };
    };

    variant() {}

    variant(int value)    : instance_{value} {}
    variant(bool value)   : instance_{value} {}
    variant(float value)  : instance_{value} {}
    variant(double value) : instance_{value} {}
    variant(Color value)  : instance_{value} {}
    variant(Version value): instance_{value} {}

    variant(const char *value)  : instance_{value} {}
    variant(const string &value): instance_{value} {}

    template<class T>
    variant(const Ref<T> &value): instance_{value} {}

    template<class T>
    variant(const T *value): variant(Ref<T>(value)) {}

    template<class T>
    variant(T *value): variant(Ref<T>(value)) {}

    variant(const Ref< List<int> > &value)    : instance_{value} {}
    variant(const Ref< List<bool> > &value)   : instance_{value} {}
    variant(const Ref< List<float> > &value)  : instance_{value} {}
    variant(const Ref< List<Color> > &value)  : instance_{value} {}
    variant(const Ref< List<Version> > &value): instance_{value} {}
    variant(const Ref<StringList> &value)     : instance_{value} {}
    variant(const Ref<VariantList> &value)    : instance_{value} {}
    variant(const Ref<VariantMap> &value)     : instance_{value} {}

    template<class T>
    variant(const List<T> *value): variant(Ref<List<T>>(value)) {}

    template<class T>
    variant(List<T> *value): variant(Ref<List<T>>(value)) {}

    variant(const variant &b) { *this = b; }

    ~variant() { if (+((*this)->type_ & VariantType::Object))(*this)->killRef(); }

    const variant &operator=(bool value)          { (*this)->type_ = VariantType::Bool;    (*this)->int_ = value; return *this; }
    const variant &operator=(int value)           { (*this)->type_ = VariantType::Int;     (*this)->int_ = value; return *this; }
    const variant &operator=(float value)         { (*this)->type_ = VariantType::Float;   (*this)->float_ = value; return *this; }
    const variant &operator=(double value)        { (*this)->type_ = VariantType::Float;   (*this)->float_ = value; return *this; }
    const variant &operator=(Color value)         { (*this)->type_ = VariantType::Color;   (*this)->word_ = value->toWord(); return *this; }
    const variant &operator=(Version value)       { (*this)->type_ = VariantType::Version; (*this)->word_ = value->toWord(); return *this; }

    const variant &operator=(const char *value)   { return (*this) = variant(value); }
    const variant &operator=(const string &value) { return (*this) = variant(value); }

    template<class T>
    const variant &operator=(const Ref<T> &value) { return (*this) = variant(value); }

    const variant &operator=(const variant &b)
    {
        if (+((*this)->type_ & VariantType::Object)) (*this)->killRef();
        (*this)->type_ = b->type_;
        (*this)->itemType_ = b->itemType_;
        if (+(b->type_ & VariantType::Object))
            (*this)->initRef(b->ref().get());
        else if (+b->type_)
            (*this)->int_ = b->int_;
        return *this;
    }

    operator bool() const {
        if (!+(*this)->type_) return bool();
        CC_ASSERT2(+((*this)->type_ & VariantType::Int), illegalConversion);
        return (*this)->int_;
    }
    operator int() const {
        if (!+(*this)->type_) return int();
        CC_ASSERT2(+((*this)->type_ & VariantType::Int), illegalConversion);
        return (*this)->int_;
    }
    operator float() const {
        if (!+(*this)->type_) return float();
        if (+((*this)->type_ & VariantType::Int)) return (*this)->int_;
        CC_ASSERT2(+((*this)->type_ & VariantType::Float), illegalConversion);
        return (*this)->float_;
    }
    operator Color() const {
        if (!+(*this)->type_) return Color();
        CC_ASSERT2(+((*this)->type_ & VariantType::Color), illegalConversion);
        return Color::fromWord((*this)->word_);
    }
    operator Version() const {
        if (!+(*this)->type_) return Version();
        CC_ASSERT2(+((*this)->type_ & VariantType::Version), illegalConversion);
        return Version::fromWord((*this)->word_);
    }
    operator string() const {
        if (!+(*this)->type_) return string{};
        CC_ASSERT2(+((*this)->type_ & VariantType::String), illegalConversion);
        return variant::cast<CharArray *>(*this);
    }

    template<class T>
    operator Ref<T>() const {
        if (!+(*this)->type_) return Ref<T>();
        CC_ASSERT2(+((*this)->type_ & VariantType::Object), illegalConversion);
        return variant::cast<T *>(*this);
    }

    const Instance *operator->() const { return &instance_; }
    Instance *operator->() { return &instance_; }

    bool operator==(const variant &b) const;
    bool operator<(const variant &b) const;

    bool operator>(const variant &b) const  { return b < *this; }
    bool operator!=(const variant &b) const { return !(*this == b); }
    bool operator<=(const variant &b) const { return (*this < b) || (*this == b); }
    bool operator>=(const variant &b) const { return (b < *this) || (*this == b); }

private:
    static constexpr const char *illegalConversion = "Illegal variant conversion";

    Instance instance_;
};

template<class T>
class VariantCast<T, true> {
public:
    static T cast(const variant &value) {
        typedef typename CC_DEREF(T) U;
        return (+(value->type() & VariantType::Object)) ? Object::cast<U *>(value->ref().get()) : nullptr;
    }
};

template<class T>
class VariantCast<T, false> {
public:
    static T cast(const variant &value) {
        return T(value);
    }
};

template<>
class VariantCast<string, false> {
public:
    static string cast(const variant &value) {
        return variant::cast<CharArray *>(value);
    }
};

template<>
class VariantCast<Color, false> {
public:
    static Color cast(const variant &value) {
        return Color::fromWord(value->word_);
    }
};

template<>
class VariantCast<Version, false> {
public:
    static Version cast(const variant &value) {
        return Version::fromWord(value->word_);
    }
};

inline string str(const variant &x) { return x->toString(); }

} // namespace cc
