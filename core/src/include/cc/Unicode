/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/containers>
#include <cc/String>
#include <cc/Utf8Walker>

namespace cc {

class Unicode;

template<>
class ConstArrayIterator<Unicode> {
public:
    ConstArrayIterator(const Unicode *c, int i);

    inline uchar_t operator*() const;
    inline ConstArrayIterator &operator++();
    inline bool operator!=(const ConstArrayIterator &b) const;

private:
    const Unicode *c_;
    int i_;
};

/** \class Unicode cc/Unicode
  * \ingroup unicode
  * \brief Seemlessly access the %Unicode characters of an UTF-8 encoded byte array
  * \see String
  */
class Unicode: public Object
{
public:
    /// Item type for iteration
    typedef uchar_t Item;

    /** Create a new %Unicode farcade for a given byte array
      * \param data UTF-8 encoded byte array
      * \return new object instance
      */
    static Ref<Unicode> open(const CharArray *data)
    {
        return new Unicode{data};
    }

    /// Check if a given %Unicode character index i is valid
    bool has(int i) const {
        walkTo(i);
        return walker_.valid();
    }

    /// Decode the i-th %Unicode character from the underlying byte array.
    uchar_t at(int i) const {
        walkTo(i);
        return walker_.getChar();
    }

    /// Return the number of %Unicode characters
    static int count(const CharArray *data) {
        return Utf8Walker::countCodePoints(data->chars());
    }

    /// Return the number of %Unicode characters
    int count() const {
        if (n_ != -1) return n_;
        return n_ = Utf8Walker::countCodePoints(data_->chars());
    }

    /// Current byte offset in the underlying byte array
    int offset() const {
        return walker_.pos() - walker_.data();
    }

    /** Copy a range of %Unicode characters
      * \param i0 first %Unicode character index
      * \param i1 behind last %Unicode character index
      * \return UTF-8 encoded characters
      */
    String copy(int i0, int i1) const;

    /// Copy the first n %Unicode characters
    String head(int n) const { return copy(0, n); }

    /// Copy the trailing n %Unicode characters
    String tail(int n) const { return copy(count() - n, n); }

    /** \name Iterators
      * @{
      */
    typedef ConstArrayIterator<Unicode> ConstIterator;
    typedef ConstIterator Iterator;

    ConstIterator begin() const { return ConstIterator{this, 0}; }
    ConstIterator end() const { return ConstIterator{this, count()}; }

    Iterator begin() { return Iterator{this, 0}; }
    Iterator end() { return Iterator{this, count()}; }
    /** @} */

    /** \internal
      * @{
      */
    typedef Iterator iterator;
    typedef ConstIterator const_iterator;
    /** @}
      */

private:
    Unicode(const CharArray *data):
        data_{data},
        walker_{data->chars()},
        i_{0}, n_{-1}
    {}

    void walkTo(int i) const {
        if (!walker_.valid()) {
            walker_ = Utf8Walker(walker_.data());
            i_ = 0;
        }
        while (i_ < i) { ++walker_; ++i_; }
        while (i_ > i) { --walker_; --i_; }
    }

    Ref<const CharArray> data_;
    mutable Utf8Walker walker_;
    mutable int i_, n_;
};

inline ConstArrayIterator<Unicode>::ConstArrayIterator(const Unicode *c, int i):
    c_{c},
    i_{i}
{}

inline uchar_t ConstArrayIterator<Unicode>::operator*() const { return c_->at(i_); }
inline ConstArrayIterator<Unicode> &ConstArrayIterator<Unicode>::operator++() { ++i_; return *this; }
inline bool ConstArrayIterator<Unicode>::operator!=(const ConstArrayIterator<Unicode> &b) const { return i_ != b.i_; }

} // namespace cc
