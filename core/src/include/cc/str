/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

/** \file str
  * \brief Output formatting helper functions
  */

#include <cc/string>
#include <cc/Variant>
#include <cc/Local>

namespace cc {

template<class T>
struct Sign { inline static int get(T x) { return x < 0; } };

template<>
struct Sign<unsigned char> { inline static int get(unsigned char) { return 0; } };

template<>
struct Sign<unsigned short> { inline static int get(unsigned short) { return 0; } };

template<>
struct Sign<unsigned int> { inline static int get(unsigned int) { return 0; } };

template<>
struct Sign<unsigned long> { inline static int get(unsigned long) { return 0; } };

template<>
struct Sign<unsigned long long> { inline static int get(unsigned long long) { return 0; } };

/** \addtogroup formatted_io
  * \{
  */

/** Convert an integer value to string
  * \tparam T integer type
  * \param x integer value
  * \param base number base (2..62)
  * \param n maximum number of digits
  * \return string representation of x
  */
template<class T>
string inum(T x, int base = 10, int n = -1)
{
    int sign = Sign<T>::get(x);
    if (sign) x = -x;
    int m = (x == 0);
    for (T y = x; y > 0; y /= base) ++m;
    if (sign) ++m;
    if (n > 0 && m < n) m = n;
    string s{m, '0'};
    if (sign) mutate(s)->at(0) = '-';
    for (int i = s->count() - 1; x > 0 && s->has(i); x /= base, --i) {
        const char *fig =
            "0123456789"
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "abcdefghijklmnopqrstuvwxyz";
        mutate(s)->at(i) = fig[x % base];
    }
    return s;
}

/** Convert a floating point number to string
  * \param x floating point value
  * \param precision number of significiant digits
  * \param base number base (2..62)
  * \param screen maximum absolute exponent for choosing a non-exponential notation
  * \return string representation of x
  */
string fnum(float64_t x, int precision = 16, int base = 10, int screen = 6);

/** Convert a floating point number to a string
  * \param x floating point value
  * \param nf number of fractional digits
  * \return string representation of x
  */
string fixed(float64_t x, int nf);

/** Convert a floating point number to a string
  * \param x floating point value
  * \param ni number of integral digits
  * \param nf number of fractional digits
  * \return string representation of x
  */
string fixed(float64_t x, int ni, int nf);

/** Convert an integer to a decimal string
  * \param x integer value
  * \param n number of digits
  * \return string representation of x
  */
template<class T>
inline string dec(T x, int n = -1) { return inum(x, 10, n); }

/** Convert an integer to a hexadecimal string
  * \param x integer value
  * \param n number of digits
  * \return string representation of x
  */
template<class T>
inline string hex(T x, int n = -1) { return inum(x, 16, n); }

/** Convert an integer to an octal string
  * \param x integer value
  * \param n number of digits
  * \return string representation of x
  */
template<class T>
inline string oct(T x, int n = -1) { return inum(x, 8, n); }

/** Convert an integer to a binary string
  * \param x integer value
  * \param n number of digits
  * \return string representation of x
  */
template<class T>
inline string bin(T x, int n = -1) { return inum(x, 2, n); }

/** Convert a floating point number to a exponental notation string
  * \param x integer value
  * \param precision number of significiant digits
  * \return string representation of x
  */
inline string sci(float32_t x, int precision = 8) { return fnum(x, precision, 10, 0); }

/** \copydoc sci(float32_t, int)
  */
inline string sci(float64_t x, int precision = 17) { return fnum(x, precision, 10, 0); }

/** Convert a floating point number to decimal string
  * \param x floating point number
  * \param precision number of significiant digits
  * \return string representation of x
  */
inline string dec(float32_t x, int precision = 8) { return fnum(x, precision, 10, 6); }

/** \copydoc dec(float32_t, int)
  */
inline string dec(float64_t x, int precision = 17) { return fnum(x, precision, 10, 6); }

/** Convert a variant to a decimal string
  * \param x variant value
  * \param n maximum number of digits
  * \return string representation of x
  */
string dec(const Variant &x, int n = -1);

/// Convenience wrapper
inline string str(const string &s) { return s; }

/// Convenience wrapper
inline string str(const Ref<StringList> &x) { return x->join(); }

/// Convenience wrapper
inline string str(CharArray *s) { return string(s); }

/// Convenience wrapper
inline string str(const CharArray *s) { return string(s); }

/// Convert a C-string to a string
inline string str(const char *s) { return string(s); }

/// Convert a C-string to a string
inline string str(char *s) { return string(s); }

/// Convert a character to a string
inline string str(char ch) { return string{&ch, 1}; }

/// Convert an unicode character to a string
string str(uchar_t ch);

/// Convert a boolean to a string
inline string str(bool x) { return x ? "true" : "false"; }

/// Convert a pointer to a string
string str(void *x);

/// Convert an object to string
template<class T>
inline string str(const Ref<T> &x) { return x->toString(); }

/// Convert an object to string
template<class T>
inline string str(const T *x) { return x ? x->toString() : string{"null"}; }

/// Convert an object to string
template<class T>
inline string str(const Local<T> &x) { return x->toString(); }

/// Convenience wrapper to dec()
inline string str(unsigned char x) { return dec(x); }

/// Convenience wrapper to dec()
inline string str(unsigned short x) { return dec(x); }

/// Convenience wrapper to dec()
inline string str(unsigned int x) { return dec(x); }

/// Convenience wrapper to dec()
inline string str(unsigned long x) { return dec(x); }

/// Convenience wrapper to dec()
inline string str(unsigned long long x) { return dec(x); }

/// Convenience wrapper to dec()
inline string str(short x) { return dec(x); }

/// Convenience wrapper to dec()
inline string str(int x) { return dec(x); }

/// Convenience wrapper to dec()
inline string str(long x) { return dec(x); }

/// Convenience wrapper to dec()
inline string str(long long x) { return dec(x); }

/// Convenience wrapper to dec()
inline string str(float x) { return dec(x); }

/// Convenience wrapper to dec()
inline string str(double x) { return dec(x); }

/** Align a string to the left
  * \param s input string
  * \param w width of display field
  * \param blank fill character
  * \return left aligned string
  */
string left(const string &s, int w, char blank = ' ');

/** Align a string to the right
  * \param s input string
  * \param w width of display field
  * \param blank fill character
  * \return right aligned string
  */
string right(const string &s, int w, char blank = ' ');

/** \}
  */

} // namespace cc
