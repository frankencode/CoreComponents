/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/String>
#include <cc/PropertyBinding>
#include <utility>

namespace cc {

template<class T>
class Property
{
public:
    Property(): instance_(Instance::create()) {}
    Property(const T &b): instance_(Instance::create(b)) {}

    Property(const Property &b): Property(b->value()) {}
    inline Property &operator=(const Property &b) { instance_->setValue(b->value()); return *this; }

    Property(Property &&b): instance_(std::move(b.instance_)) {}

    Property(const std::function<T()> &f): instance_(Instance::create(f)) {}
    inline Property &operator=(const std::function<T()> &f) { instance_->bind(f); return *this; }

    class Instance: public PropertyBinding {
    public:
        const T &value() const
        {
            preAccess();
            return value_;
        }

        void setValue(const T &newValue)
        {
            if (f_) {
                clearDependencies();
                f_ = std::function<T()>{};
                dirty_ = false;
            }
            establish(newValue);
        }

        template<class F>
        void bind(const F &f)
        {
            clearDependencies();

            f_ = f;
            dirty_ = true;

            if (hasConsumers()) {
                dirty_ = false;
                cascade();
            }
        }

        template<class F>
        void listen(const F &f)
        {
            if (dirty_) {
                dirty_ = false;
                evaluate();
            }

            valueChanged->listen(f);
        }

    private:
        friend class Property;

        template<class T2>
        friend Property<T2> alias(Property<T2> &p);

        inline static Ref<Instance> create(const T &b = T()) { return new Instance{b}; }
        inline static Ref<Instance> create(const std::function<T()> &f) { return new Instance{f}; }

        Instance(const T &b):
            PropertyBinding(false),
            value_(b)
        {}

        Instance(const std::function<T()> &f):
            PropertyBinding(true),
            value_(T()),
            f_(f)
        {}

        Property alias() { return Property(this, true); }

        void evaluate() override
        {
            establish(f_());
        }

        void establish(const T &newValue)
        {
            if (newValue != value_) {
                value_ = newValue;
                notify();
            }
        }

        mutable T value_;
        std::function<T()> f_;
    };

    inline Instance *operator->() { return instance_; }
    inline const Instance *operator->() const { return instance_; }

    inline operator T() const { return instance_->value(); }
    inline Property &operator=(const T &b) { instance_->setValue(b); return *this; }

    inline T operator()() const { return instance_->value(); }

    inline Property &operator+=(const T &b) { instance_->setValue(instance_->value() + b); return *this; }
    inline Property &operator-=(const T &b) { instance_->setValue(instance_->value() - b); return *this; }
    inline Property &operator*=(const T &b) { instance_->setValue(instance_->value() * b); return *this; }
    inline Property &operator/=(const T &b) { instance_->setValue(instance_->value() / b); return *this; }
    inline Property &operator|=(const T &b) { instance_->setValue(instance_->value() | b); return *this; }
    inline Property &operator&=(const T &b) { instance_->setValue(instance_->value() & b); return *this; }
    inline Property &operator^=(const T &b) { instance_->setValue(instance_->value() ^ b); return *this; }

    inline T operator-() const { return -instance_->value(); }
    inline T operator~() const { return ~instance_->value(); }

private:
    friend class Instance;

    Property(Instance *instance, bool): instance_(instance) {}

    Ref<Instance> instance_;
};

/** \internal
  * \brief Type conversion helpers
  * @{
  */
template<class T> inline bool operator==(const Property<T> a, const T &b) { return a->value() == b; }
template<class T> inline bool operator!=(const Property<T> a, const T &b) { return a->value() != b; }
template<class T> inline bool operator<(const Property<T> a, const T &b) { return a->value() < b; }
template<class T> inline bool operator>(const Property<T> a, const T &b) { return a->value() > b; }
template<class T> inline bool operator<=(const Property<T> a, const T &b) { return a->value() <= b; }
template<class T> inline bool operator>=(const Property<T> a, const T &b) { return a->value() >= b; }
template<class T> inline T operator+(const Property<T> a, const T &b) { return a->value() + b; }
template<class T> inline T operator-(const Property<T> a, const T &b) { return a->value() - b; }
template<class T> inline T operator*(const Property<T> a, const T &b) { return a->value() * b; }
template<class T> inline T operator/(const Property<T> a, const T &b) { return a->value() / b; }
template<class T> inline T operator|(const Property<T> a, const T &b) { return a->value() | b; }
template<class T> inline T operator&(const Property<T> a, const T &b) { return a->value() & b; }
template<class T> inline T operator^(const Property<T> a, const T &b) { return a->value() ^ b; }
/** @}
  */

template<class T>
inline Property<T> alias(Property<T> &p) { return p->alias(); }

template<class T>
inline String str(const Property<T> &p) { return str(p->value()); }

} // namespace cc
