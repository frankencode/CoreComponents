/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Event>
#include <cc/Set>

namespace cc {

template<class T>
class Property
{
public:
    Property(): instance_(Instance::create()) {}
    Property(const T &b): instance_(Instance::create(b)) {}

    Property(const Property &b): Property(b->value()) {}
    inline Property &operator=(const Property &b) { (*this)->setValue(b->value()); return *this; }

    Property(Property &&b): instance_(b.instance_) { b.instance_ = nullptr; }

    Property(const std::function<T()> &f): instance_(Instance::create(f)) {}
    inline Property &operator=(const std::function<T()> &f) { (*this)->bind(f); return *this; }

    class Instance: public Object {
    public:
        const T &value() const
        {
            if (dirty_) {
                const_cast<Instance *>(this)->dirty_ = false;
                const_cast<Instance *>(this)->evaluate();
            }

            if ((activeInstance_) && (activeInstance_ != this)) {
                if (activeInstance_->dependencies()->insert(const_cast<Instance *>(this)))
                    subscribers()->insert(activeInstance_);
            }
            return value_;
        }

        void setValue(const T &newValue)
        {
            if (f_) {
                clearDependencies();
                f_ = std::function<T()>{};
                dirty_ = false;
            }
            establish(newValue);
        }

        template<class F>
        void bind(const F &f)
        {
            clearDependencies();

            f_ = f;
            dirty_ = true;

            if (hasConsumers()) {
                dirty_ = false;
                evaluate();
            }
        }

        template<class F>
        void listen(const F &f)
        {
            if (dirty_) {
                dirty_ = false;
                evaluate();
            }

            valueChanged->listen(f);
        }

    private:
        friend class Property;

        template<class T2>
        friend Property<T2> alias(Property<T2> &p);

        typedef Set< Ref<Instance> > Association;

        inline static Ref<Instance> create(const T &b = T()) { return new Instance{b}; }
        inline static Ref<Instance> create(const std::function<T()> &f) { return new Instance{f}; }

        Instance(const T &b):
            value_(b),
            dirty_(false)
        {}

        Instance(const std::function<T()> &f):
            value_(T()),
            f_(f),
            dirty_(true)
        {}

        ~Instance()
        {
            clearDependencies();
            clearSubscribers();
        }

        Property alias() { return Property(this, Alias()); }

        Association *dependencies() const {
            if (!dependencies_) dependencies_ = Association::create();
            return dependencies_;
        }

        Association *subscribers() const {
            if (!subscribers_) subscribers_ = Association::create();
            return subscribers_;
        }

        bool hasConsumers() const { return (subscribers_ && subscribers_->count() > 0) || valueChanged->hasListeners(); }

        void clearDependencies()
        {
            if (!dependencies_) return;

            for (Instance *other: dependencies_)
                other->subscribers_->remove(this);
            dependencies_ = nullptr;
        }

        void clearSubscribers()
        {
            if (!subscribers_) return;

            for (Instance *other: subscribers_)
                other->dependencies_->remove(this);
            subscribers_ = nullptr;
        }

        void notify()
        {
            if (subscribers_) {
                for (Instance *other: subscribers_) {
                    if (other->hasConsumers()) {
                        other->dirty_ = false;
                        other->evaluate();
                    }
                    else {
                        other->dirty_ = true;
                    }
                }
            }
            valueChanged->notify();
        }

        void evaluate()
        {
            class Activator {
            public:
                Activator(Instance *instance): savedActiveInstance_(activeInstance_) { activeInstance_ = instance; }
                ~Activator() { activeInstance_ = savedActiveInstance_; }
            private:
                Instance *savedActiveInstance_;
            };

            Activator activator(this);
            establish(f_());
        }

        void establish(const T &newValue)
        {
            if (newValue != value_) {
                value_ = newValue;
                notify();
            }
        }

        Event valueChanged;

        mutable T value_;
        std::function<T()> f_;
        bool dirty_;

        mutable Ref<Association> dependencies_;
        mutable Ref<Association> subscribers_;
        thread_local static Instance *activeInstance_;
    };

    inline Instance *operator->() { return instance_; }
    inline const Instance *operator->() const { return instance_; }

    inline operator const T &() const { return (*this)->value(); }
    inline Property &operator=(const T &b) { (*this)->setValue(b); return *this; }

private:
    friend class Instance;

    class Alias {};

    Property(Instance *instance, Alias): instance_(instance) {}

    Ref<Instance> instance_;
};

template<class T>
inline Property<T> alias(Property<T> &p) { return p->alias(); }

template<class T>
thread_local typename Property<T>::Instance *Property<T>::Instance::activeInstance_ = nullptr;

} // namespace cc
