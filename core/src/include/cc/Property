/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Event>
#include <cc/Set>
#include <cc/String>
#include <utility>

namespace cc {

class PropertyEvaluationContext
{
public:
    static thread_local void *activeInstance_;
};

template<class T>
class Property
{
public:
    Property(): instance_(Instance::create()) {}
    Property(const T &b): instance_(Instance::create(b)) {}

    Property(const Property &b): Property(b->value()) {}
    inline Property &operator=(const Property &b) { instance_->setValue(b->value()); return *this; }

    Property(Property &&b): instance_(std::move(b.instance_)) {}

    Property(const std::function<T()> &f): instance_(Instance::create(f)) {}
    inline Property &operator=(const std::function<T()> &f) { instance_->bind(f); return *this; }

    class Instance: public Object {
    public:
        Event valueChanged;

        const T &value() const
        {
            if (dirty_) {
                const_cast<Instance *>(this)->dirty_ = false;
                const_cast<Instance *>(this)->evaluate();
            }

            if ((activeInstance()) && (activeInstance() != this)) {
                if (activeInstance()->dependencies()->insert(const_cast<Instance *>(this)))
                    subscribers()->insert(activeInstance());
            }

            return value_;
        }

        void setValue(const T &newValue)
        {
            if (f_) {
                clearDependencies();
                f_ = std::function<T()>{};
                dirty_ = false;
            }
            establish(newValue);
        }

        template<class F>
        void bind(const F &f)
        {
            clearDependencies();

            f_ = f;
            dirty_ = true;

            if (hasConsumers()) {
                dirty_ = false;
                evaluate();
            }
        }

        template<class F>
        void listen(const F &f)
        {
            if (dirty_) {
                dirty_ = false;
                evaluate();
            }

            valueChanged->listen(f);
        }

    private:
        friend class Property;

        template<class T2>
        friend Property<T2> alias(Property<T2> &p);

        typedef Set< Ref<Instance> > Association;

        inline static Ref<Instance> create(const T &b = T()) { return new Instance{b}; }
        inline static Ref<Instance> create(const std::function<T()> &f) { return new Instance{f}; }

        Instance(const T &b):
            value_(b),
            dirty_(false)
        {}

        Instance(const std::function<T()> &f):
            value_(T()),
            f_(f),
            dirty_(true)
        {}

        ~Instance()
        {
            clearDependencies();
            clearSubscribers();
        }

        Property alias() { return Property(this, true); }

        Association *dependencies() const {
            if (!dependencies_) dependencies_ = Association::create();
            return dependencies_;
        }

        Association *subscribers() const {
            if (!subscribers_) subscribers_ = Association::create();
            return subscribers_;
        }

        bool hasConsumers() const { return (subscribers_ && subscribers_->count() > 0) || valueChanged->hasListeners(); }

        void clearDependencies()
        {
            if (!dependencies_) return;

            for (Instance *other: dependencies_)
                other->subscribers_->remove(this);
            dependencies_ = nullptr;
        }

        void clearSubscribers()
        {
            if (!subscribers_) return;

            for (Instance *other: subscribers_)
                other->dependencies_->remove(this);
            subscribers_ = nullptr;
        }

        void notify()
        {
            if (subscribers_) {
                for (Instance *other: subscribers_) {
                    if (other->hasConsumers()) {
                        other->dirty_ = false;
                        other->evaluate();
                    }
                    else {
                        other->dirty_ = true;
                    }
                }
            }
            valueChanged->notify();
        }

        void evaluate()
        {
            class Activator {
            public:
                Activator(Instance *instance): savedActiveInstance_(PropertyEvaluationContext::activeInstance_) {
                    PropertyEvaluationContext::activeInstance_ = instance;
                }
                ~Activator() {
                    PropertyEvaluationContext::activeInstance_ = savedActiveInstance_;
                }
            private:
                void *savedActiveInstance_;
            };

            Activator activator(this);
            establish(f_());
        }

        void establish(const T &newValue)
        {
            if (newValue != value_) {
                value_ = newValue;
                notify();
            }
        }

        inline Instance *activeInstance() const { return (Instance *)PropertyEvaluationContext::activeInstance_; }

        mutable T value_;
        std::function<T()> f_;
        bool dirty_;

        mutable Ref<Association> dependencies_;
        mutable Ref<Association> subscribers_;
    };

    inline Instance *operator->() { return instance_; }
    inline const Instance *operator->() const { return instance_; }

    inline operator T() const { return instance_->value(); }
    inline Property &operator=(const T &b) { instance_->setValue(b); return *this; }

    inline T operator()() const { return instance_->value(); }

private:
    friend class Instance;

    Property(Instance *instance, bool): instance_(instance) {}

    Ref<Instance> instance_;
};

/** \internal
  * \brief Type conversion helpers
  * @{
  */
template<class T> inline bool operator==(const Property<T> a, const T &b) { return a->value() == b; }
template<class T> inline bool operator!=(const Property<T> a, const T &b) { return a->value() != b; }
template<class T> inline bool operator<(const Property<T> a, const T &b) { return a->value() < b; }
template<class T> inline bool operator>(const Property<T> a, const T &b) { return a->value() > b; }
template<class T> inline bool operator<=(const Property<T> a, const T &b) { return a->value() <= b; }
template<class T> inline bool operator>=(const Property<T> a, const T &b) { return a->value() >= b; }
template<class T> inline T operator+(const Property<T> a, const T &b) { return a->value() + b; }
template<class T> inline T operator-(const Property<T> a, const T &b) { return a->value() - b; }
template<class T> inline T operator*(const Property<T> a, const T &b) { return a->value() * b; }
template<class T> inline T operator/(const Property<T> a, const T &b) { return a->value() / b; }
template<class T> inline T operator|(const Property<T> a, const T &b) { return a->value() | b; }
template<class T> inline T operator&(const Property<T> a, const T &b) { return a->value() & b; }
template<class T> inline T operator^(const Property<T> a, const T &b) { return a->value() ^ b; }
/** @}
  */

template<class T>
inline Property<T> alias(Property<T> &p) { return p->alias(); }

template<class T>
inline String str(const Property<T> &p) { return str(p->value()); }

} // namespace cc
