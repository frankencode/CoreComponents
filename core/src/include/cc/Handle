/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <type_traits>
#include <cstddef>
#include <cassert>

namespace cc {

struct Alias {};

/** \class Handle cc/Handle
  * \ingroup objects
  * \brief Reference to an object state
  * \tparam T %Internal state type (needs to be inherited from Object::State)
  */
template<class T>
class Handle
{
public:
    /** Create an default reference
      */
    Handle():
        state_{T::Default::template get<T>()}
    {}

    /** Create a null reference
      */
    Handle(std::nullptr_t):
        state_{nullptr}
    {}

    /** Initialize with a newly created object state \a newState
      */
    Handle(T *newState):
        state_{newState}
    {
        assert(newState && newState->useCount() == 1);
    }

    Handle(T *newState, Alias):
        state_{newState}
    {
        newState->acquire();
    }

    /** Create an alias to an existing object state \a state
      */
    static Handle alias(const T *state)
    {
        assert(state);

        Handle b{AliasParam{}};
        b.state_ = const_cast<T *>(state);
        b.state_->acquire();
        return b;
    }

    /** Initialize by reference \a other
      */
    Handle(const Handle &other):
        state_{other.state_}
    {
        if (state_) state_->acquire();
    }

    /** Initialize by right-side reference \a other
      */
    Handle(Handle &&other):
        state_{other.state_}
    {
        other.state_ = nullptr;
    }

    /** Cleanup
      */
    ~Handle()
    {
        if (state_) state_->release();
        #ifndef NDEBUG
        state_ = nullptr;
        #endif
    }

    /** Assign reference \a other
      */
    Handle &operator=(const Handle &other)
    {
        if (state_) state_->release();
        state_ = other.state_;
        if (state_) state_->acquire();
        return *this;
    }

    /** Assign right-side reference \a other
      */
    Handle &operator=(Handle &&other)
    {
        if (state_) state_->release();
        state_ = other.state_;
        other.state_ = nullptr;
        return *this;
    }

    /** Assign nullptr
      */
    Handle &operator=(std::nullptr_t)
    {
        if (state_) state_->release();
        state_ = nullptr;
        return *this;
    }

    /** Get access to the object state
      */
    T &operator()()
    {
        T::Access::touch(state_);
        assert(state_);
        return *state_;
    }

    /** Get access to the object state
      */
    const T &operator()() const
    {
        assert(state_);
        return *state_;
    }

    /** Check if this reference points to a non-default object state
      */
    operator bool() const
    {
        return state_ != T::Default::template get<T>();
    }

    /** Lower than operator
      */
    bool operator<(const Handle &b) const
    {
        return state_ < b.state_;
    }

    /** Equal to operator
      */
    bool operator==(const Handle &b) const
    {
        return state_ == b.state_;
    }

    /** Not equal to operator
      */
    bool operator!=(const Handle &b) const
    {
        return state_ != b.state_;
    }

    /** Statically cast to a different state type \a T2
      */
    template<class T2>
    const T2 &as() const {
        assert(state_);
        return static_cast<const T2 &>((*this)());
    }

    /** Statically cast to a different state type \a T2
      */
    template<class T2>
    T2 &as() {
        assert(state_);
        return static_cast<T2 &>(*state_);
    }

    /** Check if this handle points to an object state of type T2
      */
    template<class T2>
    bool is() const
    {
        return std::is_base_of<T2, T>::value || (state_ && dynamic_cast<const T2 *>(state_));
    }

    /** Explicitly break constness
      */
    T &mutate() const
    {
        assert(state_);
        return *state_;
    }

private:
    template<class T2>
    friend bool operator<(const Handle<T2> &a, const T2 *b);

    template<class T2>
    friend bool operator<(const T2 *a, const Handle<T2> &b);

    struct AliasParam {};

    Handle(const AliasParam &) {}

    T *state_;
};

/** Lower than operator
  */
template<class T>
inline bool operator<(const Handle<T> &a, const T *b)
{
    return a.state_ < b;
}

/** Lower than operator
  */
template<class T>
inline bool operator<(const T *a, const Handle<T> &b)
{
    return a < b.state_;
}

} // namespace cc
