/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <iterator>
#include <cc/Object>

namespace cc {

template<class Container>
class ConstArrayIterator:
    public std::iterator<
        /*iterator_category*/ std::bidirectional_iterator_tag,
        /*value_type*/        typename Container::Item,
        /*difference_type*/   int,
        /*pointer*/           void,
        /*reference*/         typename Container::Item
    >
{
public:
    ConstArrayIterator(const Container *c, int i):
        c_{c},
        i_{i}
    {}

    typename Container::Item operator*() const { return c_->at(i_); }
    ConstArrayIterator &operator++() { ++i_; return *this; }
    ConstArrayIterator &operator--() { --i_; return *this; }
    ConstArrayIterator operator+(int delta) { return ConstArrayIterator{c_, i_ + delta}; }
    ConstArrayIterator operator-(int delta) { return ConstArrayIterator{c_, i_ - delta}; }
    int operator-(const ConstArrayIterator &b) const { return i_ - b.i_; }
    int operator<(const ConstArrayIterator &b) const { return i_ < b.i_; }
    bool operator==(const ConstArrayIterator &b) const { return i_ == b.i_; }
    bool operator!=(const ConstArrayIterator &b) const { return i_ != b.i_; }

private:
    const Container *c_;
    int i_;
};

template<class Container>
class ArrayIterator:
    public std::iterator<
        /*iterator_category*/ std::bidirectional_iterator_tag,
        /*value_type*/        typename Container::Item,
        /*difference_type*/   int,
        /*pointer*/           typename Container::Item *,
        /*reference*/         typename Container::Item &
    >
{
public:
    ArrayIterator(Container *c, int i):
        c_{c},
        i_{i}
    {}

    typename Container::Item &operator*() const { return c_->at(i_); }
    typename Container::Item *operator->() const { return &c_->at(i_); }
    ArrayIterator &operator++() { ++i_; return *this; }
    ArrayIterator &operator--() { --i_; return *this; }
    ArrayIterator operator+(int delta) { return ArrayIterator{c_, i_ + delta}; }
    ArrayIterator operator-(int delta) { return ArrayIterator{c_, i_ - delta}; }
    int operator-(const ArrayIterator &b) const { return i_ - b.i_; }
    int operator<(const ArrayIterator &b) const { return i_ < b.i_; }
    bool operator==(const ArrayIterator &b) const { return i_ == b.i_; }
    bool operator!=(const ArrayIterator &b) const { return i_ != b.i_; }

    operator ConstArrayIterator<Container>() const { return ConstArrayIterator<Container>{c_, i_}; }

private:
    Container *c_;
    int i_;
};

template<class Container>
inline typename Container::const_iterator begin(const Container *c) { return c->begin(); }

template<class Container>
inline typename Container::const_iterator end(const Container *c) { return c->end(); }

template<class Container>
inline typename Container::iterator begin(Container *c) { return c->begin(); }

template<class Container>
inline typename Container::iterator end(Container *c) { return c->end(); }

template<class Container>
inline typename Container::const_iterator begin(const Ref<const Container> &c) { return c->begin(); }

template<class Container>
inline typename Container::const_iterator end(const Ref<const Container> &c) { return c->end(); }

template<class Container>
inline typename Container::iterator begin(Ref<Container> c) { return c->begin(); }

template<class Container>
inline typename Container::iterator end(Ref<Container> c) { return c->end(); }

template<class Container>
inline typename Container::const_iterator begin(Local<const Container> &c) { return c->begin(); }

template<class Container>
inline typename Container::const_iterator end(Local<const Container> &c) { return c->end(); }

template<class Container>
inline typename Container::iterator begin(Local<Container> &c) { return c->begin(); }

template<class Container>
inline typename Container::iterator end(Local<Container> &c) { return c->end(); }

} // namespace cc
