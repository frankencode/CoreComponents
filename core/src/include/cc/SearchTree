/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/BinaryTree>

namespace cc {

template<class ItemType>
class SearchNode: public BinaryNode
{
public:
    typedef ItemType Item;

    SearchNode(): item_(Item()) {}
    SearchNode(const Item &item): item_(item) {}
    SearchNode(const SearchNode &kb) = default;

    inline SearchNode *left() const { return static_cast<SearchNode *>(left_); };
    inline SearchNode *right() const { return static_cast<SearchNode *>(right_); }
    inline SearchNode *parent() const { return static_cast<SearchNode *>(parent_); }

    Item item_;
};

#ifndef NDEBUG
class SearchTreeTester;
#endif

template<class NodeType>
class SearchTree: public BinaryTree
{
public:
    typedef NodeType Node;
    typedef typename NodeType::Item Item;

    SearchTree(int n = 0);
    ~SearchTree() { clear(); }

    SearchTree(const SearchTree &b);
    const SearchTree &operator=(const SearchTree &b);

    bool lookupByIndex(int index, Node **node = 0) const;

    template<class Pattern>
    Node *find(const Pattern &pattern, bool *found = 0, bool *below = 0, int *index = 0) const;

    inline void remove(Node *k) { return delete static_cast<Node *>(unlink(k)); }

    int findFirstAboveOrEqual(const Item &a) const;
    int findLastBelowOrEqual(const Item &b) const;

    void push(int index, const Item &item);
    void pop(int index, Item *item);

    inline void clear() { return BinaryTree::clear<Node>(); }
    inline int count() const { return weight(); }

private:
#ifndef NDEBUG
    friend class SearchTreeTester;
    static bool testOrder(Node *k);
#endif
};

template<class Node>
SearchTree<Node>::SearchTree(int n)
{
    if (n <= 0) return;

    BinaryNode **v = new BinaryNode *[n];
    for (int i = 0; i < n; ++i) v[i] = new Node;

    populate(v, n);

    delete[] v;
}

template<class Node>
SearchTree<Node>::SearchTree(const SearchTree &b)
{
    if (b.root_)
        root_ = clone(static_cast<Node *>(b.root_));
}

template<class Node>
const SearchTree<Node> &SearchTree<Node>::operator=(const SearchTree &b)
{
    clear();
    if (b.root_)
        root_ = clone(static_cast<Node *>(b.root_));
    return *this;
}

template<class Node>
bool SearchTree<Node>::lookupByIndex(int i, Node **node) const
{
    BinaryNode *k = getNodeAt(i);
    if (k && node) *node = static_cast<Node *>(k);
    return k;
}

template<class Node>
template<class Pattern>
Node *SearchTree<Node>::find(const Pattern &pattern, bool *found, bool *below, int *index) const
{
    Node *k2 = 0;
    if (found) *found = false;
    int j = -1;
    if (root_) {
        Node *k = static_cast<Node *>(root_);
        int j0 = 0;
        while (true) {
            k2 = k;
            j = j0 + BinaryTree::weight(k->left_);
            if (pattern < k->item_) {
                if (!k->left_) {
                    if (below) *below = true;
                    break;
                }
                k = k->left();
            }
            else if (k->item_ < pattern) {
                if (!k->right_) {
                    if (below) *below = false;
                    break;
                }
                j0 = j + 1;
                k = k->right();
            }
            else { // item == k->data()
                if (found) *found = true;
                break;
            }
        }
    }
    if (index) *index = j;
    return k2;
}

template<class Node>
inline int SearchTree<Node>::findFirstAboveOrEqual(const Item &a) const
{
    bool found = false, below = true;
    int index = 0;
    if (!root_) return 0;
    find(a, &found, &below, &index);
    if (found) return index;
    return below ? index : index + 1;
}

template<class Node>
inline int SearchTree<Node>::findLastBelowOrEqual(const Item &b) const
{
    bool found = false, below = true;
    int index = 0;
    if (!root_) return 0;
    find(b, &found, &below, &index);
    if (found) return index;
    return below ? index - 1 : index;
}

template<class Node>
void SearchTree<Node>::push(int index, const Item &item)
{
    Node *kn = new Node(item);
    attachAt(index, kn);
}

template<class Node>
void SearchTree<Node>::pop(int index, Item *item)
{
    BinaryNode *ko = unlinkAt(index);
    if (item) *item = static_cast<Node *>(ko)->item_;
}

#ifndef NDEBUG

template<class Node>
bool SearchTree<Node>::testOrder(Node *k)
{
    if (!k) return true;
    if (k->left_) {
        if (!(k->left()->item_ < k->item_))
            return false;
    }
    if (k->right_) {
        if (!(k->item_ < k->right()->item_))
            return false;
    }
    return testOrder(k->left()) && testOrder(k->right());
}

class SearchTreeTester: public BinaryTreeTester
{
protected:
    template<class SearchTree>
    static bool testOrder(const SearchTree *tree)
    {
        return SearchTree::testOrder(static_cast<typename SearchTree::Node *>(tree->root_));
    }

    template<class SearchTree>
    static bool test(const SearchTree *tree)
    {
        return
            BinaryTreeTester::test(tree) &&
            testOrder(tree);
    }
};

#endif // ndef NDEBUG

} // namespace cc
