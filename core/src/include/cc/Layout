/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/containers>
#include <cc/Source>
#include <cc/LayoutTree>

namespace cc {

template<class Item, class Extent>
class LayoutStop;

template<class Item, class Extent>
class LayoutSource;

template<class ItemType, class ExtentType>
class Layout: public Object
{
public:
    typedef ItemType Item;
    typedef ExtentType Extent;

    static Ref<Layout> create() { return new Layout; }

    void insertAt(int index, const Item &item, Extent extent) {
        CC_ASSERT((0 <= index) && (index <= count()));
        tree_.insertAt(index, item, extent);
    }

    void updateAt(int index, const Item &item, Extent extent) {
        CC_ASSERT(has(index));
        tree_.updateAt(index, item, extent);
    }

    void removeAt(int index, Item *item = 0) {
        CC_ASSERT(has(index));
        tree_.removeAt(index, item);
    }

    void append(const Item &item, Extent extent) { insertAt(count(), item, extent); }

    int count() const { return tree_.count(); }
    Extent extent() const { return tree_.extent(); }

    Extent extentAt(int index) const {
        CC_ASSERT(has(index));
        return tree_.extentAt(index);
    }

    bool updateExtentAt(int index, Extent extent) {
        CC_ASSERT(has(index));
        return tree_.updateExtentAt(index, extent);
    }

    Extent updateExtentAt(int index, const std::function<Extent(Extent)> &f) {
        CC_ASSERT(has(index));
        return tree_.updateExtentAt(index, f);
    }

    void getItemExtentAt(int index, Item *item, Extent *extent) const {
        CC_ASSERT(has(index));
        tree_.getItemExtentAt(index, item, extent);
    }

    void getView(Extent pos0, Extent pos1, int *index0, int *index1, Extent *itemPos0) const { tree_.getView(pos0, pos1, index0, index1, itemPos0); }

    Extent getPosAt(int index) const {
        CC_ASSERT(has(index));
        return tree_.getPosAt(index);
    }

    bool has(int index) const { return index < tree_.count() && 0 <= index; }
    Item &at(int index) {
        CC_ASSERT(has(index));
        return tree_.at(index);
    }
    const Item &at(int index) const {
        CC_ASSERT(has(index));
        return tree_.at(index);
    }

    /** \name C++ iterators
      * @{
      */
    typedef cc::Iterator<Layout> iterator;
    typedef cc::ConstIterator<Layout> const_iterator;
    iterator begin() { return iterator(this, 0); }
    iterator end() { return iterator(this, count()); }
    const_iterator begin() const { return const_iterator(this, 0); }
    const_iterator end() const { return const_iterator(this, count()); }
    /** @} */

    /** \name Source adapters
      * @{
      */
    Ref< LayoutSource<Item, Extent> > getAll() const { return LayoutSource<Item, Extent>::open(this, 0, count()); }
    Ref< LayoutSource<Item, Extent> > getInRange(Extent pos0, Extent pos1) const { return LayoutSource<Item, Extent>::open(this, pos0, pos1); }
    /** @} */

private:
    Layout() = default;

    typedef LayoutTree<Item, Extent> Tree;
    Tree tree_;
};

template<class Item, class Extent>
class LayoutStop {
public:
    LayoutStop()
    {}

    LayoutStop(Extent pos, Extent extent, const Item &item):
        instance_(pos, extent, item)
    {}

    class Instance {
    public:
        inline Extent pos() const { return pos_; }
        inline Extent extent() const { return extent_; }
        inline Item item() const { return item_; }

    private:
        friend class LayoutStop;

        Instance()
        {}

        Instance(Extent pos, Extent extent, const Item &item):
            pos_(pos),
            extent_(extent),
            item_(item)
        {}

        Extent pos_;
        Extent extent_;
        Item item_;
    };

    inline const Instance *operator->() const { return &instance_; }

private:
    Instance instance_;
};

template<class Item, class Extent>
class LayoutSource: public Source< LayoutStop<Item, Extent> >
{
public:
    static Ref<LayoutSource> open(const Layout<Item, Extent> *layout, Extent pos0, Extent pos1) {
        return new LayoutSource(layout, pos0, pos1);
    }

    bool read(LayoutStop<Item, Extent> *layoutItem) override
    {
        if (i_ < i1_) {
            Item item;
            Extent extent;
            layout_->getItemExtentAt(i_, &item, &extent);
            *layoutItem = LayoutStop<Item, Extent>(x_, extent, item);
            ++i_;
            x_ += extent;
            return true;
        }
        return false;
    }

private:
    LayoutSource(const Layout<Item, Extent> *layout, Extent pos0, Extent pos1):
        layout_(layout)
    {
        layout->getView(pos0, pos1, &i_, &i1_, &x_);
    }

    const Layout<Item, Extent> *layout_;
    int i_, i1_;
    Extent x_;
};

} // namespace cc
