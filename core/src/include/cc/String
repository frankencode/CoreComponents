/*
 * Copyright (C) 2007-2018 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/containers>
#include <cc/strings>
#include <cc/List>
#ifdef QT_CORE_LIB
#include <QString>
#include <QUrl>
#endif

/// translate a macro expression into a C string
#define CC_XSTR(x) CC_STR(x)
#define CC_STR(x) #x

namespace cc {

template<class T>
class Array;

/** Convenience alias
  * \ingroup strings
  * \see Array<char>
  */
typedef Array<char> CharArray;

class Variant;
class Format;

/** Spezialised Ref<T> for character arrays
  * \ingroup strings
  * \see Array<char>
  */
typedef Ref<const CharArray> String;

/** Convenience alias
  * \ingroup strings
  */
typedef List<String> StringList;

class MutantString;

/** Get writable access to a string
  * \ingroup strings
  */
CharArray *mutate(const String &s);

/** Get writable access to an intermediate string
  * \ingroup strings
  */
MutantString mutate(String &&s);

/** \class Ref<const CharArray> cc/String
  * \brief Spezialised Ref<T> for T=CharArray
  * \ingroup strings
  * \see mutate(const String &), CharArray, String
  */
template<>
class Ref<const CharArray>
{
public:
    /// \copydoc Array<char>::allocate()
    static String allocate(int size);

    /// \copydoc Array<char>::create(int)
    static String create(int size);

    /// \copydoc Array<char>::create(int, char)
    static String create(int size, char preset);

    /// \copydoc Array<char>::copy(const char *, int)
    static String copy(const char *data, int size = -1);

    /// Create a copy of another string \a b
    static String copy(const String &b);

    /// \copydoc Array<char>::cat()
    static String cat(const String &a, const String &b);

    /// \copydoc Array<char>::join(const StringList *, const String &)
    static String join(const StringList *parts, const String &sep = String());

    /// Construct an empty string
    Ref(): a_(0) {}

    /// Construt a string from an intermediate expression
    Ref(String &&b): a_(b.a_) { b.a_ = 0; }

    /// Construct an alias of another string \a b
    Ref(const String &b);

    /// \copydoc Ref(const String &)
    Ref(const CharArray *b);

    /// \copydoc Ref(const String &)
    Ref(CharArray *b): a_(0) { set(b); }

    /** Construct a copy of another C string
      * \param other pointer to C string to copy
      * \param size number of characters to copy (optional)
      */
    Ref(const char *other, int size = -1);

    // explicit Ref(char ch);

    /** Construct an initialized zero-terminated string
      * \param size number of characters (excluding the terminating '\0')
      * \param preset initial character value
      */
    explicit Ref(int size, char preset = '\0');

    /// Construct a string by concatenating the items of list \a b
    Ref(const Ref<StringList> &b);

    /// Contruct a string as an alias to the string stored in \a b
    Ref(const Variant &b);

    /// \copydoc Ref(const Ref<StringList> &)
    Ref(const Format &b);

    /// \internal
    ~Ref() { set(0); }

    /// Make this string an alias of \a b
    String &operator=(const String &b);

    /// Assign a copy of C string \a b
    String &operator=(const char *b);

    /// Assign the value of an intermediate expression
    inline String &operator=(String &&b) { set(0); a_ = b.a_; b.a_ = 0; return *this; }

    /// Make this string an alias of \a b
    inline String &operator=(CharArray *b) { set(b); return *this; }

    /// Make this string an lias of the string stored in \a b
    inline String &operator=(const Variant &b) { set(String(b)); return *this; }

    /// Concatenate the items of list \a b and assign the resulting string
    inline String &operator=(const Ref<StringList> &b) { set(String(b)); return *this; }

    /// Concatenate the items of the formatting list \a b and assign the resulting string
    inline String &operator=(const Format &b) { set(String(b)); return *this; }

    /// Assign an empty string
    inline String &operator=(const int &null) { CC_ASSERT(null == 0); (void)null; set(0); return *this; }

    /// Concatenate this string and character \a b and assign the resulting string
    String &operator+=(char b);

    /// Concatenate this string and C string \a b and assign the resulting string
    String &operator+=(const char *b);

    /// Concatenate this string and C string \a b and assign the resulting string
    String &operator+=(const String &b);

    /// Concatenate this string and all items of string list \a b and assign the resulting string
    String &operator+=(const Ref<StringList> &b);

    /// Contextual conversion to bool (true if s->count() > 0)
    operator bool();

    /// Contextual conversion to bool (true if s->count() > 0)
    operator bool() const;

    /// Convert to a C string
    operator const char *();

    /// Convert to a C string
    operator const char *() const;

    /// Convert to a character array pointer
    inline operator const CharArray *() { return get(); }

    /// Convert to a character array pointer
    inline operator const CharArray *() const { return get(); }

#ifdef QT_CORE_LIB
    /// \internal
    inline operator QString() const;

    /// \internal
    inline operator QUrl() const;
#endif

    /// Access the underlying character array (read-only)
    inline const CharArray &operator*() const { return *get(); }

    /// Access the underlying character array (read-only)
    inline const CharArray *operator->() const { return get(); }

private:
    friend class MutantString;
    friend class Variant;
    template<class T2> friend class Ref;

    friend CharArray *mutate(const String &s);

    const CharArray *get() const;
    void set(const CharArray *b);

    const CharArray *a_;
};

class MutantString {
public:
    MutantString(String &&s): s_(s) {}
    MutantString(const String &s): s_(s) {}
    operator char *();
    operator CharArray *();
    CharArray *operator->();

private:
    String s_;
};

/** \class Array<char> cc/String
  * \brief Character array
  * \ingroup strings
  * \see Array
  */
template<>
class Array<char>: public Object
{
public:
    /// Item type for iteration
    typedef char Item;

    /** Create an uninitialized non-zero-terminated character array
      * \param size number of characters
      * \return new object instance
      * \see isZeroTerminated()
      * \see System::pageSize()
      */
    static String allocate(int size);

    /** Create an uninitialized zero-terminated character array
      * \param size number of characters (excluding the terminating '\0')
      * \return new object instance
      * \see isZeroTerminated()
      */
    static String create(int size = 0);

    /** Create an initialized zero-terminated character array
      * \param size number of characters (excluding the terminating '\0')
      * \param preset initial character value
      * \return new object instance
      * \see isZeroTerminated()
      */
    static String create(int size, char preset)
    {
        String s = create(size);
        mutate(s)->fill(preset);
        return s;
    }

    /** Create a copy of a C string
      * \param data pointer to C string
      * \param size number of characters (optional)
      * \return new object instance
      * \see isZeroTerminated()
      */
    static String copy(const char *data, int size = -1);

    /** Create a copy of another character array
      * \param other the original character array
      * \return new object instance
      */
    inline static String copy(const CharArray *other) { return other ? other->copy() : String(); }

    /** Join a list of strings
      * \param parts the individual items to join together
      * \param sep the separator to put between the items
      * \param sepSize the size of the separator (optional)
      * \return new object instance
      */
    static String join(const StringList *parts, const char *sep = "", int sepSize = -1);

     /** Join a list of strings
      * \param parts the individual parts to join together
      * \param sep the separator to put between individual parts
      * \return new object instance
      */
    static String join(const StringList *parts, const String &sep);

    /** Concatenate two strings
      * \param a the left string
      * \param b the right string
      * \return new object instance
      */
    static String cat(const String &a, const String &b);

    /// Return the pointer to the default character array (which is of zero length)
    static const CharArray *empty();

    /// Returns true if this character array is zero terminated
    virtual bool isZeroTerminated() const { return true; }

    /// %Set all characters to \a zero
    void fill(char zero);

    /// %Set the first \a n characters to \a zero
    void fill(char zero, int n);

    /// Cut this string down to \a newSize characters
    void truncate(int newSize);

    /// Copy characters from this string to string \a b
    void write(const CharArray *b) {
        int n = (size_ < b->size_) ? size_ : b->size_;
        memcpy(data_, b->data_, n);
    }

    /** Copy characters from this string to string \a b
      * \param b source to copy data from
      * \param i0 begin of destination range (index of first byte to write)
      * \param i1 end of destination range (index behind the last byte to write)
      */
    void write(const CharArray *b, int i0, int i1)
    {
        if (i0 < 0) i0 = 0;
        if (i1 > size_) i1 = size_;
        if (i1 <= i0) return;
        int n = i1 - i0;
        if (n > b->size_) n = b->size_;
        memcpy(data_ + i0, b->data_, n);
    }

    /// Byte-vise xor over character array \a b
    void writeXor(const CharArray *b);

    /// Length of this string (in number of characters)
    inline int count() const { return size_; }

    /// Check if index \a i is valid
    inline bool has(int i) const {
        return (0 <= i) && (i < size_);
    }

    /// Access character at index \a i
    inline char &at(int i) {
        CC_ASSERT(has(i));
        return data_[i];
    }

    /// \copybrief at(int)
    inline const char &at(int i) const {
        CC_ASSERT(has(i));
        return data_[i];
    }

    /// Access byte at index \a i
    inline uint8_t &byteAt(int i) {
        CC_ASSERT(has(i));
        return bytes_[i];
    }

    /// \copybrief byteAt(int)
    inline const uint8_t &byteAt(int i) const {
        CC_ASSERT(has(i));
        return bytes_[i];
    }

    /// Access word at word offset \a j (1 word = 4 bytes)
    inline uint32_t &wordAt(int j) {
        CC_ASSERT(has(j * 4) && has(j * 4 + 3));
        return words_[j];
    }

    /// \copybrief wordAt(int)
    inline const uint32_t &wordAt(int j) const {
        CC_ASSERT(has(j * 4) && has(j * 4 + 3));
        return words_[j];
    }

    /// Check if item index \a j is valid
    template<class T>
    inline bool hasItem(int j) const {
        return has(j * sizeof(T));
    }

    /// Access item of type T at item index \a j
    template<class T>
    inline T &item(int j = 0) {
        CC_ASSERT(has(j * sizeof(T)) && has((j + 1) * sizeof(T) -1));
        return reinterpret_cast<T *>(data_)[j];
    }

    /// \copybrief item(int)
    template<class T>
    inline const T &item(int j = 0) const {
        CC_ASSERT(has(j * sizeof(T)) && has((j + 1) * sizeof(T) -1));
        return reinterpret_cast<T *>(data_)[j];
    }

    /// Number of items of type T
    template<class T>
    inline int itemCount() const { return size_ / sizeof(T); }

    /// Return the internal C string representation
    inline char *chars() { return chars_; }

    /// \copybrief chars()
    inline const char *chars() const { return chars_; }

    /// Return byte pointer to the internal memory buffer
    inline uint8_t *bytes() { return bytes_; }

    /// \copybrief bytes()
    inline const uint8_t *bytes() const { return bytes_; }

    /// Return word pointer to the internal memory buffer
    inline uint32_t *words() { return words_; }

    /// \copybrief words()
    inline const uint32_t *words() const { return words_; }

    /// Create a copy of this string
    inline String copy() const { return new CharArray(*this); }

    /** Create a selection (reference to a sub-string)
      * \param i0 begin of selection (index of first selected character)
      * \param i1 end of selection (index behind the last selected character)
      * \return the selected sub-string
      * \see parent()
      * \see Object::refCount()
      * Sub-strings reference their parent and therefore increment the parent's reference count (\see Object::refCount()).
      * Sub-string selections can be cascaded to arbitrary depth.
      */
    inline String select(int i0, int i1) const {
        return new CharArray(this, i0, i1);
    }

    /** Create a selection (reference to a sub-string)
      * \param i1 end of selection (index behind the last selected character)
      * \return the selected sub-string
      */
    inline String select(int i1) const {
        return new CharArray(this, 0, i1);
    }

    /// Pointer to parent string if this string is a sub-string selection (nullptr otherwise)
    inline const CharArray *parent() const { return parent_; }

    /// Character offset of this string within its parent string if this string is a sub-string selection (0 otherwise)
    inline int offset() const { return parent_ ? int(data_ - parent_->data_) : 0; }

    /// Copy characters in range [\a range->i0(), \a range->i1())
    template<class Range>
    inline String copyRange(Range range) const {
        if (!range) return new CharArray();
        return copy(range->i0(), range->i1());
    }

    /// Copy characters in range [\a i0, \a i1)
    String copy(int i0, int i1) const;

    /** Create an edited version of this string by replacing a sub-string
      * \param i0 begin of sub-string (index of first selected character)
      * \param i1 end of sub-string (index behind the last selected charater)
      * \param text text that will replace the sub-string
      * \return new string with range [\a i0, \a i1) replaced by text
      */
    String paste(int i0, int i1, const String &text) const;

    /// Select \a n characters from the head of this string
    inline String head(int n) const {
        if (n == size_) return this;
        return select(0, n);
    }

    /// Select \a n characters from the tail of this string
    inline String tail(int n) const {
        if (n == size_) return this;
        return select(size_ - n, size_);
    }

    /// Check if the first character of this string equals \a ch
    inline bool beginsWith(char ch) const {
        if (size_ == 0) return false;
        return data_[0] == ch;
    }

    /// Check if the last character of this string equals \a ch
    inline bool endsWith(char ch) const {
        if (size_ == 0) return false;
        return data_[size_ - 1] == ch;
    }

    /// Check if this string begins with the sub-string \a s
    bool beginsWith(const String &s) const;

    /** \copybrief beginsWith(const String &) const
      * \param s sub-string to test for
      * \param n size of \a s (optional)
      */
    bool beginsWith(const char *s, int n = -1) const;

    /// Check if this string ends with the sub-string \a s
    bool endsWith(const String &s) const;

    /** \copybrief endsWith(const String &) const
      * \param s sub-string to test for
      * \param n size of \a s (optional)
      */
    bool endsWith(const char *s, int n = -1) const;

    /** Find first occurence of a character value
      * \param ch character value to search for
      * \param i start search from this index
      * \return index of first occurence of character ch or count() if not found
      */
    inline int find(char ch, int i = 0) const { // FIXME: obsolete
        if (i < 0) i = 0;
        while (i < size_) {
            if (data_[i] == ch) break;
            ++i;
        }
        return i;
    }

    /** Find first occurence of a character value
      * \param ch character value to search for
      * \param i current search index
      * \return true if \a ch was found, false otherwise
      */
    inline bool findNext(char ch, int *i = 0) const {
        int j = (i) ? *i : 0;
        while (j < size_) {
            if (data_[j] == ch) {
                if (i) *i = j;
                return true;
            }
            ++j;
        }
        if (i) *i = j;
        return false;
    }

    /** Check if this string contains a certain character value
      * \param ch character value to search for
      * \return true if this string contains character ch
      */
    inline bool contains(char ch) const { return find(ch) < size_; }

    /** Count the number of occurrences of a certain character value
      * \param ch character value to search for
      * \return number of occurrences of character value \a ch
      */
    inline int count(char ch) const {
        int n = 0;
        for (int i = 0; i < size_; ++i)
            n += (data_[i] == ch);
        return n;
    }

    /** Count number of occurrences of characters from a set of characters
      * \param set set of characters
      * \return number of occurrences of characters from the set
      */
    int countCharsIn(const char *set) const;

    /** Find a sub-string
      * \param s sub-string to search for
      * \param i start search from this index
      * \return index of first occurence of s or count() if not found
      */
    int find(const char *s, int i = 0) const;

    /// \copydoc find(const char *, int) const
    int find(const String &s, int i = 0) const;

    /** Check if this string contains a certain sub-string
      * \param s sub-string to search for
      * \return true if this string contains the sub-string \a s
      */
    inline bool contains(const char *s) const
    {
        if (!s[0]) return true;
        return find(s) != size_;
    }

    /// \copydoc contains(const char *) const
    bool contains(const String &s) const;

    /** Create a string list by splitting this string into pieces
      * \param sep split marker to search for
      * \return list of pieces without the split markers
      */
    Ref<StringList> split(char sep) const;

    /// \copydoc split(char) const
    Ref<StringList> split(const char *sep) const;

    /// \copydoc split(char) const
    Ref<StringList> split(String sep) const { return split(sep->chars()); }

    /** Create a string list by breaking up this string into equal sized chunks
      * \param chunkSize size of the individual chunks
      * \return list of chunks
      */
    Ref<StringList> breakUp(int chunkSize) const;

    /** Replace individual character values
      * \param p character value to search for
      * \param r replacement value to insert
      */
    inline String replaceInsitu(char p, char r) {
        for (int i = 0; i < size_; ++i) {
            if (data_[i] == p)
                data_[i] = r;
        }
        return this;
    }

    /** Replace any occurrence of a certain sub-string by a replacement string
      * \param p sub-string to search for
      * \param r replacement string
      */
    String replaceInsitu(const char *p, const char *r);

    /** Replace individual character values
      * \param p character value to search for
      * \param r replacement value to insert
      * \return resulting string
      */
    String replaceEach(char p, char r) const;

    /** Replace any occurrence of a certain sub-string by a replacement string
      * \param p sub-string to search for
      * \param r replacement string
      * \return resulting string
      */
    String replace(const char *p, const char *r) const;

    /// \copydoc replace(const char *, const char *) const
    String replace(const char *p, const String &r) const;

    /// \copydoc replace(const char *, const char *) const
    String replace(const String &p, const String &r) const;

    /** Scan for a sub-string up to a lexical termination
      * \param x return the scanned sub-string
      * \param termination set of lexical termination characters
      * \param i0 begin of range to scan (index of first character)
      * \param i1 end of range to scan (index behind the last charater)
      * \return scan position behind the scanned string
      */
    int scanString(String *x, const char *termination = " \t\n", int i0 = 0, int i1 = -1) const;

    /** Scan a number literal
      * \param value returns the value of the scanned number
      * \param base number base to use
      * \param i0 begin of range to scan (index of first character)
      * \param i1 end of range to scan (index behind the last charater)
      * \return scan position behind the scanned string
      */
    template<class T>
    int scanNumber(T *value, int base = 10, int i0 = 0, int i1 = -1) const;

    /** Convert to a numerical value
      * \param ok return true if conversion was successful (optional)
      * \return numerical value
      */
    template<class T>
    inline T toNumber(bool *ok = 0) const
    {
        bool h = false;
        if (!ok) ok = &h;
        T value = T();
        *ok = (scanNumber(&value) == size_);
        return value;
    }

    /// Convert all upper-case ASCII characters to lower-case ASCII characters
    inline String toLower() const { return mutate(copy())->downcaseInsitu(); }

    /// Convert all lower-case ASCII characters to upper-case ASCII characters
    inline String toUpper() const { return mutate(copy())->upcaseInsitu(); }

    /// \copybrief toLower() const
    String downcaseInsitu();

    /// \copybrief toUpper() const
    String upcaseInsitu();

    /// Replace all non-printable and non-ASCII characters by escape sequences
    String escape() const;

    /// Replace all escape sequences by their character value
    inline String unescape() const { return mutate(copy())->unescapeInsitu(); }

    /// \copybrief unescape() const
    String unescapeInsitu();

    /** Remove leading and trailing whitespace
      * \param leadingSpace set of characters to detect as leading whitespace
      * \param trailingSpace set of characters to detect as trailing whitespace
      */
    inline String trim(const char *leadingSpace = " \t\n\r", const char *trailingSpace = 0) const
    {
        return mutate(copy())->trimInsitu(leadingSpace, trailingSpace);
    }

    /** Remove leading whitespace
      * \param space set of characters to detect as whitespace
      */
    inline String trimLeading(const char *space = " \t\n\r") const { return mutate(copy())->trimInsitu(space, ""); }

    /** Remove trailing whitespace
      * \param space set of characters to detect as whitespace
      */
    inline String trimTrailing(const char *space = " \t\n\r") const { return mutate(copy())->trimInsitu("", space); }

    /// \copybrief trim(const char *, const char *) const
    String trimInsitu(const char *leadingSpace = " \t\n\r", const char *trailingSpace = 0);

    /// Replace multi character whitespaces by single character whitespaces
    inline String simplify(const char *space = " \t\n\r") const { return mutate(copy())->simplifyInsitu(space); }

    /// \copybrief simplify(const char *) const
    String simplifyInsitu(const char *space = " \t\n\r");

    /** Common user input normalization
      * \param nameCase make sure the first character is upper case
      */
    String normalize(bool nameCase = true) const;

    /// Remove all XML/HTML tags and entities
    String xmlSanitize() const;

    /** \brief %Map a byte offset to editor coordinates.
      * \param offset byte offset
      * \param line n-th line starting with 1
      * \param pos position on line starting with 0 (in bytes)
      * \return true if offset is within valid range
      */
    bool offsetToLinePos(int offset, int *line = 0, int *pos = 0) const;

   /** %Map editor coordinates to a byte offset
     * \param line n-th line starting with 1
     * \param pos position on line starting with 1 (in bytes)
     * \param offset byte offset
     * \return true if successful
     */
    bool linePosToOffset(int line, int pos, int *offset = 0) const;

    /** Check if this string is UTF-8 encoded
      * \exception EncodingError this string is not UTF-8 encoded
      */
    void checkUtf8() const;

    /** Create an UTF-8 encoded string from an UTF-16 encoded string
      * \param utf16 UTF-16 encoded string
      * \param endian endianess of the UTF-16 encoded string
      * \return UTF-8 encoded string
      */
    static String fromUtf16(const CharArray *utf16, Endian endian = localEndian());

   /** Convert to a UTF-16 encoded string (local endian).
     * \param buf destination buffer
     * \param size pass capacity of destination buffer
     * \return true if the given buffer was suitable to hold the encoded string
     *
     * The number of bytes required to fully represent the string in UTF-16 is
     * returned with the \a size argument. Passing a zero for \a size allows to
     * determine the required buffer size. No zero termination is written or
     * or accounted for.
     */
    bool toUtf16(void *buf, int *size);

    /** \copybrief toUtf16(void *, int *)
      * \param endian endianess of the UTF-16 encoded string
      * \return UTF-16 encoded string
      */
    String toUtf16(Endian endian = localEndian()) const;

    /** Convert to a series of hexadecimal characters
      * \see hexDump
      */
    String toHex() const;

    /** Convert to a hexadecimal dump
      * \see HexDump
      */
    String hexDump() const;

    /// Add a prefix to each line of the text
    String indent(String prefix) const;

    /// Check if this string equals "/"
    bool isRootPath() const;

    /// Check if this string represents a relative path
    bool isRelativePath() const;

    /// Check if this string represents an absolute path
    bool isAbsolutePath() const;

    /** Convert to an absolute path
      * \param currentDir absolute path to the current directory
      * \return absolute path
      */
    String absolutePathRelativeTo(const String &currentDir) const;

    /// Return the filename component
    String fileName() const;

    /// Return the filename component without file type suffix
    String baseName() const;

    /// Return the file type suffix (everything after the last '.')
    String fileSuffix() const;

    /// Remove the last component from this path
    String reducePath() const;

    /// Append components of \a relativePath to this string
    String extendPath(const String &relativePath) const;

    /// Remove redundant or ambigous path elements
    String canonicalPath() const;

    /// Compare this string for equality with string \a b
    inline bool equals(const String &b) const { return size_ == b->size_ && strncmp(chars_, b->chars_, size_) == 0; }

    /// Compare this tring for inequality with string \a b
    inline bool differs(const String &b) const { return size_ != b->size_ || strncmp(chars_, b->chars_, size_) != 0; }

    /// Compare if this string is below string \a b
    inline bool below(const String &b) const {
        return below(b->chars(), b->count());
    }

    /// Compare if this string is below string \a b
    bool below(const char *b, int bSize = -1) const {
        if (bSize < 0) bSize = strlen(b);
        int m = size_ < bSize ? size_ : bSize;
        int ret = strncmp(chars_, b, m);
        if (ret == 0) return size_ < bSize;
        return ret < 0;
    }

    /// Compare if this string is below or equal string \a b
    inline bool belowOrEqual(const String &b) const {
        return belowOrEqual(b->chars(), b->count());
    }

    /// Compare if this string is below or equal string \a b
    bool belowOrEqual(const char *b, int bSize = -1) const {
        if (bSize < 0) bSize = strlen(b);
        int m = size_ < bSize ? size_ : bSize;
        int ret = strncmp(chars_, b, m);
        if (ret == 0) return size_ <= bSize;
        return ret < 0;
    }

    /// Compare if this string is greater than string \a b
    inline bool greater(const String &b) const { return b->below(this); }

    /// Compare if this string is greater than string \a b
    inline bool greater(const char *b, int bSize = -1) const { return !belowOrEqual(b, bSize); }

    /// Compare is this string is greater or equal string \a b
    inline bool greaterOrEqual(const String &b) const { return b->belowOrEqual(this); }

    /// Compare is this string is greater or equal string \a b
    inline bool greaterOrEqual(const char *b, int bSize = -1) const { return !below(b, bSize); }

    /// Compare if this string equals string \a b (ASCII case-insensitive)
    bool equalsCaseInsensitive(const String &b) const;

    /// \copybrief equalsCaseInsensitive(const String &) const
    bool equalsCaseInsensitive(const char *b) const;

    /** \name C++ iterators
      * @{
      */
    typedef Iterator<CharArray> iterator;
    typedef ConstIterator<CharArray> const_iterator;
    iterator begin() { return iterator(this, 0); }
    iterator end() { return iterator(this, count()); }
    const_iterator begin() const { return const_iterator(this, 0); }
    const_iterator end() const { return const_iterator(this, count()); }
    /** @} */

protected:
    friend class Ref<const CharArray>;

    friend bool operator==(const String &a, const String &b);
    friend bool operator!=(const String &a, const String &b);
    friend bool operator< (const String &a, const String &b);
    friend bool operator<=(const String &a, const String &b);

    typedef void (*Destroy)(CharArray *array);

    Array();
    Array(const char *data, int size = -1, Destroy destroy = 0);
    Array(const CharArray *parent, int i0, int i1);
    Array(const CharArray &b);

    ~Array();

    static void doNothing(CharArray *);

private:
    void destroy();

    static double pow(double x, double y);

    int size_;
    union {
        char *data_;
        char *chars_;
        uint8_t *bytes_;
        uint32_t *words_;
    };

    Destroy destroy_;
    String parent_;
};

template<class T>
int Array<char>::scanNumber(T *value, int base, int i0, int i1) const
{
    int i = i0;
    if (i1 < 0) i1 = size_;
    if (i > i1) i = i1;
    int sign = 1;
    if (T(-1) < T() && i < i1) {
        if (at(i) == '-') sign = -1;
        i += (at(i) == '-' || at(i) == '+');
    }
    bool isFloating = (T(1)/T(3) > 0);
    if (isFloating && i + 2 < i1) {
        if (at(i) == 'n' && at(i + 1) == 'a' && at(i + 2) == 'n') {
            *value = cc::nan();
            return i + 3;
        }
        else if (at(i) == 'i' && at(i + 1) == 'n' && at(i + 2) == 'f') {
            *value = sign * cc::inf();
            return i + 3;
        }
    }
    if (i < i1) {
        if (at(i) == '0') {
            if (i + 1 < i1) {
                char ch = at(i + 1);
                if (ch == 'x') { base = 16; i += 2; }
                else if (ch == 'b') { base = 2; i += 2; }
                else if ('0' <= ch && ch <= '7') { base = 8; i += 1; }
            }
        }
    }
    T x = 0;
    while (i < i1) {
        char ch = at(i);
        int z = -1;
        if ('0' <= ch && ch <= '9') z = ch - '0';
        else if ('a' <= ch && ch <= 'z') z = 10 + ch - 'a';
        else if ('A' <= ch && ch <= 'Z') z = 10 + ch - 'A';
        if (z < 0 || base <= z) break;
        T y = x;
        x = x * base + sign * z;
        if (!isFloating) {
            if (sign > 0 ? x < y : y < x)
                break;
        }
        ++i;
    }
    if (isFloating && i < i1) {
        if (at(i) == '.') {
            ++i;
            for (T h = T(sign) / T(base); i < i1; ++i) {
                char ch = at(i);
                int z = -1;
                if ('0' <= ch && ch <= '9') z = ch - '0';
                else if ('a' <= ch && ch <= 'z') z = 10 + ch - 'a';
                else if ('A' <= ch && ch <= 'Z') z = 10 + ch - 'A';
                if (z < 0 || base <= z) break;
                x += h * z;
                h /= base;
            }
        }
        if (i + 1 < i1) {
            if (at(i) == 'E' || at(i) == 'e') {
                int ep = 0;
                i = scanNumber(&ep, base, i + 1, i1);
                x *= pow(T(base), T(ep));
            }
        }
    }
    *value = x;
    return i;
}

inline bool operator==(const String &a, const String &b) { return a->equals(b); }
inline bool operator!=(const String &a, const String &b) { return a->differs(b); }
inline bool operator< (const String &a, const String &b) { return a->below(b); }
inline bool operator> (const String &a, const String &b) { return a->greater(b); }
inline bool operator<=(const String &a, const String &b) { return a->belowOrEqual(b); }
inline bool operator>=(const String &a, const String &b) { return a->greaterOrEqual(b); }

inline bool operator==(const char *a, const String &b) { return b->equals(a); }
inline bool operator!=(const char *a, const String &b) { return b->differs(a); }
inline bool operator< (const char *a, const String &b) { return b->greater(a); }
inline bool operator> (const char *a, const String &b) { return b->below(a); }
inline bool operator<=(const char *a, const String &b) { return b->greaterOrEqual(a); }
inline bool operator>=(const char *a, const String &b) { return b->belowOrEqual(a); }

inline bool operator==(char *a, const String &b) { return b->equals(a); }
inline bool operator!=(char *a, const String &b) { return b->differs(a); }
inline bool operator< (char *a, const String &b) { return b->greater(a); }
inline bool operator> (char *a, const String &b) { return b->below(a); }
inline bool operator<=(char *a, const String &b) { return b->greaterOrEqual(a); }
inline bool operator>=(char *a, const String &b) { return b->belowOrEqual(a); }

inline bool operator==(const String &a, const char *b) { return a->equals(b); }
inline bool operator!=(const String &a, const char *b) { return a->differs(b); }
inline bool operator< (const String &a, const char *b) { return a->below(b); }
inline bool operator> (const String &a, const char *b) { return a->greater(b); }
inline bool operator<=(const String &a, const char *b) { return a->belowOrEqual(b); }
inline bool operator>=(const String &a, const char *b) { return a->greaterOrEqual(b); }

inline bool operator==(const String &a, char *b) { return a->equals(b); }
inline bool operator!=(const String &a, char *b) { return a->differs(b); }
inline bool operator< (const String &a, char *b) { return a->below(b); }
inline bool operator> (const String &a, char *b) { return a->greater(b); }
inline bool operator<=(const String &a, char *b) { return a->belowOrEqual(b); }
inline bool operator>=(const String &a, char *b) { return a->greaterOrEqual(b); }

inline CharArray *mutate(const String &s) { return const_cast<CharArray *>(s.get()); }

inline MutantString::operator char *() { return const_cast<CharArray *>(s_.get())->chars(); }
inline MutantString::operator CharArray *() { return const_cast<CharArray *>(s_.get()); }
inline CharArray *MutantString::operator->() { return const_cast<CharArray *>(s_.get()); }

inline MutantString mutate(String &&s) { return std::move(s); }

inline Ref<const CharArray>::Ref(const String &b):
    a_(0)
{
    set(b.a_);
}

inline Ref<const CharArray>::Ref(const CharArray *b):
    a_(0)
{
    set(CharArray::copy(b));
}

inline Ref<const CharArray>::Ref(const char *other, int size):
    a_(0)
{
    set(CharArray::copy(other, size));
}

/*inline Ref<const CharArray>::Ref(char ch):
    a_(0)
{
    set(CharArray::create(1));
    a_->at(0) = ch;
}*/

inline Ref<const CharArray>::Ref(int size, char preset):
    a_(0)
{
    auto s = CharArray::create(size);
    mutate(s)->fill(preset);
    set(s);
}

inline Ref<const CharArray>::Ref(const Ref<StringList> &b):
    a_(0)
{
    if (b) set(CharArray::join(b));
}

inline String Ref<const CharArray>::allocate(int size)
{
    return CharArray::allocate(size);
}

inline String Ref<const CharArray>::create(int size)
{
    return CharArray::create(size);
}

inline String Ref<const CharArray>::create(int size, char zero)
{
    return CharArray::create(size, zero);
}

inline String Ref<const CharArray>::copy(const char *data, int size)
{
    return CharArray::copy(data, size);
}

inline String Ref<const CharArray>::copy(const String &b)
{
    return CharArray::copy(b.a_);
}

inline String Ref<const CharArray>::cat(const String &a, const String &b)
{
    return CharArray::cat(a, b);
}

inline String Ref<const CharArray>::join(const StringList *parts, const String &sep)
{
    return CharArray::join(parts, sep);
}

inline String &Ref<const CharArray>::operator=(const String &b)
{
    set(b.a_);
    return *this;
}

inline String &Ref<const CharArray>::operator=(const char *b)
{
    set(CharArray::copy(b));
    return *this;
}

inline Ref<const CharArray>::operator bool() { return a_ && a_->count() > 0; }
inline Ref<const CharArray>::operator bool() const { return a_ && a_->count() > 0; }
inline Ref<const CharArray>::operator const char *() const { return get()->chars(); }
inline Ref<const CharArray>::operator const char *() { return get()->chars(); }

inline Ref<StringList> operator+(const String &a, const String &b) { return StringList::create() << a << b; }
inline Ref<StringList> operator+(Ref<StringList> &a, const String &b) { return a << b; }
inline Ref<StringList> operator+(const String &a, const char *b) { return a + String(b); }
inline Ref<StringList> operator+(const char *a, const String& b) { return String(a) + b; }

inline String &Ref<const CharArray>::operator+=(char b) { String s(1); mutate(s)->at(0) = b; set(CharArray::cat(*this, s)); return *this; }
inline String &Ref<const CharArray>::operator+=(const char *b) { set(CharArray::cat(*this, String(b))); return *this; }
inline String &Ref<const CharArray>::operator+=(const String &b) { set(CharArray::cat(*this, b)); return *this; }
inline String &Ref<const CharArray>::operator+=(const Ref<StringList> &b) { set(String(*this + b)); return *this; }

inline const CharArray *Ref<const CharArray>::get() const
{
    if (!a_) return CharArray::empty();
    return a_;
}

inline void Ref<const CharArray>::set(const CharArray *b)
{
    if (a_ != b) {
        if (b) b->incRefCount();
        if (a_) a_->decRefCount();
        a_ = b;
    }
}

#ifdef QT_CORE_LIB
inline Ref<const CharArray>::operator QString() const
{
    return QString::fromUtf8(get()->chars(), get()->count());
}

inline Ref<const CharArray>::operator QUrl() const
{
    return QUrl::fromLocalFile(QString::fromUtf8(get()->chars(), get()->count()));
}
#endif

} // namespace cc
