/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/bucket>
#include <cc/containers>
#include <cc/pair>

namespace cc {

template<class K, class T>
class multimap;

/** \class MultiMap cc/MultiMap
  * \ingroup container_lowlevel
  * \brief Multi-map data container
  * \tparam K key type
  * \tparam T mapped type
  * \see Map, MultiSet, pair, KeySource, ValueSource
  */
template<class K, class T = K>
class MultiMap: public Object
{
public:
    typedef K key_type; ///< key type
    typedef T mapped_type; ///< value type
    typedef pair<K, T> value_type; ///< item type
    typedef bucket::Weight size_type; ///< index type

    typedef bucket::Iterator<value_type> iterator; ///< iterator type
    typedef bucket::ConstIterator<value_type> const_iterator; ///< constant iterator type

    /** Create a new relation
      * \return new object instance
      */
    static Ref<MultiMap> create() { return new MultiMap; }

    /** Create a copy of another map
      * \param other the list to copy
      * \return new object instance
      */
    static Ref<MultiMap> copy(const MultiMap *other) { return new MultiMap{other}; }

    /** Make a copy of this map
      * \return new object instance
      */
    Ref<MultiMap> copy() const { return MultiMap::copy(this); }

    /// Number of items
    size_type count() const { return tree_->count(); }

    /// Check if an index is valid
    bool has(size_type index) const {
        return 0 <= index && index < count();
    }

    /** Return a reference to an item
      * \param index set index
      * \return reference to the item
      */
    const value_type &at(size_type index) const
    {
        assert(0 <= index && index < count());
        return tree_->at<value_type>(index);
    }

    /// Iterator to the beginning (on first item)
    iterator begin() { return iterator{&tree_}; }

    /// Iterator pointing to the item at \a index
    iterator beginAt(size_type index) { return iterator{tree_, index}; }

    /// Iterator to the end (behind last item)
    iterator end() { return iterator{&tree_, tree_->count()}; }

    /// Constant iterator to the beginning (on first item)
    const_iterator begin() const { return const_iterator{tree_}; }

    /// Constant Iterator pointing to the item at \a index
    const_iterator beginAt(size_type index) const { return const_iterator{tree_, index}; }

    /// Constant iterator to the end (behind last item)
    const_iterator end() const { return const_iterator{tree_, tree_->count()}; }

    /// Check if the relation contains \a key
    bool contains(const key_type &key) const
    {
        return tree_->lookup<value_type>(value_type{key});
    }

    /** Lookup key-value pair by given key
      * \tparam Search search strategy (FindFirst or FindLast)
      * \param key key to search for
      * \param target returns an iterator to a key-value if found
      * \return true if a matching key-value pair was found
      */
    template<class Search = FindFirst>
    bool find(const key_type &key, const_iterator *target) const
    {
        size_type index = 0;
        bucket::Leaf<value_type> *node = nullptr;
        unsigned egress = 0;
        bool found = tree_->lookup<value_type, Search>(value_type{key}, &index, &node, &egress);
        if (target) *target = const_iterator{tree_, index, node, egress};
        return found;
    }

    /** Lookup key-value pair by given key
      * \tparam Search search strategy (FindFirst or FindLast)
      * \param key key to search for
      * \param target returns an iterator to a key-value if found
      * \return true if a matching key-value pair was found
      */
    template<class Search = FindFirst>
    bool find(const key_type &key, iterator *target)
    {
        size_type index = 0;
        bucket::Leaf<value_type> *node = nullptr;
        unsigned egress = 0;
        bool found = tree_->lookup<value_type, Search>(value_type{key}, &index, &node, &egress);
        if (target) *target = iterator{tree_, index, node, egress};
        return found;
    }

    /** Insert a new key-value pair
      * \param key search key
      * \param value new value
      */
    void insert(const key_type &key, const mapped_type &value)
    {
        bucket::Leaf<value_type> *target = nullptr;
        unsigned egress = 0;
        value_type item{key, value};
        bool found = tree_->lookup<value_type, FindLast>(item, nullptr, &target, &egress);
        tree_->push<value_type>(target, egress + found, item);
    }

    /** Remove all key-value pairs matching a search key
      * \param key search key
      * \return number of items removed
      */
    size_type remove(const key_type &key)
    {
        size_type removalCount = 0;
        iterator target;
        find(key, &target);
        while (target && target->key() == key) {
            remove(target);
            ++removalCount;
        }
        return removalCount;
    }

    /** Remove \a item at given \a target position */
    void remove(iterator &target)
    {
        tree_->popAndStep(target);
    }

    /// Remove item at given \a index
    void removeAt(size_type index)
    {
        assert(0 <= index && index < count());
        tree_->pop<value_type>(index);
    }

    /// Modify value of the key-value mapping at \a index
    void setValueAt(size_type index, const mapped_type &value)
    {
        assert(0 <= index && index < count());
        tree_->at<value_type>(index)->setValue(value);
    }

    /// Return the first item
    const value_type &first() const { return tree_->first<value_type>(); }

    /// Return the last item
    const value_type &last() const { return tree_->last<value_type>(); }

    /// Reset to an empty relation
    void deplete() { tree_->deplete<value_type>(); }

    /** \name Syntax sugar
      */
    ///@{
    /** Insert \a item to the set */
    void operator<<(const value_type& item) { insert(item->key(), item->value()); }

    /** Remove and return first item */
    void operator>>(value_type& item) { if (count() > 0) { item = first(); removeAt(0); } }
    ///@}

protected:
    friend class bucket::Internals;
    friend class Local<MultiMap>;
    friend class multimap<K, T>;

    MultiMap() = default;

    MultiMap(const MultiMap *other)
    {
        tree_->populate<value_type>(other);
    }

    ~MultiMap() { tree_->deplete<value_type>(); }

    Local<bucket::Tree> tree_;
};

template<class K, class T>
bool operator==(const MultiMap<K, T> &a, const MultiMap<K, T> &b) { return container::compare(&a, &b) == 0; }

template<class K, class T>
bool operator!=(const MultiMap<K, T> &a, const MultiMap<K, T> &b) { return container::compare(&a, &b) != 0; }

template<class K, class T>
bool operator<(const MultiMap<K, T> &a, const MultiMap<K, T> &b) { return container::compare(&a, &b) < 0; }

template<class K, class T>
bool operator>(const MultiMap<K, T> &a, const MultiMap<K, T> &b) { return container::compare(&a, &b) > 0; }

template<class K, class T>
bool operator<=(const MultiMap<K, T> &a, const MultiMap<K, T> &b) { return container::compare(&a, &b) <= 0; }

template<class K, class T>
bool operator>=(const MultiMap<K, T> &a, const MultiMap<K, T> &b) { return container::compare(&a, &b) >= 0; }

} // namespace cc
