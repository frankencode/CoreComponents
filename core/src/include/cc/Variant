/*
 * Copyright (C) 2007-2018 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <new>
#include <cc/bitmask>
#include <cc/Color>
#include <cc/Version>
#include <cc/String>
#include <cc/Map>

namespace cc {

class Variant;

typedef List<Variant> VariantList;
typedef Map<String, Variant> VariantMap;

/** \internal
  * \brief Variant cast policy
  * \see Variant::cast()
  */
template<class T, bool IsPointer>
class VariantCast {};

/** Type of a Variant value
  * \see Variant::type(), Variant::itemType()
  */
enum class VariantType: uint16_t
{
    Undefined = 0,
    Int       = 1,
    Bool      = 2 | Int,
    Float     = 4,
    Color     = 8,
    Version   = 16,
    Object    = 32,
    String    = 64 | Object,
    List      = 128 | Object,
    Map       = 256 | Object,
    Any       = 511
};

CC_BITMASK(VariantType, uint16_t)

/** \class Variant cc/Variant
  * \ingroup misc
  * \brief Duck-typed value
  *
  * A Variant can represent different types.
  * The type of a Variant is defined implicitly at construction or assignment.
  * Variants automatically cast to bool, int, float if the Variant type is compatible
  * with the target type requested by an expression.
  * In debug mode a DebugException will be thrown on illegal type casts.
  * Variants can be savely passed by value.
  */
class Variant
{
public:
    /// Floating point number type used for storing real values inside an Variant
    typedef float Float;

    inline static VariantType type(const Variant &value) { return value.type_; }
    inline static VariantType itemType(const Variant &value) { return value.itemType_; }
    static const char *typeName(VariantType type, VariantType itemType = VariantType::Undefined);

    /** Heuristically detect the type and read a variant value from a string
      * \param s text representation of the variant value
      * \return variant value
      */
    static Variant read(String s);

    template<class T>
    inline static T cast(const Variant &value) { return VariantCast<T, CC_IS_POINTER(T)>::cast(value); }

    Variant():              type_(VariantType::Undefined), itemType_(VariantType::Undefined)                         {}
    Variant(int value):     type_(VariantType::Int),       itemType_(VariantType::Undefined), int_(value)            {}
    Variant(bool value):    type_(VariantType::Bool),      itemType_(VariantType::Undefined), int_(value)            {}
    Variant(float value):   type_(VariantType::Float),     itemType_(VariantType::Undefined), float_(value)          {}
    Variant(double value):  type_(VariantType::Float),     itemType_(VariantType::Undefined), float_(value)          {}
    Variant(Color value):   type_(VariantType::Color),     itemType_(VariantType::Undefined), word_(value->toWord()) {}
    Variant(Version value): type_(VariantType::Version),   itemType_(VariantType::Undefined), word_(value->toWord()) {}

    Variant(const char *value):   type_(VariantType::String), itemType_(VariantType::Undefined) { initRef(mutate(String(value))); }
    Variant(const String &value): type_(VariantType::String), itemType_(VariantType::Undefined) { initRef(mutate(value)); }
    template<class T>
    Variant(const Ref<T> &value): type_(VariantType::Object), itemType_(VariantType::Undefined) { initRef(value.get()); }
    template<class T>
    Variant(const T *value): Variant(Ref<T>(value)) {}
    template<class T>
    Variant(T *value): Variant(Ref<T>(value)) {}

    Variant(const Ref< List<int> > &value):     type_(VariantType::List), itemType_(VariantType::Int)     { initRef(value); }
    Variant(const Ref< List<bool> > &value):    type_(VariantType::List), itemType_(VariantType::Bool)    { initRef(value); }
    Variant(const Ref< List<float> > &value):   type_(VariantType::List), itemType_(VariantType::Float)   { initRef(value); }
    Variant(const Ref< List<Color> > &value):   type_(VariantType::List), itemType_(VariantType::Color)   { initRef(value); }
    Variant(const Ref< List<Version> > &value): type_(VariantType::List), itemType_(VariantType::Version) { initRef(value); }
    Variant(const Ref<StringList> &value):      type_(VariantType::List), itemType_(VariantType::String)  { initRef(value); }
    Variant(const Ref<VariantList> &value):     type_(VariantType::List), itemType_(VariantType::Any)     { initRef(value); }
    Variant(const Ref<VariantMap> &value):      type_(VariantType::List), itemType_(VariantType::Any)     { initRef(value); }
    template<class T>
    Variant(const List<T> *value): Variant(Ref<List<T>>(value)) {}
    template<class T>
    Variant(List<T> *value): Variant(Ref<List<T>>(value)) {}

    Variant(const Variant &b): type_(VariantType::Undefined), itemType_(VariantType::Undefined) { *this = b; }

    ~Variant() { if (+(type_ & VariantType::Object)) killRef(); }

    inline const Variant &operator=(bool value)          { type_ = VariantType::Bool; int_ = value; return *this; }
    inline const Variant &operator=(int value)           { type_ = VariantType::Int;  int_ = value; return *this; }
    inline const Variant &operator=(float value)         { type_ = VariantType::Float; float_ = value; return *this; }
    inline const Variant &operator=(double value)        { type_ = VariantType::Float; float_ = value; return *this; }
    inline const Variant &operator=(Color value)         { type_ = VariantType::Color; word_ = value->toWord(); return *this; }
    inline const Variant &operator=(Version value)       { type_ = VariantType::Version; word_ = value->toWord(); return *this; }
    inline const Variant &operator=(const char *value)   { return *this = Variant(value); }
    inline const Variant &operator=(const String &value) { return *this = Variant(value); }
    template<class T>
    inline const Variant &operator=(const Ref<T> &value) { return *this = Variant(value); }

    inline const Variant &operator=(const Variant &b) {
        if (+(type_ & VariantType::Object)) killRef();
        type_ = b.type_;
        itemType_ = b.itemType_;
        if (+(b.type_ & VariantType::Object))
            initRef(b.ref().get());
        else if (+b.type_)
            int_ = b.int_;
        return *this;
    }

    inline operator bool() const {
        if (!+type_) return bool();
        CC_ASSERT2(+(type_ & VariantType::Int), illegalConversion);
        return int_;
    }
    inline operator int() const {
        if (!+type_) return int();
        CC_ASSERT2(+(type_ & VariantType::Int), illegalConversion);
        return int_;
    }
    inline operator float() const {
        if (!+type_) return float();
        if (+(type_ & VariantType::Int)) return int_;
        CC_ASSERT2(+(type_ & VariantType::Float), illegalConversion);
        return float_;
    }
    inline operator Color() const {
        if (!+type_) return Color();
        CC_ASSERT2(+(type_ & VariantType::Color), illegalConversion);
        return Color::fromWord(word_);
    }
    inline operator Version() const {
        if (!+type_) return Version();
        CC_ASSERT2(+(type_ & VariantType::Version), illegalConversion);
        return Version::fromWord(word_);
    }
    inline operator String() const {
        if (!+type_) return String();
        CC_ASSERT2(+(type_ & VariantType::String), illegalConversion);
        return Variant::cast<CharArray *>(*this);
    }

    template<class T>
    inline operator Ref<T>() const {
        if (!+type_) return Ref<T>();
        CC_ASSERT2(+(type_ & VariantType::Object), illegalConversion);
        return Variant::cast<T *>(*this);
    }

    bool operator==(const Variant &b) const;
    bool operator<(const Variant &b) const;

    inline bool operator>(const Variant &b) const  { return b < *this; }
    inline bool operator!=(const Variant &b) const { return !(*this == b); }
    inline bool operator<=(const Variant &b) const { return (*this < b) || (*this == b); }
    inline bool operator>=(const Variant &b) const { return (b < *this) || (*this == b); }

private:
    template<class, bool>
    friend class VariantCast;

    friend String str(const Variant &x);
    friend int type(const Variant &value);
    friend int itemType(const Variant &value);

    static constexpr const char *illegalConversion = "Illegal Variant conversion";

    template<class U>
    friend U *cast(const Variant &value);

    inline void initRef(Object *object = 0) {
        new(dummy_)Ref<Object>(object);
    }
    inline void killRef() {
        ref().~Ref<Object>();
    }
    inline void setRef(Object *object) const {
        ref() = object;
    }
    inline Ref<Object> &ref() const {
        return *union_cast< Ref<Object> *>(dummy_);
    }

    VariantType type_;
    VariantType itemType_;
    union {
        int32_t int_;
        uint32_t word_;
        float32_t float_;
        mutable char dummy_[sizeof(Ref<Object>)];
    };
};

template<class T>
class VariantCast<T, true> {
public:
    inline static T cast(const Variant &value) {
        typedef typename CC_DEREF(T) U;
        return (+(Variant::type(value) & VariantType::Object)) ? Object::cast<U *>(value.ref().get()) : nullptr;
    }
};

template<class T>
class VariantCast<T, false> {
public:
    inline static T cast(const Variant &value) {
        return T(value);
    }
};

template<>
class VariantCast<String, false> {
public:
    inline static String cast(const Variant &value) {
        return Variant::cast<CharArray *>(value);
    }
};

template<>
class VariantCast<Color, false> {
public:
    inline static Color cast(const Variant &value) {
        return Color::fromWord(value.word_);
    }
};

template<>
class VariantCast<Version, false> {
public:
    inline static Version cast(const Variant &value) {
        return Version::fromWord(value.word_);
    }
};

String str(const Variant &x);

} // namespace cc
