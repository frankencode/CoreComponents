/*
 * Copyright (C) 2007-2018 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/string>

namespace cc {

class variant;

/** \class color cc/color
  * \ingroup misc
  * \brief 32-bit ARGB color value
  */
class color
{
public:
    /** Convenience color values
      * @{
      */
    static const color transparent;
    static const color black;
    static const color white;
    static const color red;
    static const color green;
    static const color blue;
    /** @}
      */

    /** Construct an invalid color
      */
    color():
        instance_{0x00FFFFFFu}
    {}

    /** Construct a valid color from a 32-bit word \a w
      */
    color(uint32_t w):
        instance_{w | (w < 0x1000000u ? 0xFF000000u : 0u)}
    {}

    /** \copydoc color(const string &s)
      */
    explicit color(const char *s)
    {
        bool ok = false;
        *this = parse(s, &ok);
        if (!ok) *this = color{};
    }

    /** Construct a color from a color literal or name \a s
      * \param s color specification to parse
      * %color literals can be either SVG color names (e.g. 'AliceBlue') or literal RGB tuples (\#RRGGBB, \#RRGGBBAA, \#RGB, \#RGBA).
      */
    explicit color(const string &s)
    {
        bool ok = false;
        *this = parse(s, &ok);
        if (!ok) *this = color{};
    }

    /** Construct a color from a color value stored in a variant \a v
      */
    color(const variant &v);

    /** Compose a color from its components
      * \param r red component (0..0xFF)
      * \param g green component (0..0xFF)
      * \param b blue component (0..0xFF)
      * \param a alpha value / opacity (0..0xFF)
      */
    template<class T>
    color(T r, T g, T b, T a = 0xFF):
        instance_{r, g, b, a}
    {}

    /** Construct a color from a palette value \a v
      */
    template<class T>
    explicit color(T v):
        color{static_cast<uint32_t>(v)}
    {}

    /** \copydoc color(const char *)
      * \param ok return true if \a s is a valid color literal or name
      */
    static color parse(const char *s, bool *ok = nullptr);

    /** Construct a color from a 32-bit word \a w
      */
    static color fromWord(uint32_t w) { color c; c->w_ = w; return c; }

    /** Return the full color with hue \a h
      * \param h hue in range [0, 360]
      */
    static color fromHue(double h) { return fromHsv(h, 1., 1.); }

    /** Construct color from a HSV
      * \param h hue in range [0, 360]
      * \param s saturation in range [0, 1]
      * \param v value in range [0, 1]
      */
    static color fromHsv(double h, double s, double v);

    /** Construct color from a HSL
      * \param h hue in range [0, 360]
      * \param s saturation in range [0, 1]
      * \param l luminance in range [0, 1]
      */
    static color fromHsl(double h, double s, double l);

    /** Alpha-blend color \a a over color \a b and return result
      */
    static color blend(color a, color b)
    {
        b->applyOver(a);
        return b;
    }

    class Instance {
    public:
        /** Check if color \c is valid
          * A color is considered invalid, if alpha is zero and red, green or blue is non-zero.
          */
        bool isValid() const {
            return !(
                alpha() == 0 && (
                    red()   != 0 ||
                    green() != 0 ||
                    blue()  != 0
                )
            );
        }

        /** Convenience function to check if \a c is a fully opaque color
          */
        bool isOpaque() const {
            return alpha() == 0xFF;
        }

        /** Getters for individual color components
          * @{
          */
        uint32_t alpha() const { return component<AlphaShift>(); }
        uint32_t red  () const { return component<RedShift  >(); }
        uint32_t green() const { return component<GreenShift>(); }
        uint32_t blue () const { return component<BlueShift >(); }
        /** @}
          */

        /** Alpha-blend color \a b over this color
          */
        void applyOver(color b);

        /** Mix another color \a b into this color
          */
        void mixIn(color b, int percent);

        /** Return a lighter version of this color
          */
        color lighter(int percent) const {
            color c = color::fromWord(w_);
            c->mixIn(color::white, percent);
            return c;
        }

        /** Return a darker version of this color
          */
        color darker(int percent) const {
            color c = color::fromWord(w_);
            c->mixIn(color::black, percent);
            return c;
        }

        /** Translate this color from non-premultiplied to the premultiplied representation
          */
        color premultiplied() const
        {
            color c = color::fromWord(w_);
            c->premultiply();
            return c;
        }

        /** Translate this color from premultiplied to non-premultiplied representation
          */
        color normalized() const
        {
            color c = color::fromWord(w_);
            c->normalize();
            return c;
        }

        /** \copydoc premultiplied()
          */
        void premultiply()
        {
            uint32_t h = w_;
            uint16_t a = component<AlphaShift, uint16_t>(h);
            if (a == 0 || a == 0xFF) return;
            typedef uint16_t v4ui16 __attribute__((vector_size(8)));
            v4ui16 v {
                component<RedShift,   uint16_t>(h),
                component<GreenShift, uint16_t>(h),
                component<BlueShift,  uint16_t>(h),
                0
            };
            v = (a * v) / 0xFF;
            w_ = compose(v[0], v[1], v[2], a);
        }

        /** \copydoc normalized()
          */
        void normalize()
        {
            uint32_t h = w_;
            uint16_t a = component<AlphaShift, uint16_t>(h);
            if (a == 0 || a == 0xFF) return;
            typedef uint16_t v4ui16 __attribute__((vector_size(8)));
            v4ui16 v {
                component<RedShift,   uint16_t>(h),
                component<GreenShift, uint16_t>(h),
                component<BlueShift,  uint16_t>(h),
                0
            };
            v = (0xFF * v) / a;
            w_ = compose(v[0], v[1], v[2], a);
        }

        /// convert to a 32-bit word
        uint32_t toWord() const { return w_; }

        /// Stringify this color
        string toString() const;

    private:
        friend class color;

        Instance()
        {}

        Instance(uint32_t w):
            w_{w}
        {}

        template<class T>
        Instance(T r, T g, T b, T a = 0xFF):
            w_{compose(r, g, b, a)}
        {}

        enum {
            AlphaShift = 24,
            RedShift   = 16,
            GreenShift =  8,
            BlueShift  =  0
        };

        template<int Shift, class T = uint32_t>
        T component() const { return component<Shift, T>(w_); }

        template<int Shift, class T = uint32_t>
        static T component(uint32_t w) { return (w >> Shift) & 0xFF; }

        template<class T>
        static uint32_t compose(T r, T g, T b, T a = 0xFF) {
            return
                (uint32_t(a) << AlphaShift) |
                (uint32_t(r) << RedShift  ) |
                (uint32_t(g) << GreenShift) |
                (uint32_t(b) << BlueShift ) ;
        };

        uint32_t w_;
    };

    /** Create a color tone from this color with \a percent opacity
      */
    color operator()(int percent) const
    {
        return color{
            (*this)->red(),
            (*this)->green(),
            (*this)->blue(),
            uint32_t(percent) * 0xFF / 100
        };
    }

    /** Comparism operators
      * @{
      */
    bool operator==(const color &b) const { return (*this)->w_ == b->w_; }
    bool operator!=(const color &b) const { return (*this)->w_ != b->w_; }
    /** @}
      */

    const Instance *operator->() const { return &instance_; }
    Instance *operator->() { return &instance_; }

    explicit operator bool() const { return (*this)->isValid(); }

private:
    friend class variant;

    Instance instance_;
};

/// Stringify color \a c
inline string str(const color &c) { return c->toString(); }

} // namespace cc
