/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/bucket>
#include <cc/containers>

namespace cc {

template<class T>
class Set: public Object
{
public:
    /// Index type
    typedef bucket::Weight Index;

    /// Item type
    typedef T Item;

    /** Create a new set
      * \return new object instance
      */
    static Ref<Set> create() { return new Set; }

    /// Number of items
    Index count() const { return tree_->count(); }

    /// Check if an index is valid
    bool has(Index index) const {
        return 0 <= index && index < count();
    }

    /** Return a reference to an item
      * \param index set index
      * \return reference to the item
      */
    const Item &at(Index index) const
    {
        assert(0 <= index && index < count());
        return tree_->at<Item>(index);
    }

    /** Check if the set contains a given item
      * \param item item value
      * \return true if the set contains the given item
      */
    bool contains(const Item &item) const
    {
        return tree_->lookup<Item>(item);
    }

    /** Insert a new item if no item with the same value exists already.
      * \return true if the new item was inserted successfully
      */
    bool insert(const Item &item)
    {
        bool success = false;
        bucket::Leaf<Item> *target = nullptr;
        unsigned egress = 0;
        if (!tree_->lookup<Item>(item, nullptr, &target, &egress)) {
            tree_->push<Item>(target, egress, item);
            success = true;
        }
        return success;
    }

    /** Remove an item from the set
      * \param item item value
      * \return true if the matching item was found and removed
      */
    bool remove(const Item &item)
    {
        bool success = false;
        bucket::Leaf<Item> *target = nullptr;
        unsigned egress = 0;
        if (tree_->lookup<Item>(item, nullptr, &target, &egress)) {
            tree_->pop<Item>(target, egress);  // FIXME: performance
            success = true;
        }
        return success;
    }

    /** \name Iterators
      * @{
      */
    typedef bucket::ConstIterator<Item> Iterator;
    typedef bucket::ConstIterator<Item> ConstIterator;

    Iterator begin() { return ConstIterator{tree_}; }
    Iterator end() { return ConstIterator{}; }
    ConstIterator begin() const { return ConstIterator{tree_}; }
    ConstIterator end() const { return ConstIterator{}; }

    template<class Pattern>
    ConstIterator first(const Pattern &pattern) const {
        Index index = 0;
        bucket::Leaf<Item> node = nullptr;
        unsigned egress = 0;
        tree_->lookupFirst(pattern, &index, &node, &egress);
        return ConstIterator{tree_, index, node, egress};
    }

    template<class Pattern>
    ConstIterator last(const Pattern &pattern) const {
        Index index = 0;
        bucket::Leaf<Item> node = nullptr;
        unsigned egress = 0;
        tree_->lookupLast(pattern, &index, &node, &egress);
        return ConstIterator{tree_, index, node, egress};
    }
    /** @}
      */

    /** \internal
      * @{
      */
    typedef Iterator iterator;
    typedef ConstIterator const_iterator;
    /** @}
      */

    /// Return the smallest item
    const Item &first() const { return tree_->first<Item>(); }

    /// Return the biggest item
    const Item &last() const { return tree_->last<Item>(); }

    /// Reset this set to an empty set
    void deplete() { tree_->deplete<Item>(); }

private:
    friend class bucket::Internals;
    friend class Local<Set>;

    Set() = default;

    Set(const Set *other)
    {
        tree_->populate<Item>(other);
    }

    ~Set() { tree_->deplete<Item>(); }

    template<class Pattern>
    bool lookup(const Pattern &pattern, Index *finalIndex = nullptr) const
    {
        return tree_->lookup<Item>(pattern, finalIndex);
    }

    Local<bucket::Tree> tree_;
};

template<class T>
bool operator==(const Set<T> &a, const Set<T> &b) { return container::compare(a, b) == 0; }

template<class T>
bool operator!=(const Set<T> &a, const Set<T> &b) { return container::compare(a, b) != 0; }

template<class T>
bool operator<(const Set<T> &a, const Set<T> &b) { return container::compare(a, b) < 0; }

template<class T>
bool operator>(const Set<T> &a, const Set<T> &b) { return container::compare(a, b) > 0; }

template<class T>
bool operator<=(const Set<T> &a, const Set<T> &b) { return container::compare(a, b) <= 0; }

template<class T>
bool operator>=(const Set<T> &a, const Set<T> &b) { return container::compare(a, b) >= 0; }

} // namespace cc
