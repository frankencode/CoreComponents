/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/bucket>
#include <cc/containers>

namespace cc {

template<class T>
class Set: public Object
{
public:
    /// Item type
    typedef T Item;

    /// Index type
    typedef bucket::Weight Index;

    /** Create a new set
      * \return new object instance
      */
    static Ref<Set> create() { return new Set; }

    /// Number of items
    Index count() const { return tree_->count(); }

    /// Check if an index is valid
    bool has(Index index) const {
        return 0 <= index && index < count();
    }

    /// Return a reference to the item at \a index
    const Item &at(Index index) const
    {
        assert(0 <= index && index < count());
        return tree_->at<Item>(index);
    }

    /// Check if the set contains \a item
    bool contains(const Item &item) const
    {
        return tree_->lookup<Item>(item);
    }

    /** Insert a new item if no item with the same value exists already
      * \param item item value
      * \return true if the new item was inserted successfully
      */
    bool insert(const Item &item, Item *currentItem = nullptr, Index *index = nullptr)
    {
        bucket::Leaf<Item> *target = nullptr;
        unsigned egress = 0;
        bool found = tree_->lookup<Item>(item, index, &target, &egress);
        if (!found) tree_->push<Item>(target, egress, item);
        else if (currentItem) *currentItem = target->at(egress);
        return !found;
    }

    /** Remove the given \a item from the set
      * \param item item value
      * \return true if a matching item was found and removed
      */
    bool remove(const Item &item)
    {
        bucket::Leaf<Item> *target = nullptr;
        unsigned egress = 0;
        bool found = tree_->lookup<Item>(item, nullptr, &target, &egress);
        if (found) tree_->pop<Item>(target, egress);
        return found;
    }

    /// Remove item at given \a index
    void removeAt(Index index)
    {
        assert(0 <= index && index < count());
        tree_->pop<Item>(index);
    }

    /** \name Iterators
      * @{
      */
    typedef bucket::ConstIterator<Item> Iterator;
    typedef bucket::ConstIterator<Item> ConstIterator;

    Iterator begin() { return ConstIterator{tree_}; }
    Iterator end() { return ConstIterator{tree_, tree_->count()}; }
    Iterator beginAt(Index index) { return Iterator{tree_, index}; }

    ConstIterator begin() const { return ConstIterator{tree_}; }
    ConstIterator end() const { return ConstIterator{tree_, tree_->count()}; }
    ConstIterator beginAt(Index index) const { return ConstIterator{tree_, index}; }

    ConstIterator begin(const Item &item) const
    {
        Index index = 0;
        bucket::Leaf<Item> *node = nullptr;
        unsigned egress = 0;
        tree_->lookupFirst(item, &index, &node, &egress);
        return ConstIterator{tree_, index, node, egress};
    }

    ConstIterator end(const Item &item) const
    {
        Index index = 0;
        bucket::Leaf<Item> *node = nullptr;
        unsigned egress = 0;
        tree_->lookupLast(item, &index, &node, &egress);
        ConstIterator iterator{tree_, index, node, egress};
        if (iterator) ++iterator;
        return iterator;
    }
    /** @}
      */

    /** \internal
      * @{
      */
    typedef Iterator iterator;
    typedef ConstIterator const_iterator;
    /** @}
      */

    /// Return the smallest item
    const Item &first() const { return tree_->first<Item>(); }

    /// Return the biggest item
    const Item &last() const { return tree_->last<Item>(); }

    /// Reset to an empty set
    void deplete() { tree_->deplete<Item>(); }

private:
    friend class bucket::Internals;
    friend class Local<Set>;

    Set() = default;

    Set(const Set *other)
    {
        tree_->populate<Item>(other);
    }

    ~Set() { tree_->deplete<Item>(); }

    Local<bucket::Tree> tree_;
};

template<class T>
bool operator==(const Set<T> &a, const Set<T> &b) { return container::iteratorCompare(a, b) == 0; }

template<class T>
bool operator!=(const Set<T> &a, const Set<T> &b) { return container::iteratorCompare(a, b) != 0; }

template<class T>
bool operator<(const Set<T> &a, const Set<T> &b) { return container::iteratorCompare(a, b) < 0; }

template<class T>
bool operator>(const Set<T> &a, const Set<T> &b) { return container::iteratorCompare(a, b) > 0; }

template<class T>
bool operator<=(const Set<T> &a, const Set<T> &b) { return container::iteratorCompare(a, b) <= 0; }

template<class T>
bool operator>=(const Set<T> &a, const Set<T> &b) { return container::iteratorCompare(a, b) >= 0; }

} // namespace cc
