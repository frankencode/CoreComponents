/*
 * Copyright (C) 2007-2018 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Queue>
#include <cc/Mutex>
#include <cc/Guard>
#include <cc/WaitCondition>

namespace cc {

/** \class Channel cc/Channel
  * \ingroup concurrency
  * \brief Inter-thread communication channel
  * \tparam T item type
  * \todo provide wait(), send(), read() convenience methods
  * \todo provide Source interface / iteration
  */
template<class T>
class Channel
{
public:
    class Instance: public Object
    {
    public:
        /// \copydoc QueueInstance::pushBack()
        void pushBack(const T &item)
        {
            Guard<Mutex> guard{mutex_};
            queue_->pushBack(item);
            notEmpty_->signal();
        }

        /// \copydoc QueueInstance::pushFront()
        void pushFront(const T &item)
        {
            Guard<Mutex> guard{mutex_};
            queue_->pushFront(item);
            notEmpty_->signal();
        }

        /// \copydoc QueueInstance::popBack(T *)
        const T &popBack(T *item)
        {
            Guard<Mutex> guard{mutex_};
            while (queue_->count() == 0)
                notEmpty_->wait(mutex_);
            return queue_->popBack(item);
        }

        /// \copydoc QueueInstance::popFront(T *)
        const T &popFront(T *item)
        {
            Guard<Mutex> guard{mutex_};
            while (queue_->count() == 0)
                notEmpty_->wait(mutex_);
            return queue_->popFront(item);
        }

        /// \copydoc QueueInstance::popBack()
        T popBack() { T h; return popBack(&h); }

        /// \copydoc QueueInstance::popFront()
        T popFront() { T h; return popFront(&h); }

        /// Wait for the channel to become not empty
        void waitForNotEmpty()
        {
            Guard<Mutex> guard{mutex_};
            while (queue_->count() == 0)
                notEmpty_->wait(mutex_);
        }

        /** Wait for the channel to become not empty
          * \param timeout absolute timeout (e.g. System::now() + 10)
          * \return true if the channel contains at least one item before timeout
          */
        bool waitForNotEmptyUntil(double timeout)
        {
            Guard<Mutex> guard{mutex_};
            while (queue_->count() == 0) {
                if (!notEmpty_->waitUntil(timeout, mutex_))
                    return false;
            }
            return true;
        }

        /** Remove an item from the end of the queue before a certain timeout
          * \param timeout absolute timeout (e.g. System::now() + 10)
          * \param item optionally return the item value
          * \return true if an item was available before reaching the timeout, otherwise false
          */
        bool popBackBefore(double timeout, T *item)
        {
            Guard<Mutex> guard{mutex_};
            while (queue_->count() == 0) {
                if (!notEmpty_->waitUntil(timeout, mutex_))
                    return false;
            }
            queue_->popBack(item);
            return true;
        }

        /** Remove an item from the head of the queue before a certain timeout
          * \param timeout absolute timeout (e.g. System::now() + 10)
          * \param item optionally return the item value
          * \return true if an item was available before reaching the timeout, otherwise false
          */
        bool popFrontBefore(double timeout, T *item)
        {
            Guard<Mutex> guard{mutex_};
            while (queue_->count() == 0) {
                if (!notEmpty_->waitUntil(timeout, mutex_))
                    return false;
            }
            queue_->popFront(item);
            return true;
        }

        /// \copydoc pushBack()
        void push(const T &item) { return pushBack(item); }

        /// \copydoc popFront(T *)
        const T &pop(T *item) { return popFront(item); }

        /// \copydoc popFront()
        T pop() { return popFront(); }

        /// \copydoc popFrontBefore()
        bool popBefore(double timeout, T *item = nullptr) { return popFrontBefore(timeout, item); }

        /// Return number of queued items
        int count() const { Guard<Mutex> guard{mutex_}; return queue_->count(); }

        /** Connect with another channel
          * \param other other channel to connect to
          * \return pointer to the new connecting shared channel
          */
        Channel *connect(Channel *other)
        {
            other->queue_ = queue_;
            other->notEmpty_ = notEmpty_;
            other->mutex_ = mutex_;
            return this;
        }

    private:
        Mutex mutex_;
        WaitCondition notEmpty_;
        Queue<T> queue_;
    };

    /** Create a new channel
      */
    Channel():
        instance_{new Instance}
    {}

    const Instance *operator->() const { return instance_; }
    Instance *operator->() { return instance_; }

private:
    Channel &operator=(const Channel &other);

    Ref<Instance> instance_;
};

} // namespace cc
