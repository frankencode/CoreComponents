/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/string>
#include <cc/variant>
#include <cc/str>

namespace cc {

class Stream;
template<class> class Queue;

/** \addtogroup formatted_io
  * \{
  */

/** \class FormatSignal cc/format
  * \brief Type for formatting signals
  */
class FormatSignal {};

extern FormatSignal nl; ///< The newline formatting signal causes a newline but no output flushing.
extern FormatSignal flush; ///< The flush formatting signal causes the aggregated text to be flushed and written to the associated output stream (if any).

/** \class format cc/format
  * \brief Text formatting helper
  */
class format: public Ref<StringList>
{
public:
    /** Construct a new string formatting helper
      * \param pattern formatting pattern containing injection placeholders ("%%")
      * \param stream output stream to write the resulting text to (optional)
      */
    format(const string &pattern, Stream *stream = nullptr);

    /** Construct a new string formatting helper
      * \param stream output stream to write the resulting text to (optional)
      */
    format(Stream *stream = nullptr);

    /// Low-level destructor
    ~format();

    /// Copy-constructor
    format(const format &b);

    /// Assignment operator
    format &operator=(const format &b);

    /// Append or inject a string to the output text
    format &operator<<(const string &s);

    /** %Process a special formatting signal
      * \param s formatting signal (nl or flush)
      */
    format &operator<<(const FormatSignal &s);

    /** Append or inject an element x to the output text
      * \param x anything which can be converted to a string via str(x)
      */
    template<class T>
    format &operator<<(const T &x) {
        if (isNull_) return *this;
        return *this << str(x);
    }

    static const StringList *toStringList(const format &f) { return f.get(); }

private:
    typedef Ref<StringList> Super;

    void flush();

    Ref<Stream> stream_;
    bool isNull_;
    Ref< Queue<int> > placeHolder_;
    string lastInsert_;
    int lastPosition_;
};

/** \class NullFormat cc/format
  * \brief Zero storage formatting output sink
  */
class NullFormat {
public:
    /// Drop output
    template<class T>
    inline const NullFormat &operator<<(T) const { return *this; }
};

/** \}
  */

} // namespace cc
