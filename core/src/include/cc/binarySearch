/*
 * Copyright (C) 2018-2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <assert.h>
#include <cc/debug>

namespace cc {

/** \brief Binary search in a sorted list of items
  * \param items the sorted list of items
  * \param pattern pattern to search for
  * \param finalIndex return the final index of the search
  * \return true if a matching item was found, false otherwise
  */
template<
    class SortedItems,
    class Pattern = typename SortedItems::Item,
    class Index = typename SortedItems::Index
>
bool binarySearch(
    const SortedItems *items,
    const Pattern &pattern,
    Index *finalIndex
) {
    assert(items->count() > 0);
    #if 0 // ndef NDEBUG
    if (pattern < items->at(0)) {
        CC_INSPECT(items->count());
        CC_INSPECT(items->at(0));
        CC_INSPECT(pattern);
    }
    if (items->at(items->count() - 1) < pattern) {
        CC_INSPECT(items->count());
        CC_INSPECT(items->at(items->count() - 1));
        CC_INSPECT(pattern);
    }
    #endif
    assert(!(pattern < items->at(0) || items->at(items->count() - 1) < pattern));

    Index firstIndex = 0;
    Index lastIndex = items->count() - 1;
    while (true) {
        Index middleIndex = (firstIndex + lastIndex) >> 1;
        if (middleIndex == firstIndex) break;
        if (items->at(middleIndex) < pattern)
            firstIndex = middleIndex;
        else
            lastIndex = middleIndex;
    }

    if (!(items->at(firstIndex) < pattern)) {
        *finalIndex = firstIndex;
        return true;
    }

    if (!(pattern < items->at(lastIndex))) {
        *finalIndex = lastIndex;
        return true;
    }

    *finalIndex = lastIndex;
    return false;
}

} // namespace cc
