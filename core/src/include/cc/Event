/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Queue>
#include <functional>

namespace cc {

template<class T>
class Event
{
public:
    class Instance {
    public:
        template<class F>
        void connect(const F &f) { queue_ << f; }
        void propagate(const T &value) const { for (auto &f: queue_) if (f(value)) break; }

        bool hasConsumers() const { return queue_->count() > 0; }
        void disband() { queue_->deplete(); }

    private:
        friend class Event;

        Instance() = default;

        Queue<std::function<bool(T)>> queue_;
    };

    Event() = default;

    template<class F>
    Event &operator>>(const F &f) { (*this)->connect(f); return *this; }

    void operator()(const T &value) const { (*this)->propagate(); }

    Instance *operator->() { return &instance_; }
    const Instance *operator->() const { return &instance_; }

private:
    Instance instance_;
};

} // namespace cc
