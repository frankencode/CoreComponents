/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <functional>
#include <cc/Object>

namespace cc {

class PropertyBinding;

class Event
{
public:
    Event() {}

    class Instance {
    public:
        Instance() {}

        template<class F>
        inline void listen(const F &f)
        {
            first_ = Node::create(f, first_);
        }

        inline void notify() const {
            for (Node *node = first_; node; node = node->next_)
                node->f_();
        }

        inline bool hasListeners() const { return first_; }

    private:
        friend class PropertyBinding;

        inline void disband() { first_ = 0; }

        class Node: public Object {
        public:
            template<class F>
            inline static Ref<Node> create(const F &f, Node *next) { return new Node(f, next); }

            std::function<void()> f_;
            Ref<Node> next_;

        private:
            template<class F>
            Node(const F &f, Node *next): f_(f), next_(next) {}
        };

        Ref<Node> first_;
    };

    inline Instance *operator->() { return &instance_; }
    inline const Instance *operator->() const { return &instance_; }

    inline void operator()() const { instance_.notify(); }

private:
    Event(const Event&) = delete;
    Event& operator=(const Event&) = delete;

    Instance instance_;
};

} // namespace cc
