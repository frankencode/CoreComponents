/*
 * Copyright (C) 2007-2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/containers>
#include <cc/strings>
#include <cc/Array>
#include <cc/List>

#ifdef QT_CORE_LIB
#include <QString>
#endif

/// translate a macro expression into a C string
#define CC_XSTR(x) CC_STR(x)
#define CC_STR(x) #x

namespace cc {

template<class T>
class Array;

/** Convenience alias
  * \ingroup strings
  * \ingroup container_lowlevel
  * \see Array<char>
  */
typedef Array<char> CharArray;

class Variant;
class Format;

/** Spezialised Ref<T> for character arrays
  * \ingroup strings
  * \see Array<char>
  */
typedef Ref<const CharArray> string;

/** Convenience alias
  * \ingroup strings
  */
typedef List<string> StringList;

class MutantString;

/** Get writable access to a string
  * \ingroup strings
  */
CharArray *mutate(const string &s);

/** Get writable access to an intermediate string
  * \ingroup strings
  */
MutantString mutate(string &&s);

/// string matching mode flags
enum class Match: uint32_t {
    Find = 0,         ///< Match any sub-string of the string
    Head = 1,         ///< Match the start of the string
    Tail = 2,         ///< Match the end of the string
    Full = Head|Tail, ///< Match the entire string
    Case = 4          ///< Compare characters case-sensitive
};

CC_BITMASK(Match, uint32_t);

/** \class Ref<const CharArray> cc/string
  * \brief Spezialised Ref<T> for T=CharArray
  * \ingroup strings
  * \see mutate(const string &), CharArray, string
  */
template<>
class Ref<const CharArray>
{
public:
    /// \copydoc Array<char>::allocate()
    static string allocate(int size);

    /// \copydoc Array<char>::create(int)
    static string create(int size);

    /// \copydoc Array<char>::create(int, char)
    static string create(int size, char preset);

    /// \copydoc Array<char>::copy(const char *, int)
    static string copy(const char *data, int size = -1);

    /// Create a copy of another string \a b
    static string copy(const string &b);

    /// \copydoc Array<char>::cat()
    static string cat(const string &a, const string &b);

    /// \copydoc Array<char>::join(const StringList *, const string &)
    static string join(const StringList *parts, const string &sep = string{});

    /// Create a string containing \a n copies of \a b
    static string multiply(const string &b, int n);

    /// Construct an empty string
    Ref(): a_{nullptr} {}

    /// Construt a string from an intermediate expression
    Ref(string &&b): a_{b.a_} { b.a_ = nullptr; }

    /// Construct an alias of another string \a b
    Ref(const string &b);

    /// \copydoc Ref(const string &)
    Ref(const CharArray *b);

    /// \copydoc Ref(const string &)
    Ref(CharArray *b): a_{nullptr} { set(b); }

    /** Construct a copy of another C string
      * \param other pointer to C string to copy
      * \param size number of characters to copy (optional)
      */
    Ref(const char *other, int size = -1);

    // explicit Ref(char ch);

    /** Construct an initialized zero-terminated string
      * \param size number of characters (excluding the terminating '\0')
      * \param preset initial character value
      */
    explicit Ref(int size, char preset = '\0');

    /// Construct a string by concatenating the items of list \a b
    Ref(const Ref<StringList> &b);

    /// Contruct a string as an alias to the string stored in \a b
    Ref(const Variant &b);

    /// \copydoc Ref(const Ref<StringList> &)
    Ref(const Format &b);

    /// \internal
    ~Ref() { set(nullptr); }

    /// Make this string an alias of \a b
    string &operator=(const string &b);

    /// Assign a copy of C string \a b
    string &operator=(const char *b);

    /// Assign the value of an intermediate expression
    string &operator=(string &&b) { set(nullptr); a_ = b.a_; b.a_ = nullptr; return *this; }

    /// Make this string an alias of \a b
    string &operator=(CharArray *b) { set(b); return *this; }

    /// Make this string an lias of the string stored in \a b
    string &operator=(const Variant &b) { set(string(b)); return *this; }

    /// Concatenate the items of list \a b and assign the resulting string
    string &operator=(const Ref<StringList> &b) { set(string(b)); return *this; }

    /// Concatenate the items of the formatting list \a b and assign the resulting string
    string &operator=(const Format &b) { set(string(b)); return *this; }

    /// Assign an empty string (FIXME: obsolete)
    string &operator=(const int &null) { CC_ASSERT(null == 0); (void)null; set(nullptr); return *this; }

    /// Assign an empty string
    string &operator=(std::nullptr_t) { set(nullptr); return *this; }

    /// Concatenate this string and character \a b and assign the resulting string
    string &operator+=(char b);

    /// Concatenate this string and C string \a b and assign the resulting string
    string &operator+=(const char *b);

    /// Concatenate this string and C string \a b and assign the resulting string
    string &operator+=(const string &b);

    /// Concatenate this string and all items of string list \a b and assign the resulting string
    string &operator+=(const Ref<StringList> &b);

    /// Contextual conversion to bool (true if s->count() > 0)
    operator bool();

    /// Contextual conversion to bool (true if s->count() > 0)
    operator bool() const;

    /// Convert to a C string
    operator const char *();

    /// Convert to a C string
    operator const char *() const;

    /// Convert to a character array pointer
    operator const CharArray *() { return get(); }

    /// Convert to a character array pointer
    operator const CharArray *() const { return get(); }

    /// Access the underlying character array (read-only)
    const CharArray &operator*() const { return *get(); }

    /// Access the underlying character array (read-only)
    const CharArray *operator->() const { return get(); }

    /// Access character at index \a i
    const char &operator[](int i) const;

    #ifdef QT_CORE_LIB
    /** \internal
      * @{
      */
    Ref(const QByteArray &b): Ref{b.constData(), b.size()} {}
    Ref(const QString &b): Ref{b.toUtf8()} {}

    operator QByteArray() const { return QByteArray{get()->chars(), get->count()}; }
    operator QString() const { return QString::fromUtf8(get()->chars(), get()->count()); }
    /** @}
      */
    #endif // QT_CORE_LIB

private:
    friend class MutantString;
    friend class Variant;
    template<class T2> friend class Ref;

    friend CharArray *mutate(const string &s);

    const CharArray *get() const;
    void set(const CharArray *b);

    const CharArray *a_;
};

class MutantString {
public:
    MutantString(string &&s): s_{s} {}
    MutantString(const string &s): s_{s} {}
    operator char *();
    operator CharArray *();
    CharArray *operator->();

private:
    string s_;
};

/** \class Array<char> cc/string
  * \brief Character array
  * \ingroup strings
  * \see Array
  * \todo fix isZeroTerminated() for substrings and add CC_ASSERTS to all implicit const char* conversions
  * \todo move to CharArray header
  */
template<>
class Array<char>: public Object
{
public:
    /// Item type
    typedef char Item;

    /// Index type
    typedef int Index;

    /** Create an uninitialized non-zero-terminated character array
      * \param size number of characters
      * \return new object instance
      * \see isZeroTerminated()
      * \see System::pageSize()
      */
    static string allocate(int size);

    /** Create an uninitialized zero-terminated character array
      * \param size number of characters (excluding the terminating '\0')
      * \return new object instance
      * \see isZeroTerminated()
      */
    static string create(int size = 0);

    /** Create an initialized zero-terminated character array
      * \param size number of characters (excluding the terminating '\0')
      * \param preset initial character value
      * \return new object instance
      * \see isZeroTerminated()
      */
    static string create(int size, char preset)
    {
        string s = create(size);
        mutate(s)->fill(preset);
        return s;
    }

    /** Create a copy of a C string
      * \param data pointer to C string
      * \param size number of characters (optional)
      * \return new object instance
      * \see isZeroTerminated()
      */
    static string copy(const char *data, int size = -1);

    /** Create a copy of another character array
      * \param other the original character array
      * \return new object instance
      */
    static string copy(const CharArray *other) { return other ? other->copy() : string{}; }

    /** Join a list of strings
      * \param parts the individual items to join together
      * \param sep the separator to put between the items
      * \param sepSize the size of the separator (optional)
      * \return new object instance
      */
    static string join(const StringList *parts, const char *sep = "", int sepSize = -1);

     /** Join a list of strings
      * \param parts the individual parts to join together
      * \param sep the separator to put between individual parts
      * \return new object instance
      */
    static string join(const StringList *parts, const string &sep);

    /** Concatenate two strings
      * \param a the left string
      * \param b the right string
      * \return new object instance
      */
    static string cat(const string &a, const string &b);

    /// Return the pointer to the default character array (which is of zero length)
    static const CharArray *empty();

    /// Returns true if this character array is zero terminated
    virtual bool isZeroTerminated() const { return true; }

    /// %Set all characters to \a zero
    void fill(char zero);

    /// %Set the first \a n characters to \a zero
    void fill(char zero, int n);

    /// Cut this string down to \a newSize characters
    void truncate(int newSize);

    /// Copy characters to this string from string \a b
    void write(const CharArray *b) {
        int n = (size_ < b->size_) ? size_ : b->size_;
        memcpy(data_, b->data_, n);
    }

    /** Copy characters to this string from string \a b
      * \param b source to copy data from
      * \param i0 begin of destination range (index of first byte to write)
      * \param i1 end of destination range (index behind the last byte to write)
      */
    void write(const CharArray *b, int i0, int i1)
    {
        if (i0 < 0) i0 = 0;
        if (i1 > size_) i1 = size_;
        if (i1 <= i0) return;
        int n = i1 - i0;
        if (n > b->size_) n = b->size_;
        memcpy(data_ + i0, b->data_, n);
    }

    /// Byte-vise xor over this string with bytes from string \a b
    void writeXor(const CharArray *b);

    /// Length of this string (in number of characters)
    int count() const { return size_; }

    /// Check if index \a i is valid
    bool has(int i) const {
        return (0 <= i) && (i < size_);
    }

    /// Access character at index \a i
    char &at(int i) {
        CC_ASSERT(has(i));
        return data_[i];
    }

    /// \copybrief at(int)
    const char &at(int i) const {
        CC_ASSERT(has(i));
        return data_[i];
    }

    /// Access byte at index \a i
    uint8_t &byteAt(int i) {
        CC_ASSERT(has(i));
        return bytes_[i];
    }

    /// \copybrief byteAt(int)
    const uint8_t &byteAt(int i) const {
        CC_ASSERT(has(i));
        return bytes_[i];
    }

    /// Access word at word offset \a j (1 word = 4 bytes)
    uint32_t &wordAt(int j) {
        CC_ASSERT(has(j * 4) && has(j * 4 + 3));
        return words_[j];
    }

    /// \copybrief wordAt(int)
    const uint32_t &wordAt(int j) const {
        CC_ASSERT(has(j * 4) && has(j * 4 + 3));
        return words_[j];
    }

    /// Check if item index \a j is valid
    template<class T>
    bool hasItem(int j) const {
        return has(j * sizeof(T));
    }

    /// Access item of type T at item index \a j
    template<class T>
    T &item(int j = 0) {
        CC_ASSERT(has(j * sizeof(T)) && has((j + 1) * sizeof(T) -1));
        return reinterpret_cast<T *>(data_)[j];
    }

    /// \copybrief item(int)
    template<class T>
    const T &item(int j = 0) const {
        CC_ASSERT(has(j * sizeof(T)) && has((j + 1) * sizeof(T) -1));
        return reinterpret_cast<T *>(data_)[j];
    }

    /// Number of items of type T
    template<class T>
    int itemCount() const { return size_ / sizeof(T); }

    /// Return the internal C string representation
    char *chars() { return chars_; }

    /// \copybrief chars()
    const char *chars() const { return chars_; }

    /// Return byte pointer to the internal memory buffer
    uint8_t *bytes() { return bytes_; }

    /// \copybrief bytes()
    const uint8_t *bytes() const { return bytes_; }

    /// Return half word pointer to the internal memory buffer
    uint16_t *halfs() { return halfs_; }

    /// \copybrief halfs()
    const uint16_t *halfs() const{ return halfs_; }

    /// Return word pointer to the internal memory buffer
    uint32_t *words() { return words_; }

    /// \copybrief words()
    const uint32_t *words() const { return words_; }

    /// Create a copy of this string
    string copy() const { return new CharArray(*this); }

    /** Create a selection (reference to a sub-string)
      * \param i0 begin of selection (index of first selected character)
      * \param i1 end of selection (index behind the last selected character)
      * \return the selected sub-string
      * \see parent()
      * \see Object::refCount()
      * Sub-strings reference their parent and therefore increment the parent's reference count (\see Object::refCount()).
      * Sub-string selections can be cascaded to arbitrary depth.
      */
    string select(int i0, int i1) const {
        return new CharArray(this, i0, i1);
    }

    /** Create a selection (reference to a sub-string)
      * \param i1 end of selection (index behind the last selected character)
      * \return the selected sub-string
      */
    string select(int i1) const {
        return new CharArray(this, 0, i1);
    }

    /** Create a selection (reference to a sub-string)
      * \param i0 begin of selection (index of first selected character)
      * \return the selected sub-string
      */
    string selectFrom(int i0) const {
        return new CharArray(this, i0, size_);
    }

    /// Pointer to parent string if this string is a sub-string selection (nullptr otherwise)
    const CharArray *parent() const { return parent_; }

    /// Character offset of this string within its parent string if this string is a sub-string selection (0 otherwise)
    int offset() const { return parent_ ? int(data_ - parent_->data_) : 0; }

    /// Copy characters in range [\a range->i0(), \a range->i1())
    template<class Range>
    string copyRange(Range range) const {
        if (!range) return new CharArray();
        return copy(range->i0(), range->i1());
    }

    /// Copy characters in range [\a i0, \a i1)
    string copy(int i0, int i1) const;

    /** Create an edited version of this string by replacing a sub-string
      * \param i0 begin of sub-string (index of first selected character)
      * \param i1 end of sub-string (index behind the last selected charater)
      * \param text text that will replace the sub-string
      * \return new string with range [\a i0, \a i1) replaced by text
      */
    string paste(int i0, int i1, const string &text) const;

    /// Select \a n characters from the head of this string
    string head(int n) const {
        if (n == size_) return this;
        return select(0, n);
    }

    /// Select \a n characters from the tail of this string
    string tail(int n) const {
        if (n == size_) return this;
        return select(size_ - n, size_);
    }

    /// Check if the first character of this string equals \a ch
    bool startsWith(char ch) const {
        if (size_ == 0) return false;
        return data_[0] == ch;
    }

    /// Check if the last character of this string equals \a ch
    bool endsWith(char ch) const {
        if (size_ == 0) return false;
        return data_[size_ - 1] == ch;
    }

    /// Check if this string begins with the sub-string \a s
    bool startsWith(const string &s) const {
        return match(Match::Head|Match::Case, s);
    }

    /** \copybrief beginsWith(const string &) const
      * \param s sub-string to test for
      * \param n size of \a s (optional)
      */
    bool startsWith(const char *s, int n = -1) const {
        return match(Match::Head|Match::Case, s, n);
    }

    /// Check if this string ends with the sub-string \a s
    bool endsWith(const string &s) const {
        return match(Match::Tail|Match::Case, s);
    }

    /** \copybrief endsWith(const string &) const
      * \param s sub-string to test for
      * \param n size of \a s (optional)
      */
    bool endsWith(const char *s, int n = -1) const {
        return match(Match::Tail|Match::Case, s, n);
    }

    /** Match this string against another string
      * \param m matching mode
      * \param s sub-string
      * \return true if matches
      */
    bool match(Match m, const string &s) const {
        return match(m, s->chars_, s->size_);
    }

    /** \copybrief match(Match, const string &)
      * \param m matching mode
      * \param s sub-string
      * \param n length of sub-string
      * \return true if matches
      */
    bool match(Match m, const char *s, int n = -1) const;

    /** \copybrief match(Match, const string &)
      * \param s sub-string
      * \return true if matches
      */
    bool match(const string &s) const {
        return match(Match::Full, s->chars_, s->size_);
    }

    /** \copybrief match(Match, const string &)
      * \param s sub-string
      * \param n length of sub-string
      * \return true if matches
      */
    bool match(const char *s, int n = -1) const {
        return match(Match::Full, s, n);
    }

    /** Find first occurence of a character value
      * \param ch character value to search for
      * \param i start search from this index
      * \return index of first occurence of character ch or count() if not found
      */
    int scan(char ch, int i = 0) const {
        if (i < 0) i = 0;
        while (i < size_) {
            if (data_[i] == ch) break;
            ++i;
        }
        return i;
    }

    /** Find first occurence of a character value
      * \param ch character value to search for
      * \param i current search index
      * \return true if \a ch was found, false otherwise
      */
    bool find(char ch, int *i = nullptr) const
    {
        int j = (i) ? *i : 0;
        while (j < size_) {
            if (data_[j] == ch) {
                if (i) *i = j;
                return true;
            }
            ++j;
        }
        if (i) *i = j;
        return false;
    }

    /** Check if this string contains a certain character value
      * \param ch character value to search for
      * \return true if this string contains character ch
      */
    bool contains(char ch) const { return find(ch); }

    /** Count the number of occurrences of a certain character value
      * \param ch character value to search for
      * \return number of occurrences of character value \a ch
      */
    int count(char ch) const {
        int n = 0;
        for (int i = 0; i < size_; ++i)
            n += (data_[i] == ch);
        return n;
    }

    /** Count number of occurrences of characters from a set of characters
      * \param set set of characters
      * \return number of occurrences of characters from the set
      */
    int countCharsIn(const char *set) const;

    /** Find a sub-string
      * \param s sub-string to search for
      * \param i start search from this index
      * \return index of first occurence of s or count() if not found
      */
    int scan(const char *s, int i = 0) const;

    /// \copydoc scan(const char *, int) const
    int scan(const string &s, int i = 0) const;

    /** Check if this string contains a certain sub-string
      * \param s sub-string to search for
      * \return true if this string contains the sub-string \a s
      */
    bool contains(const char *s) const
    {
        if (!s[0]) return true;
        return scan(s) != size_;
    }

    /// \copydoc contains(const char *) const
    bool contains(const string &s) const;

    /** Create a string list by splitting this string into pieces
      * \param sep split marker to search for
      * \return list of pieces without the split markers
      */
    Ref<StringList> split(char sep) const;

    /// \copydoc split(char) const
    Ref<StringList> split(const char *sep) const;

    /// \copydoc split(char) const
    Ref<StringList> split(string sep) const { return split(sep->chars()); }

    /** Create a string list by breaking up this string into equal sized chunks
      * \param chunkSize size of the individual chunks
      * \return list of chunks
      */
    Ref<StringList> breakUp(int chunkSize) const;

    /** Replace individual character values
      * \param p character value to search for
      * \param r replacement value to insert
      */
    string replaceInsitu(char p, char r) {
        for (int i = 0; i < size_; ++i) {
            if (data_[i] == p)
                data_[i] = r;
        }
        return this;
    }

    /** Replace any occurrence of a certain sub-string by a replacement string
      * \param p sub-string to search for
      * \param r replacement string
      */
    string replaceInsitu(const char *p, const char *r);

    /** Replace individual character values
      * \param p character value to search for
      * \param r replacement value to insert
      * \return resulting string
      */
    string replaceEach(char p, char r) const;

    /** Replace any occurrence of a certain sub-string by a replacement string
      * \param p sub-string to search for
      * \param r replacement string
      * \return resulting string
      */
    string replace(const char *p, const char *r) const;

    /// \copydoc replace(const char *, const char *) const
    string replace(const char *p, const string &r) const;

    /// \copydoc replace(const char *, const char *) const
    string replace(const string &p, const string &r) const;

    /** Scan for a sub-string up to a lexical termination
      * \param x return the scanned sub-string
      * \param termination set of lexical termination characters
      * \param i0 begin of range to scan (index of first character)
      * \param i1 end of range to scan (index behind the last charater)
      * \return scan position behind the scanned string
      */
    int scanString(string *x, const char *termination = " \t\n", int i0 = 0, int i1 = -1) const;

    /** Scan a number literal
      * \param value returns the value of the scanned number
      * \param base number base to use
      * \param i0 begin of range to scan (index of first character)
      * \param i1 end of range to scan (index behind the last charater)
      * \return scan position behind the scanned string
      */
    template<class T>
    int scanNumber(T *value, int base = -1, int i0 = 0, int i1 = -1) const;

    /** Convert to a numerical value
      * \param ok return true if conversion was successful (optional)
      * \return numerical value
      */
    template<class T, int base = -1>
    T toNumber(bool *ok = nullptr) const
    {
        bool h = false;
        if (!ok) ok = &h;
        T value = T();
        *ok = (scanNumber(&value, base) == size_);
        return value;
    }

    /// Convert all upper-case ASCII characters to lower-case ASCII characters
    string toLower() const { return mutate(copy())->downcaseInsitu(); }

    /// Convert all lower-case ASCII characters to upper-case ASCII characters
    string toUpper() const { return mutate(copy())->upcaseInsitu(); }

    /// \copybrief toLower() const
    string downcaseInsitu();

    /// \copybrief toUpper() const
    string upcaseInsitu();

    /// Replace all non-printable and non-ASCII characters by escape sequences
    string escape() const;

    /// Replace all escape sequences by their character value
    string unescape() const { return mutate(copy())->unescapeInsitu(); }

    /// \copybrief unescape() const
    string unescapeInsitu();

    /** Remove leading and trailing whitespace
      * \param leadingSpace set of characters to detect as leading whitespace
      * \param trailingSpace set of characters to detect as trailing whitespace
      */
    string trim(const char *leadingSpace = " \t\n\r", const char *trailingSpace = nullptr) const
    {
        return mutate(copy())->trimInsitu(leadingSpace, trailingSpace);
    }

    /** Remove leading whitespace
      * \param space set of characters to detect as whitespace
      */
    string trimLeading(const char *space = " \t\n\r") const { return mutate(copy())->trimInsitu(space, ""); }

    /** Remove trailing whitespace
      * \param space set of characters to detect as whitespace
      */
    string trimTrailing(const char *space = " \t\n\r") const { return mutate(copy())->trimInsitu("", space); }

    /// \copybrief trim(const char *, const char *) const
    string trimInsitu(const char *leadingSpace = " \t\n\r", const char *trailingSpace = nullptr);

    /// Replace multi character whitespaces by single character whitespaces
    string simplify(const char *space = " \t\n\r") const { return mutate(copy())->simplifyInsitu(space); }

    /// \copybrief simplify(const char *) const
    string simplifyInsitu(const char *space = " \t\n\r");

    /** Common user input normalization
      * \param nameCase make sure the first character is upper case
      */
    string normalize(bool nameCase = true) const;

    /// Remove all XML/HTML tags and entities
    string xmlSanitize() const;

    /** \brief %Map a byte offset to editor coordinates.
      * \param offset byte offset
      * \param line n-th line starting with 1
      * \param pos position on line starting with 0 (in bytes)
      * \return true if offset is within valid range
      */
    bool offsetToLinePos(int offset, int *line = nullptr, int *pos = nullptr) const;

   /** %Map editor coordinates to a byte offset
     * \param line n-th line starting with 1
     * \param pos position on line starting with 1 (in bytes)
     * \param offset byte offset
     * \return true if successful
     */
    bool linePosToOffset(int line, int pos, int *offset = nullptr) const;

    /** Check if this string is UTF-8 encoded
      * \exception EncodingError this string is not UTF-8 encoded
      */
    void checkUtf8() const;

    /** Create an UTF-8 encoded string from an UTF-16 encoded string
      * \param utf16 UTF-16 encoded string
      * \param endian endianess of the UTF-16 encoded string
      * \return UTF-8 encoded string
      */
    static string fromUtf16(const CharArray *utf16, ByteOrder endian = localEndian());

   /** Convert to a UTF-16 encoded string (local endian).
     * \param buf destination buffer
     * \param size pass capacity of destination buffer
     * \return true if the given buffer was suitable to hold the encoded string
     *
     * The number of bytes required to fully represent the string in UTF-16 is
     * returned with the \a size argument. Passing a zero for \a size allows to
     * determine the required buffer size. No zero termination is written or
     * or accounted for.
     */
    bool toUtf16(void *buf, int *size);

    /** \copybrief toUtf16(void *, int *)
      * \param endian endianess of the UTF-16 encoded string
      * \return UTF-16 encoded string
      */
    string toUtf16(ByteOrder endian = localEndian()) const;

    /** Convert to a series of hexadecimal characters
      * \see hexDump
      */
    string toHex() const;

    /** Convert to a hexadecimal dump
      * \see HexDump
      */
    string hexDump() const;

    /// Add a prefix to each line of the text
    string indent(const string &prefix) const;

    /// Check if this string equals "/"
    bool isRootPath() const;

    /// Check if this string represents a relative path
    bool isRelativePath() const;

    /// Check if this string represents an absolute path
    bool isAbsolutePath() const;

    /** Convert to an absolute path
      * \param currentDir absolute path to the current directory
      * \return absolute path
      */
    string absolutePathRelativeTo(const string &currentDir) const;

    /// Return the filename component
    string fileName() const;

    /// Return the filename component without file type suffix
    string baseName() const;

    /// Return the file type suffix (everything after the last '.')
    string fileSuffix() const;

    /// Remove the last component from this path
    string reducePath() const;

    /// Append components of \a relativePath to this string
    string extendPath(const string &relativePath) const;

    /// Remove redundant or ambigous path elements
    string canonicalPath() const;

    /// Compare this string for equality with string \a b
    bool equals(const string &b) const { return size_ == b->size_ && strncmp(chars_, b->chars_, size_) == 0; }

    /// Compare this tring for inequality with string \a b
    bool differs(const string &b) const { return size_ != b->size_ || strncmp(chars_, b->chars_, size_) != 0; }

    /// Compare if this string is below string \a b
    bool below(const string &b) const {
        return below(b->chars(), b->count());
    }

    /// Compare if this string is below string \a b
    bool below(const char *b, int bSize = -1) const {
        if (bSize < 0) bSize = strlen(b);
        int m = size_ < bSize ? size_ : bSize;
        int ret = strncmp(chars_, b, m);
        if (ret == 0) return size_ < bSize;
        return ret < 0;
    }

    /// Compare if this string is below or equal string \a b
    bool belowOrEqual(const string &b) const {
        return belowOrEqual(b->chars(), b->count());
    }

    /// Compare if this string is below or equal string \a b
    bool belowOrEqual(const char *b, int bSize = -1) const {
        if (bSize < 0) bSize = strlen(b);
        int m = size_ < bSize ? size_ : bSize;
        int ret = strncmp(chars_, b, m);
        if (ret == 0) return size_ <= bSize;
        return ret < 0;
    }

    /// Compare if this string is greater than string \a b
    bool greater(const string &b) const { return b->below(this); }

    /// Compare if this string is greater than string \a b
    bool greater(const char *b, int bSize = -1) const { return !belowOrEqual(b, bSize); }

    /// Compare is this string is greater or equal string \a b
    bool greaterOrEqual(const string &b) const { return b->belowOrEqual(this); }

    /// Compare is this string is greater or equal string \a b
    bool greaterOrEqual(const char *b, int bSize = -1) const { return !below(b, bSize); }

    /// Compare if this string equals string \a b (ASCII case-insensitive)
    bool equalsCaseInsensitive(const string &b) const;

    /// \copybrief equalsCaseInsensitive(const string &) const
    bool equalsCaseInsensitive(const char *b) const;

    /** \name Iterators
      * @{
      */
    typedef ArrayIterator<CharArray> Iterator;
    typedef ConstArrayIterator<CharArray> ConstIterator;

    Iterator begin() { return Iterator{this, 0}; }
    Iterator end() { return Iterator{this, count()}; }

    ConstIterator begin() const { return ConstIterator{this, 0}; }
    ConstIterator end() const { return ConstIterator{this, count()}; }
    /** @} */

    /** \internal
      * @{
      */
    typedef Iterator iterator;
    typedef ConstIterator const_iterator;
    /** @}
      */

protected:
    friend class Ref<const CharArray>;

    friend bool operator==(const string &a, const string &b);
    friend bool operator!=(const string &a, const string &b);
    friend bool operator< (const string &a, const string &b);
    friend bool operator<=(const string &a, const string &b);

    typedef void (*Destroy)(CharArray *array);

    Array();
    Array(const char *data, int size = -1, Destroy destroy = nullptr);
    Array(const CharArray *parent, int i0, int i1);
    Array(const CharArray &b);

    ~Array();

    static void doNothing(CharArray *);

private:
    void destroy();

    static double pow(double x, double y);

    int size_;
    union {
        char *data_; // \todo that should be void *
        char *chars_;
        uint8_t *bytes_;
        uint16_t *halfs_;
        uint32_t *words_;
    };

    Destroy destroy_;
    string parent_;
};

template<class T>
int Array<char>::scanNumber(T *value, int base, int i0, int i1) const
{
    int i = i0;
    if (i1 < 0) i1 = size_;
    if (i > i1) i = i1;
    int sign = 1;
    if (T(-1) < T() && i < i1) {
        if (at(i) == '-') sign = -1;
        i += (at(i) == '-' || at(i) == '+');
    }
    bool isFloating = (T(1)/T(3) > 0);
    if (isFloating && i + 2 < i1) {
        if (at(i) == 'n' && at(i + 1) == 'a' && at(i + 2) == 'n') {
            *value = cc::nan();
            return i + 3;
        }
        else if (at(i) == 'i' && at(i + 1) == 'n' && at(i + 2) == 'f') {
            *value = sign * cc::inf();
            return i + 3;
        }
    }
    if (i < i1 && base <= 0) {
        if (at(i) == '0') {
            if (i + 1 < i1) {
                char ch = at(i + 1);
                if (ch == 'x') { base = 16; i += 2; }
                else if (ch == 'b') { base = 2; i += 2; }
                else if ('0' <= ch && ch <= '7') { base = 8; i += 1; }
            }
        }
    }
    if (base <= 0) base = 10;
    T x = 0;
    while (i < i1) {
        char ch = at(i);
        int z = -1;
        if ('0' <= ch && ch <= '9') z = ch - '0';
        else if ('a' <= ch && ch <= 'z') z = 10 + ch - 'a';
        else if ('A' <= ch && ch <= 'Z') z = 10 + ch - 'A';
        if (z < 0 || base <= z) break;
        T y = x;
        x = x * base + sign * z;
        if (!isFloating) {
            if (sign > 0 ? x < y : y < x)
                break;
        }
        ++i;
    }
    if (isFloating && i < i1) {
        if (at(i) == '.') {
            ++i;
            for (T h = T(sign) / T(base); i < i1; ++i) {
                char ch = at(i);
                int z = -1;
                if ('0' <= ch && ch <= '9') z = ch - '0';
                else if ('a' <= ch && ch <= 'z') z = 10 + ch - 'a';
                else if ('A' <= ch && ch <= 'Z') z = 10 + ch - 'A';
                if (z < 0 || base <= z) break;
                x += h * z;
                h /= base;
            }
        }
        if (i + 1 < i1) {
            if (at(i) == 'E' || at(i) == 'e') {
                int ep = 0;
                i = scanNumber(&ep, base, i + 1, i1);
                x *= pow(T(base), T(ep));
            }
        }
    }
    *value = x;
    return i;
}

inline bool operator==(const string &a, const string &b) { return a->equals(b); }
inline bool operator!=(const string &a, const string &b) { return a->differs(b); }
inline bool operator< (const string &a, const string &b) { return a->below(b); }
inline bool operator> (const string &a, const string &b) { return a->greater(b); }
inline bool operator<=(const string &a, const string &b) { return a->belowOrEqual(b); }
inline bool operator>=(const string &a, const string &b) { return a->greaterOrEqual(b); }

inline bool operator==(const char *a, const string &b) { return b->equals(a); }
inline bool operator!=(const char *a, const string &b) { return b->differs(a); }
inline bool operator< (const char *a, const string &b) { return b->greater(a); }
inline bool operator> (const char *a, const string &b) { return b->below(a); }
inline bool operator<=(const char *a, const string &b) { return b->greaterOrEqual(a); }
inline bool operator>=(const char *a, const string &b) { return b->belowOrEqual(a); }

inline bool operator==(char *a, const string &b) { return b->equals(a); }
inline bool operator!=(char *a, const string &b) { return b->differs(a); }
inline bool operator< (char *a, const string &b) { return b->greater(a); }
inline bool operator> (char *a, const string &b) { return b->below(a); }
inline bool operator<=(char *a, const string &b) { return b->greaterOrEqual(a); }
inline bool operator>=(char *a, const string &b) { return b->belowOrEqual(a); }

inline bool operator==(const string &a, const char *b) { return a->equals(b); }
inline bool operator!=(const string &a, const char *b) { return a->differs(b); }
inline bool operator< (const string &a, const char *b) { return a->below(b); }
inline bool operator> (const string &a, const char *b) { return a->greater(b); }
inline bool operator<=(const string &a, const char *b) { return a->belowOrEqual(b); }
inline bool operator>=(const string &a, const char *b) { return a->greaterOrEqual(b); }

inline bool operator==(const string &a, char *b) { return a->equals(b); }
inline bool operator!=(const string &a, char *b) { return a->differs(b); }
inline bool operator< (const string &a, char *b) { return a->below(b); }
inline bool operator> (const string &a, char *b) { return a->greater(b); }
inline bool operator<=(const string &a, char *b) { return a->belowOrEqual(b); }
inline bool operator>=(const string &a, char *b) { return a->greaterOrEqual(b); }

inline CharArray *mutate(const string &s) { return const_cast<CharArray *>(s.get()); }

inline MutantString::operator char *() { return const_cast<CharArray *>(s_.get())->chars(); }
inline MutantString::operator CharArray *() { return const_cast<CharArray *>(s_.get()); }
inline CharArray *MutantString::operator->() { return const_cast<CharArray *>(s_.get()); }

inline MutantString mutate(string &&s) { return std::move(s); }

inline Ref<const CharArray>::Ref(const string &b):
    a_{nullptr}
{
    set(b.a_);
}

inline Ref<const CharArray>::Ref(const CharArray *b):
    a_{nullptr}
{
    set(CharArray::copy(b));
}

inline Ref<const CharArray>::Ref(const char *other, int size):
    a_{nullptr}
{
    set(CharArray::copy(other, size));
}

inline Ref<const CharArray>::Ref(int size, char preset):
    a_{nullptr}
{
    auto s = CharArray::create(size);
    mutate(s)->fill(preset);
    set(s);
}

inline Ref<const CharArray>::Ref(const Ref<StringList> &b):
    a_{nullptr}
{
    if (b) set(CharArray::join(b));
}

inline string Ref<const CharArray>::allocate(int size)
{
    return CharArray::allocate(size);
}

inline string Ref<const CharArray>::create(int size)
{
    return CharArray::create(size);
}

inline string Ref<const CharArray>::create(int size, char zero)
{
    return CharArray::create(size, zero);
}

inline string Ref<const CharArray>::copy(const char *data, int size)
{
    return CharArray::copy(data, size);
}

inline string Ref<const CharArray>::copy(const string &b)
{
    return CharArray::copy(b.a_);
}

inline string Ref<const CharArray>::cat(const string &a, const string &b)
{
    return CharArray::cat(a, b);
}

inline string Ref<const CharArray>::join(const StringList *parts, const string &sep)
{
    return CharArray::join(parts, sep);
}

inline string Ref<const CharArray>::multiply(const string &b, int n)
{
    auto s = CharArray::allocate(n * b->count());
    for (int i = 0, m = s->count(); i < m; i += b->count()) mutate(s)->write(b, i, i + b->count());
    return s;
}

inline string &Ref<const CharArray>::operator=(const string &b)
{
    set(b.a_);
    return *this;
}

inline string &Ref<const CharArray>::operator=(const char *b)
{
    set(CharArray::copy(b));
    return *this;
}

inline const char &Ref<const CharArray>::operator[](int i) const
{
    return get()->at(i);
}

inline Ref<const CharArray>::operator bool() { return a_ && a_->count() > 0; }
inline Ref<const CharArray>::operator bool() const { return a_ && a_->count() > 0; }
inline Ref<const CharArray>::operator const char *() const { return get()->chars(); }
inline Ref<const CharArray>::operator const char *() { return get()->chars(); }

inline Ref<StringList> operator+(const string &a, const string &b) { return StringList::create() << a << b; }
inline Ref<StringList> operator+(Ref<StringList> &a, const string &b) { return a << b; }
inline Ref<StringList> operator+(const string &a, const char *b) { return a + string{b}; }
inline Ref<StringList> operator+(const char *a, const string& b) { return string{a} + b; }

inline string &Ref<const CharArray>::operator+=(char b) { string s{1}; mutate(s)->at(0) = b; set(CharArray::cat(*this, s)); return *this; }
inline string &Ref<const CharArray>::operator+=(const char *b) { set(CharArray::cat(*this, string{b})); return *this; }
inline string &Ref<const CharArray>::operator+=(const string &b) { set(CharArray::cat(*this, b)); return *this; }
inline string &Ref<const CharArray>::operator+=(const Ref<StringList> &b) { set(string{*this + b}); return *this; }

inline const CharArray *Ref<const CharArray>::get() const
{
    if (!a_) return CharArray::empty();
    return a_;
}

inline void Ref<const CharArray>::set(const CharArray *b)
{
    if (a_ != b) {
        if (b) b->incRefCount();
        if (a_) a_->decRefCount();
        a_ = b;
    }
}

} // namespace cc
