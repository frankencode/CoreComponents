/*
 * Copyright (C) 2021 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Range>
#include <cc/AppendList>
#include <cc/SyntaxRule>

namespace cc {

class TokenScreen;

/** \class Token cc/Token
  * \ingroup syntax
  * \brief Syntax production
  */
class Token final: public Object
{
public:
    /** Create an invalid token
      */
    Token():
        Object{new State}
    {}

    bool isValid() const { return range().isValid(); } ///< Check if valid

    operator bool() const { return isValid(); } ///< Check if valid

    /** Check if this token is produced within a certain \a context.
      */
    bool withinContext(const SyntaxRule &context) const { return me().withinContext(context); }

    /** Returns the syntax rule this token was generated by
      */
    const SyntaxRule &rule() const { return me().rule_; }

    /** %Index range that is covered by this token
      */
    const Range &range() const { return me().range_; }

    operator long() const { return range()[0]; } ///< Cast to long
    operator Range() const { return range(); } ///< Coverage range
    long i0() const { return range()[0]; } ///< Start index of coverage range
    long i1() const { return range()[1]; } ///< End index of coverage range
    long operator[](int i) const { return range()[i]; } ///< Syntax sugar

    using Children = AppendList<Token>; ///< Type of the children list

    const Children &children() const { return me().children_; } ///< %Constant children list
    Children &children() { return me().children_; } ///< %Children list

    /** Get captured value by \a name
      * \see cc::SyntaxDefinition::Capture
      */
    String capturedValue(const String &name) const
    {
        return me().capturedValue(name);
    }

    /** Set captured value
      */
    void setCapturedValue(const String &name, const String &value)
    {
        me().setCapturedValue(name, value);
    }

    /** %Project this token tree onto \a screen
      */
    bool project(const TokenScreen &screen) const;

private:
    friend class SyntaxRule;
    friend class CaptureNode;

    explicit Token(Token *parent):
        Object{new State{&parent->me()}}
    {}

    void setRule(const SyntaxRule &rule)
    {
        me().rule_ = rule;
    }

    void setRange(Range newValue)
    {
        me().range_ = newValue;
    }

    bool projectCascade(TokenScreen &screen) const;

    struct MatchState;

    struct State: public Object::State
    {
        State() = default;

        explicit State(const State *parent):
            parent_{parent}
        {}

        ~State()
        {
            if (matchState_) deleteMatchState();
        }

        bool withinContext(const SyntaxRule &context) const
        {
            for (const State *state = parent_; state; state = state->parent_)
            {
                if (state->rule_ == context) return true;
            }
            return false;
        }

        const State *getRoot() const
        {
            const State *state = this;
            while (state->parent_) state = state->parent_;
            return state;
        }

        String capturedValue(const String &name) const;
        void setCapturedValue(const String &name, const String &value);
        void deleteMatchState();

        const State *parent_ { nullptr };
        mutable MatchState *matchState_ { nullptr };
        SyntaxRule rule_;
        Range range_;
        Children children_;
    };

    State &me() { return Object::me.as<State>(); }
    const State &me() const { return Object::me.as<State>(); }
};

} // namespace cc
