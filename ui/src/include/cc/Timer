/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Object>
#include <cc/Trigger>
#include <atomic>

namespace cc {

class Application;
class TimeoutRequest;

/** \class Timer cc/Timer
  * \ingroup ui
  * \brief Inverval timer
  */
class Timer final: public Object
{
public:
    /** Create a single-shot timer
      */
    Timer() = default;

    /** Create a repeating interval timer
      * \param interval %Interval in which the timeout signal is triggered
      */
    explicit Timer(double interval):
        Object{new State{interval}}
    {}

    /** Register function \a f to be called on timeout
      */
    Timer &onTimeout(Fun<void()> &&f)
    {
        me().timeout_(move(f));
        return *this;
    }

    /** Start timer
      */
    Timer &start()
    {
        startIn(me().interval_);
        return *this;
    }

    /** Start timer at a later \a startTime
      */
    Timer &startAt(double startTime);

    /** Start timer after a giving \a delayTime
      */
    Timer &startIn(double delayTime);

    /** Stop the timer
      */
    void stop();

    /** Timer is active an generates timeout signals
      */
    bool isActive() const { return me().isActive_; }

    /** The first time the timer emits the timeout signal
      */
    double firstTime() const { return me().firstTime_; }

    /** Beginning of the first timeout interval
      */
    double startTime() const { return me().startTime_; }

    /** %Time between two timeout signal emissions
      */
    double interval() const { return me().interval_; }

    /** Convenience method to run the application loop
      */
    int run();

private:
    friend class Application;
    friend class TimeoutRequest;

    struct State final: public Object::State
    {
        State(double interval):
            interval_{interval}
        {}
        double interval_;
        Trigger timeout_;
        mutable std::atomic<bool> isActive_ { false };
        double firstTime_ { 0 };
        double startTime_ { 0 };
        std::atomic<uint64_t> requestId_ { 0 };
    };

    State &me() { return Object::me.as<State>(); }
    const State &me() const { return Object::me.as<State>(); }
};

} // namespace cc
