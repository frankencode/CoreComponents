/*
 * Copyright (C) 2020-2022 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Control>
#include <cc/Timer>
#include <cc/Pane>

namespace cc {

/** \class Flickable cc/Flickable
  * \ingroup ui
  * \brief %Control with variable sized movable contents
  * \todo make the style plugin deliver the behavioral parameters for the flickable
  */
class Flickable: public Control
{
public:
    /** Create a primordial flickable
      */
    Flickable();

    /** Create a new flickable
      */
    explicit Flickable(Out<Flickable> self):
        Control{new State}
    {
        self = weak<Flickable>();
    }

    /** Create a new flickable of given size (\a width, \a height)
      */
    Flickable(double width, double height):
        Control{new State}
    {
        size(Size{width, height});
    }

    /** Create a new flickable of given size (\a width, \a height) and with a custom \a pane
      */
    Flickable(double width, double height, const View &pane):
        Control{new State{pane}}
    {
        size(Size{width, height});
    }

    /** Create a new flickable with a custom \a pane
      */
    explicit Flickable(const View &pane):
        Control{new State{pane}}
    {}

    /** Get the access to the contained pane
      */
    View &pane() { return me().pane_; }

    /** Get the access to the contained pane
      */
    const View &pane() const { return me().pane_; }

protected:
    friend class Object;

    struct State: public Control::State
    {
        State(const View &pane = Pane{});

        View pane() const { return pane_; }

        virtual void preheat();
        virtual void positionCarrierOnResize();

    protected:
        friend class Flickable;

        void keepFocusControlInView();

        bool carrierInsideBoundary() const;
        Point carrierStep(Point p, double b = 0);

        void carrierFlyStart();
        void carrierBounceStart();
        void carrierTraverseStart(Step distance);
        void carrierStop();
        void timerStop();

        void carrierFly();
        void carrierBounce();
        void carrierTraverse();
        void carrierStopped();

        Property<double> maxFlyTime { 1.5 };
        Property<double> maxSpeed { [this]{ return 3 * size().max(); } };
        Property<double> minHoldTime { 0.1 };
        Property<double> boundary { dp(60) };
        Property<double> maxBounceTime { 0.6 };
        Property<double> traverseTime { 0.5 };

        Property<double> wheelGranularity { 3 * std::ceil(style().itemHeight2()) };
        Property<double> maxWheelTime { 0.1 };
        Property<bool> wheelInversion { style().wheelInversion() };
        Property<bool> wheelBouncing { true };

        Property<Control> focusControl;

        View pane_;
        Control overwrittenControl_;
        bool isDragged_ { false };
        Point dragStart_;
        Point carrierOrigin_;

        Point lastDragPos_;
        double lastDragTime_;
        double releaseSpeedMagnitude_;
        Step speed_;

        enum class TimerMode { Stopped, Flying, Bouncing, Traversing };
        TimerMode timerMode_ { TimerMode::Stopped };

        Timer timer_;
        double lastTime_;

        Point startPos_;
        Point finalPos_;

        bool wasFlying_ { false };
        bool carrierAtRest_ { true };
    };

    explicit Flickable(State *newState):
        Control{newState}
    {}

    explicit Flickable(CreateState createState):
        Control{createState}
    {}

    State &me() { return View::me().as<State>(); }
    const State &me() const { return View::me().as<State>(); }
};

} // namespace cc
