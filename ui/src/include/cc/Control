/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/View>
#include <cc/Cursor>

namespace cc {

class Flickable;

/** \class Control cc/Control
  * \ingroup ui
  * \brief %User interaction control
  */
class Control: public View
{
public:
    /** Create a primordial control
      */
    Control();

    /** Create a new control and return a reference to itself
      */
    explicit Control(Out<Control> self):
        View{new State}
    {
        self = weak<Control>();
    }

    /** Create a new top-level control of size (\a width, \a height)
      */
    Control(double width, double height):
        View{new State}
    {
        size(Size{width, height});
    }

    Control delegate() const; ///< Delegate for handling user input

    bool hover() const { return me().hover(); } ///< %Pointer is currently hovering over this control
    bool pressed() const { return me().pressed(); } ///< %Control is currently pressed by the user
    bool focus() const { return me().focus(); } ///< %Control has text input focus

    Control &focus(bool newValue); ///< %Grab or release input focus

    Cursor cursor() const { return me().cursor(); } ///< Get cursor
    Control &cursor(Cursor newValue) { me().cursor(newValue); return *this; } ///< %Set cursor
    Control &cursor(Definition<Cursor> &&f) { me().cursor(std::move(f)); return *this; } ///< %Define cursor

    Point pointerPos() const { return me().pointerPos(); } ///< %Pointer position when hovered, pressed or clicked

    /** %Handle clicked event
      */
    Control &onClicked(Call<void()> &&f)
    {
        me().onPointerClicked(
            [=](const PointerEvent &){ f(); return true; }
        );
        return *this;
    }

    /** %Handle pointer clicked event
      */
    Control &onPointerClicked(Filter<PointerEvent> &&f) { me().onPointerClicked(std::move(f)); return *this; }

    /** %Handle mouse clicked event
      */
    Control &onMouseClicked(Filter<MouseEvent> &&f) { me().onMouseClicked(std::move(f)); return *this; }

    /** %Handle finger clicked event
      */
    Control &onFingerClicked(Filter<FingerEvent> &&f) { me().onFingerClicked(std::move(f)); return *this; }

protected:
    friend class Object;
    friend class Application;
    friend class Flickable;

    /** \brief Internal state
      */
    struct State: public View::State
    {
        State();
        void grabFocus();
        void releaseFocus();

        virtual Control delegate() const;

        virtual Rect textInputArea() const;
        virtual void onTextEdited(const String &text, int start, int length);
        virtual void onTextInput(const String &text);

        Control self() const { return Object::alias<Control>(this); }

        Property<Cursor> cursor; ///< %Pointer cursor when the pointer is over this control

        Property<bool> hover; ///< \copydoc Control::hover()
        Property<bool> pressed; ///< \copydoc Control::pressed()
        Property<bool> pressedOverwrite;
        Property<bool> focus; ///< \copydoc Control::focus()

        Property<Point> pointerPos; ///< \copydoc Control::pointerPos

        Event<PointerEvent> onPointerClicked; ///< %Control has been pressed and released
        Event<MouseEvent> onMouseClicked; ///< %Control has been clicked by the mouse
        Event<FingerEvent> onFingerClicked; ///< %Control has been pressed and released by a touch input
    };

    explicit Control(State *newState):
        View{newState}
    {}

    static View::State *createState()
    {
        return new State;
    }

    explicit Control(CreateState onDemand):
        View{onDemand}
    {}

    State &me() {
        return View::me().as<State>();
    }

    const State &me() const {
        return View::me().as<State>();
    }

    State *operator->() { return &me(); }
    const State *operator->() const { return &me(); }
};

} // namespace cc
