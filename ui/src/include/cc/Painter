/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Surface>
#include <cc/Pen>
#include <cc/types>
#include <cc/Exception>

typedef struct _cairo cairo_t;

namespace cc {

class GlyphRun;
class TextRun;
class FtGlyphRun;

/** \class Painter cc/Painter
  * \ingroup ui
  * \brief Drawing 2D vector graphics
  * \exception PainterError
  */
class Painter
{
public:
    /** \name Painter State
      */
    ///@{

    /** Create a new painter for \a surface
      */
    explicit Painter(const Surface &surface);

    /** Create a new painter
      */
    explicit Painter(Surface::State *state);

    ~Painter();

    Painter &save(); ///< Save painter state to the top of the state stack
    Painter &restore(); ///< Restore painter state from the top of the state stack

    /** Emit current page
      * \param clear Start with clean page
      */
    Painter &nextPage(bool clear = true);
    ///@}

    /** \name Path Creation
      */

    ///@{
    Painter &newPath(); ///< Start a new path
    Painter &newSubPath(); ///< Start a new sub-path without setting an initial current point
    Painter &closePath(); ///< Close path with a line segment

    bool hasCurrentPoint() const; ///< Check if there is a current point
    Point currentPoint() const; ///< Get the current point
    Painter &moveTo(Point c); ///< Start a new sub-path starting at \a c
    Painter &lineTo(Point c); ///< Add a line segment to the path from the current point to the new current point \a c
    Painter &curveTo(Point a, Point b, Point c); ///< Add a cubic BÃ©zier spline starting in the current point, spanning over control points \a a, \a b and ending in the new current point \a c
    Painter &arc(Point m, double r, double alpha0 = 0, double alpha1 = 2 * M_PI); ///< Add a circular arc of radius \a r centered at \a m starting at angle \a alpha0 and ending at angle \a alpha1 (in radians)
    Painter &arcNegative(Point m, double r, double alpha0, double alpha1); ///< Add a circular arc with \a alpha1 < \a alpha0

    Painter &rectangle(Point pos, Size size); ///< Add a closed sub-path in form of a rectangle with top-left at \a pos and given dimensions \a size

    Rect pathExtents() const; ///< Get the current path's extents
    Rect fillExtents() const; ///< Get the current path's exact rasterization extents

    ///@}

    using GetColor = Fun<Color(int)> ; ///< Get color for a given byte offset

    /** \name Text Rendering
      */
    ///@{

    /** Show glyph run
      * \param pos %Baseline position
      * \param run %Glyph run
      */
    Painter &showGlyphRun(Point pos, const GlyphRun &run);

    /** Show glyph run with additional colors
      * \param pos %Baseline position
      * \param run %Glyph run
      * \param ink %Foreground colors
      * \param paper %Background colors
      */
    Painter &showGlyphRun(Point pos, const GlyphRun &run, const GetColor &ink, const GetColor &paper = GetColor{});

    /** Show text run
      * \param pos %Baseline position
      * \param run %Text run
      */
    Painter &showTextRun(Point pos, const TextRun &run);

    /** Show text run with additional colors
      * \param pos %Baseline position
      * \param run %Text run
      * \param ink %Foreground colors
      * \param paper %Background colors
      */
    Painter &showTextRun(Point pos, const TextRun &run, const GetColor &ink, const GetColor &paper);

    ///@}

    /** \name Coordinate System Transformations
      */
    ///@{

    Painter &translate(Step step); ///< Move coordinate system by \a step
    Painter &scale(Scale ratio); ///< Scale coordinate system by \a ratio
    Painter &rotate(double angle); ///< Rotate coordinate system by \a angle (in radians)

    ///@}

    /** \name Drawing
      */
    ///@{

    Painter &setPen(Color color); ///< %Set source color
    Painter &setPen(const Pen &pen); ///< %Set source color and line style in one go

    /** Tells if to delete the current path after a stroke or fill operation
      */
    enum class CurrentPath {
        Clear, ///< %Clear the current path from the painting context
        Preserve ///< %Preserve the painting context's current path
    };

    /** Fill the current path
      * \param mode \copydoc CurrentPath
      */
    Painter &fill(CurrentPath mode = CurrentPath::Clear);

    /** Stroke the outline of the current path
      * \param mode \copydoc CurrentPath
      */
    Painter &stroke(CurrentPath mode = CurrentPath::Clear);

    ///@}

private:
    Painter(const Painter &) = delete;

    void fillGlyphRunBackground(const FtGlyphRun &ftGlyphRun);

    void setLineWidth(double width); ///< %Set current line width
    void setLineCap(LineCap style); ///< %Set line cap style
    void setLineJoin(LineJoin style); ///< %Set line join style
    void setMiterLimit(double limit); ///< %Set limit for automatically switching between miter and bevel joins (limit = 1/sin(angle/2))
    void setLineDash(const Array<double> &pattern, double offset = 0); ///< %Set line dash pattern

    cairo_t *cr_;
    Surface::State *state_;
};

/** \class PainterError cc/Painter
  * \brief Something went wrong during painting
  */
class PainterError: public Exception
{
public:
    PainterError(int errorStatus);
    String message() const override;

private:
    int errorStatus_;
};

} // namespace cc
