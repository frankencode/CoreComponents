/*
 * Copyright (C) 2020-2022 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/ui/StylePlugin>
#include <cc/ui/MouseEvent>
#include <cc/ui/FingerEvent>
#include <cc/ui/WheelEvent>
#include <cc/ui/KeyEvent>
#include <cc/ui/Image>
#include <cc/ui/Event>
#include <cc/ui/Easing>
#include <cc/ui/Padding>
#include <cc/Trigger>
#include <cc/Map>
#include <cc/IndexTracking>
#include <cc/Monitor>
#include <limits>
#include <cassert>

namespace cc::ui {

class Window;
class Control;
class Flickable;

/** \class View cc/ui/View
  * \ingroup ui
  * \brief %User interface building block
  */
class View: public Surface
{
protected:
    struct State;

public:
    /** %View identifier
      */
    using Id = double;

    /** \name Construction
      */
    ///@{

    /** Create a primordial view
      */
    View() = default;

    /** Create a new view and return a copy of itself
      */
    explicit View(Out<View> self):
        View{new State}
    {
        self = *this;
    }

    /** Create a new view of size (\a width, \a height)
      */
    explicit View(double width, double height):
        View{new State}
    {
        size(Size{width, height});
    }

    /** Invoke custom setup function \a f
      */
    View &setup(const std::function<void(View &)> &&f)
    {
        f(*this);
        return *this;
    }

    /** Materialize a primordial view
      */
    void touch()
    {
        me();
    }

    ///@}

    /** \name View Properties
      */
    ///@{

    /** Define foreground
      */
    View &paint(Definition<void> &&f) { me().paint(std::move(f)); return *this; }

    Color paper() const { return me().paper(); } ///< Get background color
    View &paper(Color newValue) { me().paper(newValue); return *this; } ///< %Set background color
    View &paper(Definition<Color> &&f) { me().paper(std::move(f)); return *this; } ///< Define background color

    bool visible() const { return me().visible(); } ///< Get visible
    View &visible(bool newValue) { me().visible(newValue); return *this; } ///< %Set visible
    View &visible(Definition<bool> &&f) { me().visible(std::move(f)); return *this; } ///< Define visible
    View &onVisibleChanged(Call<void()> &&f) { me().visible.onChanged(std::move(f)); return *this; } ///< \todo remove this method

    double opacity() const { return me().opacity(); } ///< Get opacity
    View &opacity(double newValue) { me().opacity(newValue); return *this; } ///< %Set opacity
    View &opacity(Definition<double> &&f) { me().opacity(std::move(f)); return *this; } ///< Define opacity
    View &opacityEasing(const EasingCurve &easing, double duration) { Easing{me().opacity, easing, duration}; return *this; } ///< %Set easing on opacity

    bool clip() const { return me().clip(); } ///< Get clip
    View &clip(bool newValue) { me().clip(newValue); return *this; } ///< %Set clip
    View &clip(Definition<bool> &&f) { me().clip(std::move(f)); return *this; } ///< Define clip

    bool moving() const { return me().moving(); } ///< Get moving
    View &moving(bool newValue) { me().moving(newValue); return *this; } ///< %Set moving
    View &moving(Definition<bool> &&f) { me().moving(std::move(f)); return *this; } ///< Define moving

    Point pos() const { return me().pos(); } ///< Get position
    View &pos(Point newValue) { me().pos(newValue); return *this; } ///< %Set position
    View &pos(double x, double y) { me().pos(Point{x, y}); return *this; } ///< %Set position
    View &pos(Definition<Point> &&f) { me().pos(std::move(f)); return *this; } ///< Define position
    View &posEasing(const EasingCurve &easing, double duration) { Easing{me().pos, easing, duration}; return *this; } ///< %Set easing on position

    Size size() const { return me().size(); } ///< Get size
    double x() const { return me().pos()[0]; } ///< Get pos()[0]
    double y() const { return me().pos()[1]; } ///< Get pos()[1]
    double width() const { return me().width(); } ///< Get size()[0]
    double height() const { return me().height(); } ///< Get size()[1]
    double innerWidth() const { return me().innerWidth(); } ///< Get inner width
    double innerHeight() const { return me().innerHeight(); } ///< Get inner height
    View &size(Size newValue) { me().size(newValue); return *this; } ///< %Set size to \a newValue
    View &size(double width, double height) { me().size = Size{width, height}; return *this; } ///< %Set size to Size{\a width, \a height}
    View &size(Definition<Size> &&f) { me().size(std::move(f)); return *this; } ///< Define size
    View &sizeEasing(const EasingCurve &easing, double duration) { Easing{me().size, easing, duration}; return *this; } ///< %Set easing on size

    Padding padding() const { return me().padding(); } ///< Get padding
    View &padding(const Padding &newValue) { me().padding(newValue); return *this; } ///< %Set padding
    View &padding(Definition<Padding> &&f) { me().padding(std::move(f)); return *this; } ///< Define padding

    Point pivot() const { return me().pivot(); } ///< Get rotation center
    View &pivot(Point newValue) { me().pivot(newValue); return *this; } ///< %Set rotation center
    View &pivot(Definition<Point> &&f) { me().pivot(std::move(f)); return *this; } ///< Define rotation center
    View &pivotEasing(const EasingCurve &easing, double duration) { Easing{me().pivot, easing, duration}; return *this; } ///< %Set easing on rotation center

    double angle() const { return me().angle(); } ///< Get rotation angle
    View &angle(double newValue) { me().angle(newValue); return *this; } ///< %Set rotation angle
    View &angle(Definition<double> &&f) { me().angle(std::move(f)); return *this; } ///< Define rotation angle
    View &angleEasing(const EasingCurve &easing, double duration) { Easing{me().angle, easing, duration}; return *this; } ///< %Set easing on rotation angle

    double scale() const { return me().scale(); } ///< Get scale factor
    View &scale(double newValue) { me().scale(newValue); return *this; } ///< %Set scale factor
    View &scale(Definition<double> &&f) { me().scale(std::move(f)); return *this; } ///< Define scale factor
    View &scaleEasing(const EasingCurve &easing, double duration) { Easing{me().scale, easing, duration}; return *this; } ///< %Set easing on scale

    View decoration() const { return me().decoration(); } ///< Get decoration
    View &decorate(const View &newValue) { me().decoration(newValue); return *this; } ///< %Set decoration \see Shadow
    View &decorate(Definition<View> &&f) { me().decoration(std::move(f)); return *this; } ///< Define decoration \see Shadow

    Size preferredSize() const { return me().preferredSize(); } ///< Get preferred size
    Size minSize() const { return me().minSize(); } ///< Get minimal size
    Size maxSize() const { return me().maxSize(); } ///< Get maximal size

    Color basePaper() const { return me().basePaper(); } ///< Get the background paper

    const char *objectName() const { return me().objectName_; } ///< Get the object name (for debugging)
    View &objectName(const char *name) { me().objectName_ = name; return *this; } ///< %Set the object name

    bool hasWindow() const { return me().hasWindow(); } ///< Check if this view is already shown in a window
    Window window() const; ///< Get the window this view is shown in

    bool isHandheld() const { return me().isHandheld(); } ///< Get window().display().isHandheld()

    ///@}

    /** \name View Hierarchy
      */
    ///@{

    /** Get view identifier
      */
    Id id() const { return me().id_; }

    /** Lower than operator
      */
    bool operator<(const View &other) const { return id() < other.id(); }

    /** Check if this is a child view
      */
    bool hasParent() const { return me().hasParent(); }

    /** Get parent view
      */
    View parent() const { return me().parent(); }

    /** Get the root view of this window
      */
    View root() const
    {
        View v = *this;
        while (v.hasParent()) v = v.parent();
        return v;
    }

    /** Number of children
      */
    long childrenCount() const { return me().childrenCount(); }

    /** Check if there are any children
      */
    bool hasChildren() const { return me().childrenCount() > 0; }

    /** Add a new \a child
      */
    View &add(const View &child)
    {
        me().insertChild(child);
        return *this;
    }

    /** Insert a new \a child at position \a pos
      */
    View &insertAt(Locator pos, const View &child)
    {
        me().insertAt(pos, child);
        return *this;
    }

    /** Remove a child
      */
    View &remove(const View &child)
    {
        me().removeChild(child);
        return *this;
    }

    /** Remove all children
      */
    void deplete() { me().deplete(); }

    /** Make this view be visible above any other visible sibling
      */
    void moveToTop() { me().moveToTop(); }

    /** Make this view be visible beneath any other visible sibling
      */
    void moveToBottom() { me().moveToBottom(); }

    /** Get all children views
      */
    const Set<View> &children() const { return me().children_; }

    /** Get visible children views
      */
    const Set<View> &visibleChildren() const { return me().visibleChildren_; }

    /** %Map view coordinates \a l to window coordinates
      */
    Point mapToGlobal(Point l) const { return me().mapToGlobal(l); }

    /** %Map window coordinates \a g to view coordinates
      */
    Point mapToLocal(Point g) const { return me().mapToLocal(g); }

    /** %Map local coordinates \a l to \a child coordinates
      */
    Point mapToChild(const View &child, Point l) const { return me().mapToChild(child, l); }

    /** %Map local coordinates \a l to \a parent coordinates
      */
    Point mapToParent(const View &parent, Point l) const { return me().mapToParent(parent, l); }

    /** Check if local point \a l lays inside this view
      */
    bool containsLocal(Point l) const { return me().withinBounds(l); }

    /** Check if global point \a l lays inside this view
      */
    bool containsGlobal(Point g) const { return me().withinBounds(mapToLocal(g)); }

    /** Find the first child which contains local point \a l
      */
    View findChild(Point l) const { return me().findChild(l); }

    /** Find the first control which contains local point \a l
      */
    Control findControl(Point l) const;

    /** Check if this view is parent of \a other
      */
    bool isParentOf(const View &other) const { return me().isParentOf(other); }

    /** Check if this view is fully visible inside \a other with given surrounding \a margin
      */
    bool laysInsideOf(const View &other, double margin) const { return me().laysInsideOf(other, margin); }

    template<class ViewType>
    void collectVisible(InOut<List<ViewType>> collection) const
    {
        for (const View &child: visibleChildren()) {
            child.collectVisible<ViewType>(collection);
        }

        if (is<ViewType>()) {
            collection->append(as<ViewType>());
        }
    }

    /** \brief %Automatic geometry for children views
      * \ingroup ui_layout
      */
    class Layout: public Object
    {
    public:
        /** Create a null layout
          */
        Layout() = default;

        Orientation orientation() const { return me().orientation(); }

        Size margin() const { return me().margin(); } ///< Get inner layout margins
        Layout &margin(Size newValue) { me().margin(newValue); return *this; } ///< %Set inner layout margins

        double spacing() const { return me().spacing(); } ///< Get layout spacing
        Layout &spacing(double newValue) { me().spacing(newValue); return *this; } ///< %Set layout spacing

        Size minSize() const { return me().minSize(); } ///< Get the minimum size of the layout
        Size maxSize() const { return me().maxSize(); } ///< Get the maximum size of the layout
        Size preferredSize() const { return me().preferredSize(); } ///< Get the preferred size of the layout

        bool isManaged() const { return me().isManaged(); }

    protected:
        friend class View;

        struct State: public Object::State
        {
            State() = default;

            bool hasView() const { return view_() != nullptr; }

            virtual bool isManaged() const { return false; }

            virtual Orientation orientation() const = 0;

            View::State &view() { return *view_(); }

            Property<Size> margin;
            Property<double> spacing { 0 };
            Property<Size> minSize;
            Property<Size> maxSize { Size{std::numeric_limits<double>::max()} };
            Property<Size> preferredSize;
            Property<View::State *> view_ { nullptr };
        };

        explicit Layout(State *state):
            Object{state}
        {}

        State &me() { return Object::me.as<State>(); }
        const State &me() const { return Object::me.as<State>(); }
    };

    Layout layout() const { return me().layout(); } ///< Get layout

    View &layout(const Layout &newValue) { me().layout(newValue); return *this; } ///< %Set layout

    ///@}

    /** \name Positional Anchors
      */
    ///@{

    double top   () const { return pos()[1]; } ///< Get y-coordinate of this view's top border
    double bottom() const { return pos()[1] + size()[1]; } ///< Get y-coordinate of this view's bottom border
    double left  () const { return pos()[0]; } ///< Get x-coordinate of this view's left border
    double right () const { return pos()[0] + size()[0]; } ///< Get x-coordinate of this view's right border

    Point topLeft    () const { return pos(); } ///< Get this view's top-left corner
    Point topRight   () const { return pos() + Step{size()[0], 0}; } ///< Get this view's top-right corner
    Point bottomLeft () const { return pos() + Step{0, size()[1]}; } ///< Get this view's bottom-left corner
    Point bottomRight() const { return pos() + size(); } ///< Get this view's bottom-right corner
    Point centerLeft () const { return pos() + Step{0, size()[1] / 2}; } ///< Get this view's center-left point
    Point centerRight() const { return pos() + Step{size()[0], size()[1] / 2}; } ///< Get this view's center-right point

    View &topLeft    (Definition<Point> &&a) { pos(std::move(a));                                                               return *this; } ///< %Anchor the top-left corner to \a a
    View &topRight   (Definition<Point> &&a) { pos([self = me(), a]{ return a() - Step{self.size()[0], 0};                  }); return *this; } ///< %Anchor the top-right corner to \a a
    View &bottomLeft (Definition<Point> &&a) { pos([self = me(), a]{ return a() - Step{0, self.size()[1]};                  }); return *this; } ///< %Anchor the bottom-left corner to \a a
    View &bottomRight(Definition<Point> &&a) { pos([self = me(), a]{ return a() - self.size();                              }); return *this; } ///< %Anchor the bottom-right corner to \a a
    View &centerLeft (Definition<Point> &&a) { pos([self = me(), a]{ return a() - Step{0, self.size()[1] / 2};              }); return *this; } ///< %Anchor the center-left to \a a
    View &centerRight(Definition<Point> &&a) { pos([self = me(), a]{ return a() - Step{self.size()[0], self.size()[1] / 2}; }); return *this; } ///< %Anchor the center-right to \a a
    View &center     (Definition<Point> &&a) { pos([self = me(), a]{ return a() - self.size() / 2;                          }); return *this; } ///< %Anchor the center to \a a

    /** Anchor this view's center to its parent's center
      */
    View &centerInParent()
    {
        pos([self = me()]{ return self.parent() ? (self.parent().size() - self.size()) / 2 : Point{}; });
        return *this;
    }

    ///@}

    /** \name Triggers and Events
      */
    ///@{

    /** %Handle window enter event
      */
    View &onWindowEntered(Call<void()> &&f) { me().onWindowEntered(std::move(f)); return *this; }

    /** %Handle window leave event
      */
    View &onWindowLeft(Call<void()> &&f) { me().onWindowLeft(std::move(f)); return *this; }

    /** %Handle pointer pressed event
      */
    View &onPointerPressed(Filter<PointerEvent> &&f) { me().onPointerPressed(std::move(f)); return *this; }

    /** %Handle pointer release event
      */
    View &onPointerReleased(Filter<PointerEvent> &&f) { me().onPointerReleased(std::move(f)); return *this; }

    /** %Handle pointer moved event
      */
    View &onPointerMoved(Filter<PointerEvent> &&f) { me().onPointerMoved(std::move(f)); return *this; }

    /** %Handle move pressed event
      */
    View &onMousePressed(Filter<MouseEvent> &&f) { me().onMousePressed(std::move(f)); return *this; }

    /** %Handle mouse release event
      */
    View &onMouseReleased(Filter<MouseEvent> &&f) { me().onMouseReleased(std::move(f)); return *this; }

    /** %Handle move moved event
      */
    View &onMouseMoved(Filter<MouseEvent> &&f) { me().onMouseMoved(std::move(f)); return *this; }

    /** %Handle finger pressed event
      */
    View &onFingerPressed(Filter<FingerEvent> &&f) { me().onFingerPressed(std::move(f)); return *this; }

    /** %Handle finger released event
      */
    View &onFingerReleased(Filter<FingerEvent> &&f) { me().onFingerReleased(std::move(f)); return *this; }

    /** %Handle finger moved event
      */
    View &onFingerMoved(Filter<FingerEvent> &&f) { me().onFingerMoved(std::move(f)); return *this; }

    /** %Handle mouse wheel moved event
      */
    View &onWheelMoved(Filter<WheelEvent> &&f) { me().onWheelMoved(std::move(f)); return *this; }

    /** %Handle key pressed event
      */
    View &onKeyPressed(Filter<KeyEvent> &&f) { me().onKeyPressed(std::move(f)); return *this; }

    /** %Handle key released event
      */
    View &onKeyReleased(Filter<KeyEvent> &&f) { me().onKeyReleased(std::move(f)); return *this; }

    /** Get notified when the View's lifetime ends
      */
    View &onEndOfLife(Call<void()> &&f) { return attach(OnEndOfLife{std::move(f)}); }

    ///@}

    /** \name Triggers and Events
      */
    ///@{

    /** Attach a non-visual object (e.g. a Monitor)
      */
    View &attach(const Object &other) { me().attachments_.append(other); return *this; }

    /** Convenience method for attaching a monitor
      */
    View &attach(Call<void()> &&f) { return attach(Monitor{std::move(f)}); }

    ///@}

protected:
    friend class Object;
    friend class Application;
    friend class Window;
    friend class Layout;
    friend class Control;
    friend class Flickable;
    friend class Painter;
    friend class IndexTracking<View>;

    /** \brief Internal state
      */
    struct State: public Surface::State
    {
        Property<void> paint; ///< %Painting monitor
        Property<Color> paper; ///< %Background color
        Property<bool> visible { true }; ///< %Visiblity
        Property<double> opacity { 1. }; ///< Opacity (0: fully transparent, 1: fully opaque)
        Property<bool> clip { false }; ///< %Clip children views
        Property<bool> moving { false };

        Property<Point> pos; ///< %Position within its parent
        Property<Size> size; ///< %Size of this view
        Property<Padding> padding; ///< %Padding to apply when adding this view to a layout

        Property<Point> pivot { [this]{ return size() / 2; } }; ///< %Rotation center
        Property<double> angle { 0 }; ///< %Rotation angle
        Property<double> scale { 1 }; ///< %Zoom factor

        Property<long> childrenCount { 0 }; ///< %Number of children

        Property<View> decoration;

        Trigger onWindowEntered; ///< Triggered when the pointer enters the window
        Trigger onWindowLeft; ///< Triggered when the pointer leaves the window

        Event<PointerEvent> onPointerPressed; ///< %Pointing device is pressed over this view
        Event<PointerEvent> onPointerReleased; ///< %Pointing device is released over this view
        Event<PointerEvent> onPointerMoved; ///< %Pointer moved over this view

        Event<MouseEvent> onMousePressed; ///< %Mouse is pressed over this view
        Event<MouseEvent> onMouseReleased; ///< %Mouse is released over this view
        Event<MouseEvent> onMouseMoved; ///< %Mouse moved over this view

        Event<FingerEvent> onFingerPressed; ///< %Finger contact started over this view
        Event<FingerEvent> onFingerReleased; ///< %Finger contact ended over this view
        Event<FingerEvent> onFingerMoved; ///< %Finger contact moved over this view

        Event<WheelEvent> onWheelMoved; ///< %Mouse wheel is moved

        Event<KeyEvent> onKeyPressed; ///< %Keyboard key is pressed
        Event<KeyEvent> onKeyReleased; ///< %Keyboard key is released

        State();
        ~State();

        const char *objectName() const { return objectName_; } ///< \copydoc View::objectName()
        void objectName(const char *name) { objectName_ = name; }  ///< \copydoc View::objectName(const char *name)

        bool hasParent() const { return parent_(); } ///< %Check if this view has a parent

        View parent() const { return Object::alias<View>(parent_()); } ///< Get the parent

        const Set<View> &children() const { return children_; } ///< Get set of all children
        const Set<View> &visibleChildren() const { return visibleChildren_; } ///< Get set of visible children

        /** Remove all children
          */
        void deplete()
        {
            visibleChildren_.deplete();
            children_.deplete();
        }

        double x() const { return pos()[0]; } ///< Get pos().x()
        double y() const { return pos()[1]; } ///< Get pos().y()
        double width() const { return width_(); } ///< Get width
        double height() const { return height_(); } ///< Get height

        double innerWidth() const { return width() - (layout_ ? 2 * layout_.margin()[0] : 0); } ///< Get inner width
        double innerHeight() const { return height() - (layout_ ? 2 * layout_.margin()[1] : 0); } ///< Get inner height

        Layout layout() const { return layout_; } ///< Get the layout
        double expandableWidth(double width) const; ///< Get the expandable width of this view within its parent layout

        /** %Set the layout
          */
        void layout(const Layout &newValue)
        {
            layout_ = newValue;
            layout_.me().view_ = this;
        }

        Point mapToGlobal(Point l) const; ///< \copydoc View::mapToGlobal()
        Point mapToLocal(Point g) const; ///< \copydoc View::mapToLocal()
        Point mapToChild(const View &child, Point l) const; ///< \copydoc View::mapToChild()
        Point mapToParent(const View &parent, Point l) const; ///< \copydoc View::mapToParent()

        View findChild(Point l) const; ///< \copydoc View::findChild()
        Control findControl(Point l) const; ///< \copydoc View::findControl()
        bool isParentOf(const View &other) const; ///< \copydoc View::isParentOf()
        bool laysInsideOf(const View &other, double margin = 0.) const; ///< \copydoc View::laysInsideOf()

        virtual Size preferredSize() const { return layout() ? layout().preferredSize() : Size{}; } ///< \copydoc View::preferredSize()
        virtual Size minSize() const { return layout() ? layout().minSize() : Size{}; } ///< \copydoc View::minSize()
        virtual Size maxSize() const { return layout() ? layout().maxSize() : Size{std::numeric_limits<double>::max()}; }  ///< \copydoc View::maxSize()

        virtual bool isOpaque() const { return paper().isOpaque(); } ///< Tells the graphics engine if all pixels of this view are fully opaque
        virtual bool isPainted() const { return paper().isValid() && size()[0] > 0 && size()[1] > 0; } ///< Tells the graphics engine if this view has visible pixels
        virtual bool isStatic() const { return true; } ///< Tells the graphics engine if this view is static (i.e. is not changing with each frame)

        Color basePaper() const; ///< %Search upwards in the view hierarchy for the first valid background color

        /** Check if local point \a l is inside this view
          */
        virtual bool withinBounds(Point l) const
        {
            return
                0 <= l[1] && l[1] < size()[1] &&
                0 <= l[0] && l[0] < size()[0];
        }

        bool containsLocal(Point l) const { return withinBounds(l); } ///< \copydoc View::containsLocal()
        bool containsGlobal(Point g) const { return withinBounds(mapToLocal(g)); } ///< \copydoc View::containsGlobal()

        virtual void childReady(InOut<View> child); ///< Called when a new child has been added
        virtual void childDone(InOut<View> child); ///< Called after a child had been removed
        virtual void settled(); ///< Called on the child after it has been added (ideal place for setting up easing behavior / transitions)

        void add(const View &child) { insertChild(child); } ///< \copydoc View::add()
        void insertAt(Locator pos, View child); ///< \copydoc View::insertAt()
        void remove(const View &child) { removeChild(child); } ///< \copydoc View::remove()

        virtual void insertChild(View child); ///< Handles the insertion of new children
        virtual void removeChild(View child); ///< Handles the removal of children

        void moveToTop() { if (hasParent()) parent().me().moveToTop(self()); } ///< \copydoc View::moveToTop();
        void moveToBottom() { if (hasParent()) parent().me().moveToBottom(self()); } ///< \copydoc View::moveToBottom()
        void moveToTop(View child); ///< Make \a child visible above all its siblings
        void moveToBottom(View child); ///< Make \a child visible beneath all its siblings

        Image image(); ///< Painting target
        void image(const Image &newValue) { image_ = newValue; } ///< %Set painting target

        View self() const; ///< Get a view from this state
        bool hasWindow() const { return window_(); } /// \copydoc View::hasWindow()
        Window window() const; ///< \copydoc View::window()

        bool isHandheld() const; ///< \copydoc View::isHandheld()

        void clear(Color color) { if (color) image().clear(color.premultiplied()); }
        void clear() { clear(paper()); }

        void polish() override { clear(); }

    protected:
        friend class View;
        friend class Application;
        friend class Window;
        friend class IndexTracking<View>;

        Id nextId() const { return children_.count() == 0 ? 1 : children_.max().id() + 1; }

        cairo_surface_t *cairoSurface() override;

        void update(UpdateReason reason);

        virtual bool feedExposedEvent() const;
        virtual bool feedEnterEvent() const;
        virtual bool feedLeaveEvent() const;

        virtual bool feedFingerEvent(FingerEvent &event) const;
        virtual bool feedMouseEvent(MouseEvent &event) const;
        virtual bool feedWheelEvent(WheelEvent &event) const;
        virtual bool feedKeyEvent(KeyEvent &event) const;

        Id id_ { std::numeric_limits<double>::quiet_NaN() };
        const char *objectName_ { "" };

        Property<View::State *> parent_ { nullptr };
        Property<Object::State *> window_ { [this]{ return parent_() ? parent_()->window_() : nullptr; } };

        Property<double> width_ { [this]{ return size()[0]; } };
        Property<double> height_ { [this]{ return size()[1]; } };

        Set<View> children_;
        Set<View> visibleChildren_;
        List<Object> attachments_;

        Image image_;
        Layout layout_;
        Object context_;
        void *trackingHandle_ { nullptr };
    };

    /** Initialize view
      */
    explicit View(State *newState):
        Surface{newState}
    {}

    using CreateState = State *();

    template<class T>
    static View::State *onDemand() { return new T; }

    /** Initialize view
      */
    explicit View(CreateState onDemand):
        onDemand_{onDemand}
    {}

    State &me() {
        if (!Object::me) Object::me = onDemand_();
        return Object::me.as<State>();
    }

    const State &me() const {
        if (!Object::me) Object::me = onDemand_();
        return Object::me.as<State>();
    }

private:
    static State *createState() { return new State; }

    CreateState *onDemand_ { &createState };

    /** \internal
      * Detach all non-visual objects
      */
    void detachAll()
    {
        for (const View &child: me().children_) const_cast<View &>(child).detachAll();
        me().attachments_.deplete();
    }

    State *operator->() { return &me(); }
    const State *operator->() const { return &me(); }
};

} // namespace cc::ui

namespace cc {

template<>
class IndexTracking<ui::View> {
public:
    static void setHandle(ui::View &view, void *handle) { if (view) view->trackingHandle_ = handle; }
    static void *handle(const ui::View &view) { return (view) ? view->trackingHandle_ : nullptr; }
};

} // namespace cc
