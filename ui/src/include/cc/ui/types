/*
 * Copyright (C) 2017-2018 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <limits>
#include <cc/bitmask>
#include <cc/Property>
#include <cc/string>
#include <cc/Color>
#include <cc/ui/Rect>

namespace cc {
namespace ui {

using cc::str;

/** text anti-aliasing strategy
  */
enum class FontSmoothing: uint8_t {
    Default      = 0,
    None         = 1,
    Grayscale    = 2,
    RgbSubpixel  = 3,
    BgrSubpixel  = 4,
    VrgbSubpixel = 5,
    VbgrSubpixel = 6
};

string str(FontSmoothing smoothing);

/** glyph outline hinting strategy
  */
enum class OutlineHinting: uint8_t {
    Default = 0,
    None    = 1,
    Slight  = 2,
    Medium  = 3,
    Full    = 4,
};

string str(OutlineHinting outlineHinting);

/** return hinted font metrics
  * \see Font::getMetrics()
  */
enum class MetricsHinting: uint8_t {
    Default = 0,
    Off     = 1,
    On      = 2
};

string str(MetricsHinting metricsHinting);

/** font slant
  */
enum class Slant: uint8_t {
    Normal,
    Italic,
    Oblique = Italic
};

string str(Slant slant);

/** visual thickness of a font
  */
enum class Weight: uint8_t {
    Thin       = 1,
    ExtraLight = 2,
    Light      = 3,
    Normal     = 4,
    Medium     = 5,
    SemiBold   = 6,
    Bold       = 7,
    ExtraBold  = 8,
    Black      = 9
};

string str(Weight weight);

/** font width to height ratio
  */
enum class Stretch: uint8_t {
    UltraCondensed = 1,
    ExtraCondensed = 2,
    Condensed      = 3,
    SemiCondensed  = 4,
    Normal         = 5,
    SemiExpanded   = 6,
    Expanded       = 7,
    ExtraExpanded  = 8,
    UltraExpanded  = 9
};

string str(Stretch stretch);

/** font pitch
  */
enum class Pitch: uint8_t {
    Fixed,   ///< monospace font
    Variable ///< variable-width font
};

string str(Pitch pitch);

/** text alignment
  */
enum class TextAlign: uint8_t {
    Left,   ///< align left
    Right,  ///< align right
    Center, ///< align center
    Justify ///< align justify
};

string str(TextAlign align);

/** text decoration
  */
enum class Decoration: uint8_t {
    None      = 0,
    Underline = 1,
    StrikeOut = 2
};

CC_BITMASK(Decoration, uint8_t)

string str(Decoration decoration);

/** alignment within a Column
  */
enum class ColumnAlign {
    Auto,  ///< align according to language preference
    Left,  ///< align left
    Right, ///< align right
    Center ///< align center
};

string str(ColumnAlign align);

/** alignment within a Row
  */
enum class RowAlign {
    Top,    ///< align top
    Bottom, ///< align bottom
    Center  ///< align center
};

string str(RowAlign align);

/** mouse button flags
  */
enum class MouseButton: unsigned int {
    None   = 0,
    Left   = 1,
    Right  = 2,
    Middle = 4,
    X1     = 8,
    X2     = 16
};

CC_BITMASK(MouseButton, unsigned int);

string str(MouseButton mask);

/** event type of touch, mouse or pen input
  */
enum class PointerAction {
    Moved,
    Pressed,
    Released
};

string str(PointerAction action);

enum class KeyAction {
    Pressed,
    Released
};

string str(KeyAction action);

enum class CursorShape {
    Arrow,
    IBeam,
    Wait,
    CrossHair,
    WaitArrow,
    ResizeNorthWestSouthEast,
    ResizeNorthEastSouthWest,
    ResizeWestEast,
    ResizeNorthSouth,
    ResizeCross,
    Forbidden,
    Hand
};

string str(CursorShape shape);

typedef Vector<double, 2> Step;
typedef Vector<double, 2> Scale;

typedef std::function<bool(const string &/*text*/, int /*byteOffset*/, int /*byteCount*/)> TextWrapBehind;
bool textWrapBehindDefault(const string &text, int byteOffset, int byteCount);

typedef int64_t TouchDeviceId;
typedef int64_t TouchFingerId;

/// translate \a angle in degree (0..360) to radians (0..2*M_PI)
double degree(double angle);

/// translate design units to pixels
double dp(double x);

/// translate design units to scaled pixels
double sp(double x);

}} // namespace cc::ui
