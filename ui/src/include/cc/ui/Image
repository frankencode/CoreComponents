/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/ui/Surface>
#include <cc/ui/types>
#include <cc/Color>
#include <cc/Array>

namespace cc::ui {

/** \class Image cc/ui/Image
  * \ingroup ui
  * \brief 2-dimensional color matrix
  * \todo move internal state to implementation file
  */
class Image: public Surface
{
public:
    /** Create a null image
      */
    Image() = default;

    /** Create an image of \a width x \a height pixels
      */
    Image(int width, int height):
        Surface{new State{width, height}}
    {}

    /** Width of the image in pixels
      */
    int width() const { return me().width_; }

    /** Height of the image in pixels
      */
    int height() const { return me().height_; }

    /** Get the size of the image
      */
    Size size() const { return Size{static_cast<double>(me().width_), static_cast<double>(me().height_)}; }

    /** Number of bytes per image row
      */
    int pitch() const { return me().pitch(); }

    /** Directly access image data
      */
    Bytes data() { return me().data_; }

    /** Get a reference to the \a i-th pixel
      */
    Color &pixel(int i) { return me().data_.item<Color>(i); }

    /** Get a constant reference to the \a i-th pixel
      */
    const Color &pixel(int i) const { return me().data_.item<Color>(i); }

    /** Number of pixels
      */
    long count() const { return me().data_.count() / sizeof(Color); }

    /** Clear the entire image with color \a c
      */
    void clear(Color c);

    /** Convert the entire image from normal alpha to pre-multiplied alpha
      */
    void premultiply();

    /** Convert the entire image from pre-multiplied alpha to normal alpha
      */
    void normalize();

    /** Create a deep copy of this image
      */
    Image copy() const { return Image{new State{me()}}; }

    /** Copy this image to \a target at (\a x, \a y)
      */
    void copyToXy(Out<Image> target, int x, int y) const;

    /** Add background \a paper to each transparent pixel
      */
    void applyOver(Color paper);

    /** Check if all pixels of this image are opaque
      */
    bool checkOpaque() const;

    /** Replace this image by a low-pass monochrome version of itself
      * \param radius Blur radius
      * \param shadowColor Replacement color
      */
    void shadowBlur(int radius, Color shadowColor);

private:
    struct State: public Surface::State
    {
        State(const State &other):
            width_{other.width_},
            height_{other.height_},
            data_{other.data_.items(), other.data_.count()}
        {}

        State(int width, int height):
            width_{width > 0 ? width : 1},
            height_{height > 0 ? height : 1},
            data_{Bytes::allocate(width_ * height_ * static_cast<long>(sizeof(Color)))}
        {}

        ~State();

        cairo_surface_t *cairoSurface() override;

        int pitch() const { return width_ * sizeof(Color); }

        int width_ { 0 };
        int height_ { 0 };
        Bytes data_;
        mutable cairo_surface_t *cairoSurface_ { nullptr };
    };

    explicit Image(State *state):
        Surface{state}
    {}

    State &me() { return Object::me.as<State>(); }
    const State &me() const { return Object::me.as<State>(); }
};

} // namespace cc::ui
