/*
 * Copyright (C) 2017-2019 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Notifier>
#include <atomic>
#include <memory>

namespace cc {
namespace ui {

class TimeWorker;

class Timer
{
public:
    class Instance: public Object
    {
    public:
        void start();
        void startAt(double startTime);
        void startIn(double delayTime);
        void stop();

        bool isActive() const { return isActive_; }
        double firstTime() const { return firstTime_; }
        double startTime() const { return startTime_; }
        double interval() const { return interval_; }

        Notifier timeout;

    private:
        friend class Timer;
        friend class TimeWorker;
        friend class ApplicationInstance;

        Instance(double interval);

        mutable std::atomic_bool isActive_ { false };
        double firstTime_ { 0 };
        double startTime_ { 0 };
        double interval_;
        std::atomic<void *> timeout_ { nullptr };
    };

    Timer(double interval = 0):
        instance_{new Instance{interval}}
    {}

    Timer(double interval, const std::function<void()> &onTimeout):
        instance_{new Instance{interval}}
    {
        (*this)->timeout->connect(onTimeout);
    }

    Timer(const std::function<void()> &onTimeout):
        instance_{new Instance{0}}
    {
        (*this)->timeout->connect(onTimeout);
    }

    Instance *operator->() { return instance_; }
    const Instance *operator->() const { return instance_; }

private:
    Ref<Instance> instance_;
};

}} // namespace
