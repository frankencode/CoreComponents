/*
 * Copyright (C) 2020-2022 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/ui/Control>
#include <cc/ui/Timer>
#include <cc/ui/Carrier>

namespace cc::ui {

/** \class Flickable cc/ui/Flickable
  * \ingroup ui
  * \brief %Control with variable sized movable contents
  * \todo make the style plugin deliver the behavioral parameters for the flickable
  */
class Flickable: public Control
{
public:
    /** Create a primordial flickable
      */
    Flickable();

    /** Create a new flickable
      */
    explicit Flickable(Out<Flickable> self):
        Control{new State}
    {
        self = *this;
    }

    /** Create a new flickable of given size (\a width, \a height)
      */
    Flickable(double width, double height):
        Control{new State}
    {
        size(Size{width, height});
    }

    /** Create a new flickable with custom \a carrier
      */
    explicit Flickable(const View &carrier):
        Control{new State{carrier}}
    {}

    /** Get the carrier
      */
    View carrier() const { return me().carrier(); }

protected:
    struct State: public Control::State
    {
        State(const View &carrier = Carrier{});

        View carrier() const { return carrier_; }

        void insertChild(View child) override;

        void layout(const Layout &layout) override;

        virtual void preheat();
        virtual void positionCarrierOnResize();

    protected:
        void keepFocusControlInView();

        bool carrierInsideBoundary() const;
        Point carrierStep(Point p, double b = 0);

        void carrierFlyStart();
        void carrierBounceStart();
        void carrierTraverseStart(Step distance);
        void carrierStop();
        void timerStop();

        void carrierFly();
        void carrierBounce();
        void carrierTraverse();
        void carrierStopped();

        Property<double> maxFlyTime { 1.5 };
        Property<double> maxSpeed { [this]{ return 3 * size().max(); } };
        Property<double> minHoldTime { 0.1 };
        Property<double> boundary { dp(60) };
        Property<double> maxBounceTime { 0.6 };
        Property<double> traverseTime { 0.5 };

        Property<double> wheelGranularity { 3 * std::ceil(style().itemHeight2()) };
        Property<double> maxWheelTime { 0.1 };
        Property<bool> wheelInversion { style().wheelInversion() };
        Property<bool> wheelBouncing { true };

        Property<Control> focusControl;

        View carrier_;
        Control overwrittenControl_;
        bool isDragged_ { false };
        Point dragStart_;
        Point carrierOrigin_;

        Point lastDragPos_;
        double lastDragTime_;
        double releaseSpeedMagnitude_;
        Step speed_;

        enum class TimerMode { Stopped, Flying, Bouncing, Traversing };
        TimerMode timerMode_ { TimerMode::Stopped };

        Timer timer_;
        double lastTime_;

        Point startPos_;
        Point finalPos_;

        bool wasFlying_ { false };
        bool carrierAtRest_ { true };
    };

    explicit Flickable(State *newState):
        Control{newState}
    {}

    explicit Flickable(CreateState createState):
        Control{createState}
    {}

    State &me() { return View::me().as<State>(); }
    const State &me() const { return View::me().as<State>(); }
};

} // namespace cc::ui
