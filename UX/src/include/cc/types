/*
 * Copyright (C) 2020 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Rect>
#include <cc/Color>
#include <cc/Property>
#include <cc/Object>
#include <cc/bitmask>
#include <cc/str>
#include <cmath>

namespace cc {

/** \internal
  */
enum class UpdateReason {
    Moved,
    Changed,
    Resized,
    Exposed,
    // Shown,
    Hidden,
    Faded
};

/** %Text anti-aliasing strategy
  */
enum class FontSmoothing: uint8_t {
    Default      = 0, ///< %Use platform default font anti-aliasing strategy
    None         = 1, ///< Do not perform any anti-aliasing
    Grayscale    = 2, ///< Smooth font outlines with shades of gray
    RgbSubpixel  = 3, ///< Smooth font outlines with shades of gray taking advantage of the arragement of the LCD cells of an horizontal RGB display
    BgrSubpixel  = 4, ///< Smooth font outlines with shades of gray taking advantage of the arragement of the LCD cells of an horizontal RGB display
    VrgbSubpixel = 5, ///< Smooth font outlines with shades of gray taking advantage of the arragement of the LCD cells of an vertical RGB display
    VbgrSubpixel = 6  ///< Smooth font outlines with shades of gray taking advantage of the arragement of the LCD cells of an vertical BGR display
};

inline uint8_t operator+(FontSmoothing smoothing) { return static_cast<uint8_t>(smoothing); }

inline String str(FontSmoothing smoothing)
{
    switch (smoothing) {
        case FontSmoothing::Default     : return "FontSmoothing::Default";
        case FontSmoothing::None        : return "FontSmoothing::None";
        case FontSmoothing::Grayscale   : return "FontSmoothing::Grayscale";
        case FontSmoothing::RgbSubpixel : return "FontSmoothing::RgbSubpixel";
        case FontSmoothing::BgrSubpixel : return "FontSmoothing::BgrSubpixel";
        case FontSmoothing::VrgbSubpixel: return "FontSmoothing::VrgbSubpixel";
        case FontSmoothing::VbgrSubpixel: return "FontSmoothing::VbgrSubpixel";
    }

    return String{};
}

/** %Glyph outline hinting strategy
  */
enum class OutlineHinting: uint8_t {
    Default = 0, ///< %Use platform default outline hinting strategy
    None    = 1, ///< Do not perform any outline hinting
    Slight  = 2, ///< Hint the glyph outlines slightly towards the pixel raster
    Medium  = 3, ///< Hint the glyph outlines slightly more towards the pixel raster
    Full    = 4, ///< Hint the glyph outlines fully with the pixel raster
};

inline uint8_t operator+(OutlineHinting hinting) { return static_cast<uint8_t>(hinting); }

inline String str(OutlineHinting outlineHinting)
{
    switch (outlineHinting) {
        case OutlineHinting::Default: return "OutlineHinting::Default";
        case OutlineHinting::None   : return "OutlineHinting::None";
        case OutlineHinting::Slight : return "OutlineHinting::Slight";
        case OutlineHinting::Medium : return "OutlineHinting::Medium";
        case OutlineHinting::Full   : return "OutlineHinting::Full";
    }

    return String {};
}

/** %Font metrics hinting mode
  */
enum class MetricsHinting: uint8_t {
    Default = 0, ///< %Use platform default metrics hinting mode
    Off     = 1, ///< Disable metrics hinting
    On      = 2  ///< Enable metrics hinting
};

inline uint8_t operator+(MetricsHinting hinting) { return static_cast<uint8_t>(hinting); }

inline String str(MetricsHinting metricsHinting)
{
    switch (metricsHinting) {
        case MetricsHinting::Default: return "MetricsHinting::Default";
        case MetricsHinting::On     : return "MetricsHinting::On";
        case MetricsHinting::Off    : return "MetricsHinting::Off";
    }

    return String{};
};

/** %Font slant
  */
enum class Slant: uint8_t {
    Normal = 0, ///< Regular font slant
    Italic = 1, ///< Cursive font slant
    Oblique = Italic ///< Cursive font slant
};

inline uint8_t operator+(Slant slant) { return static_cast<uint8_t>(slant); }

inline String str(Slant slant)
{
    switch (slant) {
        case Slant::Normal : return "Slant::Normal";
        case Slant::Italic : return "Slant::Italic";
        // case Slant::Oblique: return "Oblique";
    }

    return String{};
}

/** %Visual thickness of a font
  */
enum class Weight: uint8_t {
    Thin       = 1, ///< Thinnest thickness
    ExtraLight = 2, ///< Extra-light thickness
    Light      = 3, ///< Light thickness
    Normal     = 4, ///< Regular thickness
    Medium     = 5, ///< Medium thickness
    SemiBold   = 6, ///< Semi-bold thickness
    Bold       = 7, ///< Bold thickness
    ExtraBold  = 8, ///< Extra-bold thickness
    Black      = 9  ///< Black thickness
};

inline uint8_t operator+(Weight weight) { return static_cast<uint8_t>(weight); }

inline String str(Weight weight)
{
    switch (weight) {
        case Weight::Thin      : return "Weight::Thin";
        case Weight::ExtraLight: return "Weight::ExtraLight";
        case Weight::Light     : return "Weight::Light";
        case Weight::Normal    : return "Weight::Normal";
        case Weight::Medium    : return "Weight::Medium";
        case Weight::SemiBold  : return "Weight::SemiBold";
        case Weight::Bold      : return "Weight::Bold";
        case Weight::ExtraBold : return "Weight::ExtraBold";
        case Weight::Black     : return "Weight::Black";
    }

    return String{};
}

/** %Font width to height ratio
  */
enum class Stretch: uint8_t {
    UltraCondensed = 1, ///< Ultra-condensed stretch
    ExtraCondensed = 2, ///< Extra-condensed stretch
    Condensed      = 3, ///< Condensed stretch
    SemiCondensed  = 4, ///< Semi-condensed stretch
    Normal         = 5, ///< Regular stretch
    SemiExpanded   = 6, ///< Semi-expanded stretch
    Expanded       = 7, ///< Expanded stretch
    ExtraExpanded  = 8, ///< Extra-expanded stretch
    UltraExpanded  = 9  ///< Ultra-expanded stretch
};

inline uint8_t operator+(Stretch stretch) { return static_cast<uint8_t>(stretch); }

inline String str(Stretch stretch)
{
    switch (stretch) {
        case Stretch::UltraCondensed: return "Stretch::UltraCondensed";
        case Stretch::ExtraCondensed: return "Stretch::ExtraCondensed";
        case Stretch::Condensed     : return "Stretch::Condensed";
        case Stretch::SemiCondensed : return "Stretch::SemiCondensed";
        case Stretch::Normal        : return "Stretch::Normal";
        case Stretch::SemiExpanded  : return "Stretch::SemiExpanded";
        case Stretch::Expanded      : return "Stretch::Expaned";
        case Stretch::ExtraExpanded : return "Stretch::ExtraExpanded";
        case Stretch::UltraExpanded : return "Stretch::UltraExpanded";
    }

    return String{};
}

/** %Font pitch
  */
enum class Pitch: uint8_t {
    Fixed    = 0, ///< All glyphs have same width
    Variable = 1  ///< Glyphs have varying widths
};

inline uint8_t operator+(Pitch pitch) { return static_cast<uint8_t>(pitch); }

inline String str(Pitch pitch)
{
    switch (pitch) {
        case Pitch::Fixed:    return "Pitch::Fixed";
        case Pitch::Variable: return "Pitch::Variable";
    }

    return String{};
}

/** %Text alignment
  */
enum class TextAlign: uint8_t {
    Left,   ///< %Align left
    Right,  ///< %Align right
    Center, ///< %Align center
    Justify ///< %Align justify
};

inline uint8_t operator+(TextAlign align) { return static_cast<uint8_t>(align); }

inline String str(TextAlign align)
{
    switch (align) {
        case TextAlign::Left:    return "TextAlign::Left";
        case TextAlign::Right:   return "TextAlign::Right";
        case TextAlign::Center:  return "TextAlign::Center";
        case TextAlign::Justify: return "TextAlign::Justify";
    }

    return String{};
}

/** %Text decoration
  */
enum class Decoration: uint8_t {
    None      = 0, ///< No text decoration
    Underline = 1, ///< Underline decoration
    StrikeOut = 2  ///< Strike-out decoration
};

CC_BITMASK(Decoration)

inline String str(Decoration decoration)
{
    if (decoration == Decoration::None) return "Decoration::None";
    List<String> parts;
    if (decoration & Decoration::Underline) parts << "Decoration::Underline";
    if (decoration & Decoration::StrikeOut) parts << "Decoration::StrikeOut";
    return parts.join('|');
}

/** %Alignment within a ManagedColumnLayout
  */
enum class ColumnAlign {
    Auto,  ///< %Align according to language preference
    Left,  ///< %Align left
    Right, ///< %Align right
    Center ///< %Align center
};

inline String str(ColumnAlign align)
{
    switch (align) {
        case ColumnAlign::Auto:   return "ColumnAlign::Auto";
        case ColumnAlign::Left:   return "ColumnAlign::Left";
        case ColumnAlign::Right:  return "ColumnAlign::Right";
        case ColumnAlign::Center: return "ColumnAlign::Center";
    }

    return String{};
}

/** %Alignment within a ManagedRowLayout
  */
enum class RowAlign {
    Top,    ///< %Align top
    Bottom, ///< %Align bottom
    Center  ///< %Align center
};

inline String str(RowAlign align)
{
    switch (align) {
        case RowAlign::Top:    return "RowAlign::Top";
        case RowAlign::Bottom: return "RowAlign::Bottom";
        case RowAlign::Center: return "RowAlign::Center";
    }

    return String{};
}

/** %Mouse button flags
  */
enum class MouseButton: unsigned int {
    None   = 0, ///< No mouse button
    Left   = 1, ///< Left mouse button
    Right  = 2, ///< Right mouse button
    Middle = 4, ///< Middle mouse button
    X1     = 8, ///< X1 mouse button
    X2     = 16 ///< X2 mouse button
};

CC_BITMASK(MouseButton)

inline String str(MouseButton mask)
{
    List<String> parts;
    if (mask & MouseButton::Left)   parts << "MouseButton::Left";
    if (mask & MouseButton::Right)  parts << "MouseButton::Right";
    if (mask & MouseButton::X1)     parts << "MouseButton::X1";
    if (mask & MouseButton::X2)     parts << "MouseButton::X2";
    if (mask & MouseButton::Middle) parts << "MouseButton::Middle";
    return parts.join('|');
}

/** Type of input action
  */
enum class PointerAction {
    Moved, ///< Pointer was moved
    Pressed, ///< Pointer has been pressed
    Released ///< Pointer has been released
};

inline String str(PointerAction action)
{
    switch (action) {
        case PointerAction::Moved   : return "PointerAction::Moved";
        case PointerAction::Pressed : return "PointerAction::Pressed";
        case PointerAction::Released: return "PointerAction::Released";
    };

    return String{};
}

/** %Keyboard key action
  */
enum class KeyAction {
    Pressed, ///< Key was pressed
    Released ///< Key was released
};

inline String str(KeyAction action)
{
    switch (action) {
        case KeyAction::Pressed : return "KeyAction::Pressed";
        case KeyAction::Released: return "KeyAction::Released";
    };

    return String{};
}

/** Predefined cursor shapes
  */
enum class CursorShape {
    Arrow,                    ///< Arrow cursor
    IBeam,                    ///< I-beam text selection cursor
    Wait,                     ///< Hourglass cursor
    CrossHair,                ///< Crosshair cursor
    WaitArrow,                ///< Arrow cursor with an hourglass
    ResizeNorthWestSouthEast, ///< Resizing cursor (NW to SE)
    ResizeNorthEastSouthWest, ///< Resizing cursor (NE to SW)
    ResizeWestEast,           ///< Resizing cursor (W to E)
    ResizeNorthSouth,         ///< Resizing cursor (N to S)
    ResizeCross,              ///< Resiging cursor
    Forbidden,                ///< Forbidden action cursor
    Hand                      ///< Grabbing hand cursor
};

inline String str(CursorShape shape)
{
    switch (shape) {
        case CursorShape::Arrow                   : return "CursorShape::Arrow";
        case CursorShape::IBeam                   : return "CursorShape::IBeam";
        case CursorShape::Wait                    : return "CursorShape::Wait";
        case CursorShape::CrossHair               : return "CursorShape::CrossHair";
        case CursorShape::WaitArrow               : return "CursorShape::WaitArrow";
        case CursorShape::ResizeNorthWestSouthEast: return "CursorShape::ResizeNorthWestSouthEast";
        case CursorShape::ResizeNorthEastSouthWest: return "CursorShape::ResizeNorthEastSouthWest";
        case CursorShape::ResizeWestEast          : return "CursorShape::ResizeWestEast";
        case CursorShape::ResizeNorthSouth        : return "CursorShape::ResizeNorthSouth";
        case CursorShape::ResizeCross             : return "CursorShape::ResizeCross";
        case CursorShape::Forbidden               : return "CursorShape::Forbidden";
        case CursorShape::Hand                    : return "CursorShape::Hand";
    };

    return String{};
}

/** %Orientation
  */
enum class Orientation {
    Vertical,              ///< Portrait orientation
    Horizontal,            ///< Landscape orientation
    Portrait = Vertical,   ///< Portrait orientation
    Landscape = Horizontal ///< Landscape orientation
};

inline String str(Orientation orientation)
{
    switch (orientation) {
        case Orientation::Horizontal: return "Orientation::Horizontal";
        case Orientation::Vertical  : return "Orientation::Vertical";
    };

    return String{};
}

/** %Button style
  */
enum class ButtonStyle {
    Regular, ///< Regular button
    Floating, ///< Floating Action Button (FAB)
    TinyFloating, ///< Tiny Floating Action Button (FAB)
    FloatingWithLabel ///< Extended Floating Action Button (FAB with label)
};

inline String str(ButtonStyle style)
{
    switch (style) {
        case ButtonStyle::Regular: return "ButtonStyle::Regular";
        case ButtonStyle::Floating: return "ButtonStyle::Floating";
        case ButtonStyle::TinyFloating: return "ButtonStyle::TinyFloating";
        case ButtonStyle::FloatingWithLabel: return "ButtonStyle::FloatingWithLabel";
    };

    return String{};
}

/** %Point delta type
  */
using Step = Vector<double, 2>;

/** Scaling type
  */
using Scale = Vector<double, 2>;

/** Check if a text can be wrapped behind a certain text fragment
  */
using TextWrapBehind = Fun<bool(const String &/*text*/, long /*byteOffset*/, long /*byteCount*/)>;

/** Check if \a text can be wrapped behind a text fragment
  * \param text Text to be wrapped
  * \param byteOffset Offset of the text fragment
  * \param byteCount Length of the text fragment
  */
bool textWrapBehindDefault(const String &text, long byteOffset, long byteCount);

/** Touch device ID
  */
using TouchDeviceId = std::int64_t;

/** Touch finger ID
  */
using TouchFingerId = std::int64_t;

/** Translate \a angle in degree (0..360) to radians (0..2*M_PI)
  */
constexpr double degree(double angle)
{
    return M_PI * angle / 180;
}

/** Translate design units (\a x) to pixels
  */
double dp(double x);

/** Translate scaleable design units (\a x) to pixels
  */
double sp(double x);

/** Translate grid units (\a n) to pixels
  */
double gu(int n);

} // namespace cc
