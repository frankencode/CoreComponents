/*
 * Copyright (C) 2021 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the GNU General Public License version 3
 * (see CoreComponents/LICENSE-gpl-3.0).
 *
 */

#include <cc/TlsClientOptions>
#include <gnutls/gnutls.h>
#include <gnutls/x509.h>

namespace cc {

struct TlsClientOptions::State: public Object::State
{
    State()
    {
    }

    ~State()
    {
        if (prio_) gnutls_priority_deinit(prio_);
        if (cred_) gnutls_certificate_free_credentials(cred_);
        if (psk_) gnutls_psk_free_client_credentials(psk_);
    }

    void setCredentials(const String &certPath, const String &keyPath)
    {
        if (!cred_) {
            int ret = gnutls_certificate_allocate_credentials(&cred_);
            if (ret != GNUTLS_E_SUCCESS) throw TlsError{ret};
        }
        certPath_ = certPath;
        keyPath_ = keyPath;
        int ret = gnutls_certificate_set_x509_key_file(cred_, certPath, keyPath, GNUTLS_X509_FMT_PEM);
        if (ret != GNUTLS_E_SUCCESS) throw TlsError{ret};
    }

    void setTrustFilePath(const String &filePath)
    {
        if (!cred_) {
            int ret = gnutls_certificate_allocate_credentials(&cred_);
            if (ret != GNUTLS_E_SUCCESS) throw TlsError{ret};
        }
        trustFilePath_ = filePath;
        int ret = gnutls_certificate_set_x509_trust_file(cred_, filePath, GNUTLS_X509_FMT_PEM);
        if (ret < 0) throw TlsError{ret};
        defaultTrust_ = false;
    }

    void setSystemTrust()
    {
        if (!cred_) {
            int ret = gnutls_certificate_allocate_credentials(&cred_);
            if (ret != GNUTLS_E_SUCCESS) throw TlsError{ret};
        }
        if (trustFilePath_ != "") trustFilePath_ = "";
        int ret = gnutls_certificate_set_x509_system_trust(cred_);
        if (ret < 0) throw TlsError{ret};
        defaultTrust_ = false;
    }

    void setCiphers(const String &ciphers)
    {
        ciphers_ = ciphers;
        if (prio_) gnutls_priority_deinit(prio_);
        int ret = gnutls_priority_init(&prio_, ciphers_, NULL);
        if (ret != GNUTLS_E_SUCCESS) throw TlsError{ret};
    }

    void setPsk(const Bytes &key, const Bytes &identifier)
    {
        pskKey_ = key;
        pskIdentifier_ = identifier;
        if (!psk_) {
            int ret = gnutls_psk_allocate_client_credentials(&psk_);
            if (ret != GNUTLS_E_SUCCESS) throw TlsError{ret};
        }
        gnutls_datum_t pskKeyDatum_ { pskKey_.bytes(), static_cast<unsigned>(pskKey_.size()) };
        gnutls_datum_t pskIdentifierDatum_ { pskIdentifier_.bytes(), static_cast<unsigned>(pskIdentifier_.size()) };
        int ret = gnutls_psk_set_client_credentials2(
            psk_,
            &pskKeyDatum_,
            &pskIdentifierDatum_,
            GNUTLS_PSK_KEY_RAW
        );
        if (ret != GNUTLS_E_SUCCESS) throw TlsError{ret};
    }

    void establish(gnutls_session_t session)
    {
        if (defaultTrust_) setSystemTrust();
        if (cred_) {
            int ret = gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, cred_);
            if (ret != GNUTLS_E_SUCCESS) throw TlsError{ret};
        }
        if (psk_) {
            int ret = gnutls_credentials_set(session, GNUTLS_CRD_PSK, psk_);
            if (ret != GNUTLS_E_SUCCESS) throw TlsError{ret};
        }
        if (prio_) {
            int ret = gnutls_priority_set(session, prio_);
            if (ret != GNUTLS_E_SUCCESS) throw TlsError{ret};
        }
        else {
            int ret = gnutls_set_default_priority(session);
            if (ret != GNUTLS_E_SUCCESS) throw TlsError{ret};
        }
    }

    String serverName_;
    String certPath_;
    String keyPath_;
    String trustFilePath_;
    String ciphers_;
    Bytes pskKey_;
    Bytes pskIdentifier_;
    bool defaultTrust_ { true };

    gnutls_certificate_credentials_t cred_ { nullptr };
    gnutls_psk_client_credentials_t psk_ { nullptr };
    gnutls_priority_t prio_ { nullptr };
};

} // namespace cc
