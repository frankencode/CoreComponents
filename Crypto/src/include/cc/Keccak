/*
 * Copyright (C) 2023 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the GNU General Public License version 3
 * (see CoreComponents/LICENSE-gpl-3.0).
 *
 */

#pragma once

#include <cc/Bytes>
#include <cstring>
#include <bit>

namespace cc {

/** Default padding policy for Keccak
  */
struct KeccakPadding {
    static constexpr uint8_t Suffix = 0;
    static constexpr int Length = 0;
};

/** Padding policy for NIST SHA3
  */
struct Sha3Padding {
    static constexpr uint8_t Suffix = 0b10;
    static constexpr int Length = 2;
};

/** Padding policy for NIST SHAKE128 and SHAKE256
  */
struct ShakePadding {
    static constexpr uint8_t Suffix = 0b1111;
    static constexpr int Length = 4;
};

/** Default policy for reading input bytes
  */
template<int Capacity, class Padding>
class KeccakSource
{
public:
    static constexpr int FeedRate = (1600 - Capacity) / 8; ///< Rate of the sponge function (in bytes)

    static_assert(Padding::Length <= 6);

    KeccakSource(const Bytes &data, long offset = 0):
        data_{data},
        offset_{offset}
    {
        assert(0 <= offset);
    }

    uint8_t readByte()
    {
        uint8_t ch = 0;
        if (offset_ < data_.count()) {
            ch = data_[offset_];
        }
        else {
            if (offset_ == data_.count()) {
                ch = Padding::Suffix;
                ch |= 1 << Padding::Length;
            }
            if (offset_ % FeedRate == FeedRate - 1) ch |= 1 << 7;
        }
        ++offset_;
        return ch;
    }

    bool eoi() const
    {
        return offset_ > data_.count();
    }

private:
    const Bytes &data_;
    long offset_;
};

/** Default policy for writing output bytes
  */
class KeccakSink
{
public:
    KeccakSink(Out<Bytes> data, long offset = 0):
        data_{*data},
        offset_{offset}
    {
        assert(0 <= offset);
        assert(data != None{} && offset < data->count());
    }

    void writeByte(uint8_t ch)
    {
        if (offset_ < data_.count()) {
            data_[offset_] = ch;
            ++offset_;
        }
    }

    bool eoi() const
    {
        return offset_ >= data_.count();
    }

private:
    Bytes &data_;
    long offset_;
};

/** \class Keccak cc/Keccak
  * \ingroup crypto
  * \brief Keccak sponge function
  * \tparam Capacity %Capacity of the sponge function
  * \tparam Padding Additional padding sequence to apply
  * \tparam Source Policy of reading input bytes and automatically applying padding bytes
  *
  * The %Keccak template class implements the Keccak[c] sponge function according to NIST.FIPS.202, chapter 5.2.
  *
  * \todo Optimize further, 2x speedup is plausible.
  */
template<int Capacity = 1024, class Padding = KeccakPadding, class Source = KeccakSource<Capacity, Padding>, class Sink = KeccakSink >
class Keccak
{
    static_assert(Capacity % 8 == 0);

public:
    static constexpr int FeedRate = (1600 - Capacity) / 8; ///< Rate of the sponge function (in bytes)

    /** Create new Keccak instance
      */
    Keccak();

    /** Create new Keccak instance
      * \param key Initial state bytes
      */
    Keccak(const Bytes &key);

    /** Absorb a chunk of input data (FeedRate bytes at a time)
      * \param source %Source to read a single chunk of data from
      * \return true if more data can be absorbed
      */
    bool absorb(Source source);

    /** Generate output bytes out of the sponge (FeedRate bytes at a time)
      * \param sink %Sink to write output bytes to
      */
    void squeeze(Sink sink);


private:
    #if 0
    static uint64_t generateRoundWord(int ir);
    static uint64_t rc(uint8_t t);
    #endif

    uint64_t state(int l) const
    {
        assert(0 <= l && l < 25);
        return state_[l];
    }

    uint64_t &state(int l)
    {
        assert(0 <= l && l < 25);
        return state_[l];
    }

    void permutate();
    void rnd(int ir);

    void theta();
    void rho();
    void pi();
    void chi();
    void iota(int ir);

    uint64_t state_[25];

    static constexpr uint_fast8_t shuffle_[25] = { 1, 10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1 };
    static constexpr uint_fast8_t shift_[25] = { 0, 1, 62, 28, 27, 36, 44, 6, 55, 20, 3, 10, 43, 25, 39, 41, 45, 15, 21, 8, 18, 2, 61, 56, 14 };

    static constexpr uint64_t roundWord_[24] = {
        0x1ull,
        0x8082ull,
        0x800000000000808Aull,
        0x8000000080008000ull,
        0x808Bull,
        0x80000001ull,
        0x8000000080008081ull,
        0x8000000000008009ull,
        0x8Aull,
        0x88ull,
        0x80008009ull,
        0x8000000Aull,
        0x8000808Bull,
        0x800000000000008Bull,
        0x8000000000008089ull,
        0x8000000000008003ull,
        0x8000000000008002ull,
        0x8000000000000080ull,
        0x800Aull,
        0x800000008000000Aull,
        0x8000000080008081ull,
        0x8000000000008080ull,
        0x80000001ull,
        0x8000000080008008ull
    };
};

template<int Capacity, class Padding, class Source, class Sink>
Keccak<Capacity, Padding, Source, Sink>::Keccak()
{
    ::memset(state_, 0, sizeof(state_));
}

template<int Capacity, class Padding, class Source, class Sink>
Keccak<Capacity, Padding, Source, Sink>::Keccak(const Bytes &key)
{
    for (int i = 0; i < FeedRate;) {
        uint64_t lane = 0;
        do {
            lane |= static_cast<uint64_t>(key(i, 0)) << ((i & 7) << 3);
            ++i;
        } while ((i & 7) != 0 && i < FeedRate);
        state((i - 1) >> 3) ^= lane;
    }
}

template<int Capacity, class Padding, class Source, class Sink>
bool Keccak<Capacity, Padding, Source, Sink>::absorb(Source source)
{
    for (int i = 0; i < FeedRate;) {
        uint64_t lane = 0;
        do {
            lane |= static_cast<uint64_t>(source.readByte()) << ((i & 7) << 3);
            ++i;
        } while ((i & 7) != 0 && i < FeedRate);
        state((i - 1) >> 3) ^= lane;
    }

    permutate();

    return !source.eoi();
}

template<int Capacity, class Padding, class Source, class Sink>
void Keccak<Capacity, Padding, Source, Sink>::squeeze(Sink sink)
{
    while (!sink.eoi()) {
        int i = 0;
        for (int l = 0; l < 25 && i < FeedRate && !sink.eoi(); ++l) {
            uint64_t lane = state(l);
            for (int z = 0; z < 8 && i < FeedRate && !sink.eoi(); ++z) {
                sink.writeByte(lane);
                lane >>= 8;
            }
        }
        if (i == FeedRate) permutate();
    }
}

template<int Capacity, class Padding, class Source, class Sink>
void Keccak<Capacity, Padding, Source, Sink>::permutate()
{
    for (int ir = 0; ir < 24; ++ir) {
        rnd(ir);
    }
}

template<int Capacity, class Padding, class Source, class Sink>
void Keccak<Capacity, Padding, Source, Sink>::rnd(int ir)
{
    theta();
    rho();
    pi();
    chi();
    iota(ir);
}

template<int Capacity, class Padding, class Source, class Sink>
void Keccak<Capacity, Padding, Source, Sink>::theta()
{
    uint64_t work[5];

    for (int l = 0; l < 5; ++l) {
        work[l] = state(l);
        work[l] ^= state(l + 5);
        work[l] ^= state(l + 10);
        work[l] ^= state(l + 15);
        work[l] ^= state(l + 20);
    }

    for (int l = 0; l < 25;) {
        state(l) ^= work[4] ^ std::rotl(work[1], 1);
        ++l;
        state(l) ^= work[0] ^ std::rotl(work[2], 1);
        ++l;
        state(l) ^= work[1] ^ std::rotl(work[3], 1);
        ++l;
        state(l) ^= work[2] ^ std::rotl(work[4], 1);
        ++l;
        state(l) ^= work[3] ^ std::rotl(work[0], 1);
        ++l;
    }
}

template<int Capacity, class Padding, class Source, class Sink>
void Keccak<Capacity, Padding, Source, Sink>::rho()
{
    for (int t = 1; t < 25; ++t) {
        state(t) = std::rotl(state(t), shift_[t]);
    }
}

template<int Capacity, class Padding, class Source, class Sink>
void Keccak<Capacity, Padding, Source, Sink>::pi()
{
    uint64_t work[2];

    work[0] = state(1);
    for (int i = 1; i < 25; ++i) {
        int g = shuffle_[i];
        work[1] = state(g);
        state(g) = work[0];
        work[0] = work[1];
    }
}

template<int Capacity, class Padding, class Source, class Sink>
void Keccak<Capacity, Padding, Source, Sink>::chi()
{
    uint64_t work[2];

    for (int l = 0; l < 25;) {
        work[0] = state(l + 0);
        work[1] = state(l + 1);
        state(l) ^= (~state(l + 1) & state(l + 2));
        ++l;
        state(l) ^= (~state(l + 1) & state(l + 2));
        ++l;
        state(l) ^= (~state(l + 1) & state(l + 2));
        ++l;
        state(l) ^= (~state(l + 1) & work[0]     );
        ++l;
        state(l) ^= (~work[0]      & work[1]     );
        ++l;
    }
}

template<int Capacity, class Padding, class Source, class Sink>
void Keccak<Capacity, Padding, Source, Sink>::iota(int ir)
{
    state(0) ^= roundWord_[ir];
}

#if 0
template<int Capacity, class Padding, class Source, class Sink>
uint64_t Keccak<Capacity, Padding, Source, Sink>::generateRoundWord(int ir)
{
    uint64_t sugar = 0;
    int ir7 = ir * 7;
    for (int j = 0; j < 7; ++j) {
        sugar ^= rc(j + ir7) << ((1 << j) - 1);
    }
    return sugar;
}

template<int Capacity, class Padding, class Source, class Sink>
uint64_t Keccak<Capacity, Padding, Source, Sink>::rc(uint8_t t)
{
    uint8_t r = 1 << 7;
    for (int i = 1; i <= t; ++i) {
        const uint8_t r8 = r & 1;
        r >>= 1;
        r ^= (r8 << (7 - 0));
        r ^= (r8 << (7 - 4));
        r ^= (r8 << (7 - 5));
        r ^= (r8 << (7 - 6));
    }
    return r >> 7;
}
#endif

} // namespace cc
