/*
 * Copyright (C) 2007-2017 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/Variant>

namespace cc { namespace syntax { class Token; } }

namespace cc {
namespace meta {

using namespace cc::syntax;

class MetaProtocol;

class MetaObject;
typedef List< Ref<MetaObject> > MetaObjectList;

/** \class MetaObject cc/meta/MetaObject
  * \brief Duck-typed object
  * \TODO slit into two separate classes MetaObject and MetaPrototype(based on MetaObject)
  */
class MetaObject: public VariantMap
{
public:
    static Ref<MetaObject> create(const String &className = "");

    String className() const { return className_; }
    Variant toVariant() const;
    String toString() const;

    bool hasProtocol() const;
    const MetaProtocol *protocol() const { return protocol_; }

    bool hasChildren() const { return children_->count() > 0; }
    MetaObjectList *children() { return children_; }
    const MetaObjectList *children() const { return children_; }

    Ref<MetaObject> clone() const;

    virtual Ref<MetaObject> produce() const {
        return MetaObject::create(className());
    }

    virtual void autocomplete(const MetaObject *prototype);

    virtual void realize(const CharArray *text, Token *objectToken) {}

protected:
    friend class MetaProtocol;

    MetaObject(const String &className = "", const MetaProtocol *protocol = nullptr);
    ~MetaObject();

    static Token *nameToken(const CharArray *text, Token *objectToken, const String &memberName);
    static Token *valueToken(const CharArray *text, Token *objectToken, const String &memberName);
    static Token *childToken(Token *objectToken, int childIndex);

private:
    String className_;
    Ref<const MetaProtocol> protocol_;
    Ref<MetaObjectList> children_;
};

}} // namespace cc::meta
