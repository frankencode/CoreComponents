/*
 * Copyright (C) 2007-2019 Frank Mertens.
 *
 * Distribution and use is allowed under the terms of the zlib license
 * (see cc/LICENSE-zlib).
 *
 */

#pragma once

#include <cc/variant>
#include <cc/meta/exceptions>

namespace cc {
namespace meta {

class MetaObject;
typedef List< Ref<MetaObject> > MetaObjectList;

/** \class MetaObject cc/meta/MetaObject
  * \brief Duck-typed object
  */
class MetaObject: public VariantMap
{
public:
    static Ref<MetaObject> create(const string &className = "");

    string className() const { return className_; }
    variant toVariant() const;
    string toString() const;

    bool hasChildren() const { return children_->count() > 0; }
    MetaObjectList *children() { return children_; }
    const MetaObjectList *children() const { return children_; }

    Ref<MetaObject> clone() const;

    virtual Ref<MetaObject> produce() const {
        return MetaObject::create(className());
    }

    void autocomplete(MetaObject *target) const;

    virtual void realize();

protected:
    friend class MetaProtocol;

    MetaObject(const string &className = "");
    ~MetaObject();

private:
    string className_;
    Ref<MetaObjectList> children_;
};

}} // namespace cc::meta
